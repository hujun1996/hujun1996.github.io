<!DOCTYPE HTML>
<html lang="en">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="HERO">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.3.0">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://example.com">
    <!--SEO-->

<meta name="keywords" content="软件测试理论" />


<meta name="description" content="一、软件研发流程1. 软件产品的特点计算机软件是由程序及其文档组成，关于软件的特点，我们可以总结如下：
a. 是一种逻辑产品，与物质产品有很大的区别。
b. 软件产品的生产主要是研制，生产成本主..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    软件测试 |
    
    HERO
</title>


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 5.4.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner3.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='hujun'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <h2>
                生活如此简单有趣
            </h2>
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://example.com">
                        HERO</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                Home</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="软件测试">
            
            软件测试
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-none-link" href="/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/" rel="tag">软件测试理论</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2021/08/01</span>
    </span>
    
    <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="一、软件研发流程"><a href="#一、软件研发流程" class="headerlink" title="一、软件研发流程"></a>一、软件研发流程</h1><h3 id="1-软件产品的特点"><a href="#1-软件产品的特点" class="headerlink" title="1. 软件产品的特点"></a>1. <strong>软件产品的特点</strong></h3><p>计算机软件是由程序及其文档组成，关于软件的特点，我们可以总结如下：</p>
<p>a. 是一种逻辑产品，与物质产品有很大的区别。</p>
<p>b. 软件产品的生产主要是研制，生产成本主要在开发和研制，开发研制完成后，通过复制就产生了大量软件产品。</p>
<p>c. 软件产品不会用坏，不存在磨损，消耗。</p>
<p>d. 生产主要是脑力劳动，还末完全摆脱手工开发方式，大部分产品是”定做”的。</p>
<h3 id="2-软件工程"><a href="#2-软件工程" class="headerlink" title="2. 软件工程"></a>2. 软件工程</h3><h4 id="1-什么是软件工程？"><a href="#1-什么是软件工程？" class="headerlink" title="1.什么是软件工程？"></a>1.什么是软件工程？</h4><p>软件工程一直以来都缺乏一个统一的定义，很多学者、组织机构都分别给出了自己的定义。但具体总结起来就是几个关键点：</p>
<p>​    系统化、规范化、可管理、将软件开发变成一项工程。</p>
<h4 id="2-为什么需要软件工程？"><a href="#2-为什么需要软件工程？" class="headerlink" title="2. 为什么需要软件工程？"></a>2. 为什么需要软件工程？</h4><p>早期做软件是小作坊式的生产，后来随着硬件的提升，用户的需求。小作坊明显解决不了问题，就出现了软件危机</p>
<p>软件危机(Software Crisis) 是计算机软件在它的开发和维护过程中所遇到的一系列严重问题。</p>
<p>软件危机主要表现在：软件产品质量低和生产效率低，后期维护也不得力。</p>
<p>为了更好解决诸如此类的问题，软件规模化，工厂化的生产越发成为需要，软件工程便呼之欲出啦，需要解决以下问题：</p>
<p>软件开发进度难以预测</p>
<p>软件开发成本难以控制</p>
<p>用户对产品功能难以满足</p>
<p>软件产品质量无法保证</p>
<p>软件产品难以维护</p>
<p>软件缺少适当的文档资料</p>
<h3 id="3-软件的开发模型"><a href="#3-软件的开发模型" class="headerlink" title="3. 软件的开发模型"></a>3. 软件的开发模型</h3><p>软件测试工作与软件开发模型息息相关，在不同的软件开发模型中，测试的任务和作用也不相同，因此测试人员要充分了解软件开发模型，以便找准自己在其中的定位与任务。</p>
<p>软件开发模型规定了软件开发应遵循的步骤，是软件开发的导航图，它能够清晰、直观地表达软件开发的全过程，以及每个阶段要进行的活动和要完成的任务。</p>
<p>开发人员在选择开发模型时，要根据软件的特点、开发人员的参与方式选择稳定可靠的开发模型自有软件开发以来，软件开发模型也从最初的“边做边改”发展出了多个模型，下面以软件开发模型发展历史为顺序，介绍几个典型的开发模型。</p>
<h4 id="1）瀑布模型"><a href="#1）瀑布模型" class="headerlink" title="1）瀑布模型"></a>1）瀑布模型</h4><p>在20世纪70年代，由温斯顿·罗伊斯（Winston Royce）提出，瀑布模型一直是惟一被广泛采用的软件过程模型，现在它仍然是软件工程中应用得非常广泛的过程模型。瀑布模型是一种线形的、顺序的软件开发模型，主要分为6个阶段:可行性计划研究→需求分析→软件设计→编码→测试→运行维护，其开发过程如图下面所示。</p>
<p><img src="https://pic.imgdb.cn/item/6137286b44eaada739a559d4.png"></p>
<p>在瀑布模型中，软件开发的各项活动严格按照这条线进行，只有当一个阶段任务完成之后才能开始下一个阶段。软件开发的每一个阶段都要有结果产出，结果经过审核验证之后作为下一个阶段的输入，下个阶段才可以顺利进行。如果结果审核验证不通过，则需要返回修改。</p>
<p>瀑布模型为整个项目划分了清晰的检查点，当一个阶段完成之后，只需要把全部精力放置在后面的开发上即可，它有利于大型软件开发人员的组织管理及工具的使用与研究，可以提高开发的效率。</p>
<p>但是瀑布模型是严格按照线性方式进行的，无法适应用户需求变更，用户只能等到最后才能看到开发成果，增加了开发风险。如果开发人员与客户对需求理解有偏差，到最后开发完成后，最终成果与客户需求可能会差之千里。使用瀑布模型开发软件时，如果早期犯的错误在项目完成后才发现，此时再修改原来的错误需要付出巨大的代价。瀑布模型要求每一个阶段必须有结果产出，这就势必增加了文档的数量，使软件开发的工作量变大。</p>
<h4 id="2）V模型"><a href="#2）V模型" class="headerlink" title="2）V模型"></a>2）V模型</h4><p>V 模型最早是由Paul Rook 在20 世纪80 年代后期提出的，V 模型在英国国家计算中心文献中发布，目的是改进软件开发的效率和效果。它是软件测试最具代表性的测试模型之一。</p>
<p>在传统的开发模型中，如瀑布模型，通常把软件测试过程作为在需求分析、概要设计、详细设计和编码全部完成之后的一个阶段，尽管有时软件测试工作会占整个项目周期一半的时间，但是仍然被认为软件测试只是一个收尾工作，而不是主要的工程。故对以前的测试模型进行了一定程度的改进，V 模型其实是软件开发瀑布模型的变种，反映了软件测试活动与软件开发过程(从分析到设计)的关系，如图</p>
<p><img src="https://pic.imgdb.cn/item/6137291744eaada739a684bb.png"></p>
<p>V 模型从左到右，描述了基本的开发过程和测试行为，明确地标明了测试工程中存在的不同级别以及测试阶段和开发过程各阶段的对应关系。图中箭头代表了时间方向，左边下降的是开发过程各阶段，与此相对应的是右边上升的部分，即测试过程各阶段。</p>
<p>V 模型指出，单元和集成测试是验证程序设计，单元测试主要由白盒测试工程对代码进行测试，但目前国内真正做白盒测试的企业不多。这主要有两大原因：第一，白盒测试投入的成本很高，并且产出不明显，很多企业不希望投入更多的资源去做这项工作;第二，白盒测试对测试工程师的要求较高，在目前系统测试还没有完全成熟的情况下很难真正地开展白盒测试。而集成测试是介于白盒测试与系统测试之间的一种测试，也叫灰盒测试，由于它与白盒测试和系统测试之间没有明显的界限，所以在实际的测试过程中，即使开展集成测试也是由系统测试工程师来完成。</p>
<p>系统测试主要验证系统设计，检测系统功能、性能的质量特性是否达到系统设计的指标，由测试人员和用户进行软件的确认测试和验收测试，以及对需求说明书进行测试，以确定软件的实现是否满足用户需求或合同要求。</p>
<p>V 模型存在一定的局限性，它把测试过程作为在需求分析、概要设计、详细设计及编码之后的一个阶段。如果不做白盒测试，那么其实都是在系统完成集成后才开始系统测试的，这样需求分析阶段隐藏的问题一直到后期的验收测试才被发现，因此修改缺陷的成本就高了很多。</p>
<h4 id="3）快速原型模型"><a href="#3）快速原型模型" class="headerlink" title="3）快速原型模型"></a>3）快速原型模型</h4><p>快速原型模型与瀑布模型正好相反，它在最初确定用户需求时快速构造岀一个可以运行的软件原型，这个软件原型向用户展示待开发软件的全部或部分功能和性能，客户对该原型进行审核评价，然后给出更具体的需求意见，这样逐步丰富细化需求，最后开发人员与客户达成最终共识，确定客户的真正需求。确定客户的真正需求之后，开始真正的软件开发。</p>
<p>**快速原型模型类似于建造房子，确定客户对房子的需求之后快速地搭建一个房子模型**，由客户对房子模型进行评价，房子的样式、功能、布局等是否满足需求，哪里需要改进等，最后确定了客户对房子的要求，就开始真正地建造房子。该模型的开发过程如图</p>
<p><img src="https://pic.imgdb.cn/item/6137293344eaada739a6b314.png"></p>
<p>与瀑布模型相比，快速原型模型克服了需求不明确带来的风险，适用于不能预先确定需求的软件项目。但快速原型模型关键在于快速构建软件原型，准确地设计出软件原型存在定的难度。此外，这种开发模型也不利于开发人员对产品进行扩展。</p>
<h4 id="4）-迭代模型"><a href="#4）-迭代模型" class="headerlink" title="4） 迭代模型"></a>4） 迭代模型</h4><p>迭代模型又称为增量模型或演化模型，它将一个完整的软件拆分成不同的组件，然后逐个组件地开发测试，每完成一个组件就展现给客户，让客户确认这一部件功能和性能是否达到客户需求，最终确定无误，将组件集成到软件体系结构中。</p>
<p>整个开发工作被组织为一系列短期、简单的小项目，称为一系列迭代，每一个迭代都需要经过需求分析→软件设计→编码→测试的过程，其开发过程如图</p>
<p><img src="https://pic.imgdb.cn/item/6137294b44eaada739a6dd95.png"></p>
<p>在迭代模型中，第一个迭代(即第一个组件)往往是软件基本需求的核心部分，第一个组件完成之后，经过客户审核评价形成下一个组件的开发计划，包括对核心产品的修改和新功能的发布，这样重复迭代步骤直到实现最终完善的产品。</p>
<p>迭代模型可以很好地适应客户需求变更，它逐个组件地交付产品，客户可以经常看到产品，如果某个组件没有满足客户需求，则只需要更改这一个组件，降低了软件开发的成本与风险。但是选代模型需要将开发完成的组件集成到软件体系结构中，这样会有集成失败的风险，因此要求软件必须有开放式的体系结构。此外，迭代模型逐个组件地开发修改，很容易退化为“边做边改”的开发形式，从而失去对软件开发过程的整体控制。</p>
<h4 id="5）螺旋模型"><a href="#5）螺旋模型" class="headerlink" title="5）螺旋模型"></a>5）螺旋模型</h4><h5 id="螺旋模型由巴利·玻姆-Barry-Boehm-于1988年提岀，该模型融合了瀑布模型、快速原型模型，它最大的特点是引入了其他模型所忽略的风险分析，如果项目不能排除重大风险，就停止项目从而减小损失。这种模型比较适合开发复杂的大型软件。"><a href="#螺旋模型由巴利·玻姆-Barry-Boehm-于1988年提岀，该模型融合了瀑布模型、快速原型模型，它最大的特点是引入了其他模型所忽略的风险分析，如果项目不能排除重大风险，就停止项目从而减小损失。这种模型比较适合开发复杂的大型软件。" class="headerlink" title="螺旋模型由巴利·玻姆(Barry Boehm)于1988年提岀，该模型融合了瀑布模型、快速原型模型，它最大的特点是引入了其他模型所忽略的风险分析，如果项目不能排除重大风险，就停止项目从而减小损失。这种模型比较适合开发复杂的大型软件。"></a>螺旋模型由巴利·玻姆(Barry Boehm)于1988年提岀，该模型融合了瀑布模型、快速原型模型，它最大的特点是引入了其他模型所忽略的风险分析，如果项目不能排除重大风险，就停止项目从而减小损失。这种模型比较适合开发复杂的大型软件。</h5><p>螺旋模型将整个项目开发过程划分为几个不同的阶段，每个阶段按部就班地执行，这种划分方式采用了瀑布模型。每个阶段在开始之前都要进行风险评估，如果能消除重大风险则可以开始该阶段任务。在每个阶段，首先构建软件原型，根据快速原型模型完成这个迭代过程，产出最终完善的产品，然后进入下一个阶段，同样下一个阶段开始之前也要进行风险评估，这样循环往复直到完成所有阶段的任务。螺旋模型的若干个阶段是沿着螺线方式进行的，如图</p>
<p><img src="https://pic.imgdb.cn/item/6137295c44eaada739a6f9c2.png"></p>
<p>(1)制订计划:确定软件目标，制订实施方案，并且列出项目开发的限制条件。</p>
<p>(2)风险分析:评价所制订的实施方案，识别风险并消除风险。</p>
<p>(3)实施工程:开发产品并进行验证</p>
<p>(4)客户评估:客户对产品进行审核评估，提出修正建议，制订下一步计划。</p>
<p>在螺旋模型中，每一个选代都需要经过这4个步骤，直到最后得到完善的产品，可以进行提交。</p>
<p>螺旋模型强调了风险分析，这意味着对可选方案和限制条件都进行了评估，更有助于将软件质量作为特殊目标融入产品开发之中。它以小分段构建大型软件，使成本计算变得简单容易，而且客户始终参与每个阶段的开发，保证了项目不偏离正确方向，也保证了项目的可控制性。</p>
<h3 id="4-软件开发生命周期"><a href="#4-软件开发生命周期" class="headerlink" title="4.软件开发生命周期"></a>4.软件开发生命周期</h3><p>软件和其他产品一样，都有一个从“出生”到“消亡”的过程，这个过程称为软件的生命周期。在软件的生命周期中，软件测试是非常重要的一个环节。</p>
<p>软件生命周期分为多个阶段，每个阶段有明确的任务，这样就使得结构复杂、管理复杂的软件开发变得容易控制和管理。通常，可将软件生命周期划分为6个阶段，如图所示。</p>
<p><img src="https://pic.imgdb.cn/item/6137296e44eaada739a71972.png"></p>
<p>每个阶段的目标任务及含义分别介绍如下：</p>
<p>****第1阶段:问题定义****，该阶段由软件开发方与需求方共同讨论，主要确定软件的开发目标及其可行性。</p>
<p>****第2阶段:需求分析****，该阶段对软件需求进行更深入的分析，划分出软件需要实现的功能模块，并制作成文档。需求分析在软件的整个生命周期中起着非常重要的作用，它直接关系到后期软件开发的成功率。在后期开发中，需求可能会发生变化，因此，在进行需求分析时，应考虑到需求的变化，以保证整个项目的顺利进行。</p>
<p>****第3阶段:软件设计****，该阶段在需求分析结果的基础上，对整个软件系统进行设计，如系统框架设计、数据库设计等。</p>
<p>****第4阶段:软件开发****，该阶段在软件设计的基础上，选择一种编程语言进行开发。在开发过程中，必须要制订统一的、符合标准的程序编写规范，以保证程序的可读性、易维护性以及可移植性。</p>
<p>****第5阶段:软件测试****，该阶段是软件开发完成后对软件进行测试，以查找软件设计与软件开发过程中存在的问题并加以修正。软件测试过程包括单元测试、集成测试、系统测试、验收测试等4个阶段;测试的方法以黑盒测试、白盒测试或者两者结合的形式进行。在测试过程中，为减少测试的随意性，需要制订详细的测试计划并严格遵守;测试完成之后，要对测试结果进行分析并对测试结果以文档的形式汇总。</p>
<p>****第6阶段:软件维护****，软件完成测试并投入使用之后，面对庞大的用户群体，软件可能无法满足用户使用需求，此时就需要对软件进行维护升级以延续软件的使用寿命。软件的维护包括纠错性维护和改进性维护两个方面。软件维护是软件生命周期中持续时间最长的阶段。</p>
<h3 id="5-项目团队里面的成员及其职责"><a href="#5-项目团队里面的成员及其职责" class="headerlink" title="5. 项目团队里面的成员及其职责"></a>5. <strong>项目团队里面的成员及其职责</strong></h3><p>项目经理：驱动整个项目的运转，负责制定计划，安排人力，管理进度，协调团队，进行重大决策。</p>
<p>架构师 / 系统工程师：技术专家，经验丰富，负责整个系统的体系架构的设计以及关键模块的设计。</p>
<p>程序员 / 开发人员：设计、编写软件，并修复软件中的缺陷。</p>
<p>测试工程师：负责找出软件产品存在的问题并报告。</p>
<p>实施/运维工程师：负责软件系统安装部署、升级维护。</p>
<p>资料工程师：负责编写软件产品附带的文件和联机帮助文档</p>
<p>配置管理员：负责管理程序员写的代码和资料工程师写的文档资料，并组合成一个软件包。</p>
<p>QA：质量监管人员</p>
<h1 id="二、软件测试的基础理论"><a href="#二、软件测试的基础理论" class="headerlink" title="二、软件测试的基础理论"></a>二、软件测试的基础理论</h1><h3 id="1-软件测试的定义"><a href="#1-软件测试的定义" class="headerlink" title="1.软件测试的定义"></a>1.软件测试的定义</h3><p><em><strong>*软件测试的发展史：*<em><strong>20世纪60年代（软件工程建立前），为表明程序正确而进行测试。1972年在北卡罗来纳大学举行了首届软件测试正式会议。对软件测试给出了一个早期定义：</strong></em>*测试是为了让程序能够按照预期运行而建立的一种信心。*</strong></em></p>
<p>1979年，Glenford Myers的《软件测试艺术》，对测试做了定义：<em><strong>*测试是为发现错误而执行的一个程序或者系统的过程。*</strong></em></p>
<p>20世纪90年代，测试工具盛行起来。1996年提出的测试能力成熟度模型TMM（Testing Maturity Model）。</p>
<p>2009年，James A. Whittake提出探索式测试理论</p>
<p>****什么是软件测试？软件测试是做什么的？****软件测试是使用人工或者自动手段运行或测定某个系统的过程，检验系统是否满足规定的需求，并找出预期结果与实际结果的差异</p>
<h3 id="2-测试的对象"><a href="#2-测试的对象" class="headerlink" title="2.测试的对象"></a>2.测试的对象</h3><p>根据软件的定义，软件包括程序、文档，所以软件测试并不仅仅是程序测试。软件测试贯穿于整个软件生命周期中。</p>
<p>由于在整个软件生命周期中，各阶段有不同的测试对象，形成了不同开发阶段的不同类型的测试。需求分析、概要设计、详细设计以及程序编码等各阶段产生的文档，包括需求规格说明、概要设计规格说明、详细设计规格说明以及源程序，都应作为“软件测试”的对象。</p>
<p><img src="https://pic.imgdb.cn/item/6137297f44eaada739a73529.png"></p>
<h3 id="3-软件测试的目的"><a href="#3-软件测试的目的" class="headerlink" title="3.软件测试的目的"></a>3.软件测试的目的</h3><p>软件测试的目的大家都能随口说出，如查找程序中的错误、保证软件质量、检验软件是否符合客户需求等。这些都对，但它们只是笼统地对软件测试目的进行了概括，比较片面结合软件开发、软件测试与客户需求可以将软件测试的目的归结为以下几点。</p>
<p><strong>1)</strong> 预防缺陷，减少产品的风险：对于软件开发来说，软件测试通过找到的问题缺陷帮助开发人员找到开发过程中存在的问题，包括软件开发的模式、工具、技术等方面存在的问题与不足，预防下次缺陷的产生。</p>
<p>2）****发现被测对象与用户需求之间的差异（俗称找BUG</p>
<p><strong>3)</strong> <em><strong>*通过测试活动发现并解决缺陷，增加人们对被测对象的质量信心；*</strong></em></p>
<p><strong>4)</strong> ****通过测试活动，发现被测对象的质量信息，为决策者提供数据依据****；</p>
<h3 id="4-软件测试所遵循的原则"><a href="#4-软件测试所遵循的原则" class="headerlink" title="4.软件测试所遵循的原则"></a>4.软件测试所遵循的原则</h3><p>软件测试经过几十年的发展，人们提出了很多测试的基本原则用于指导软件测试工作。制定软件测试的基本原则有助于提高测试工作的效率和质量，能让测试人员以最少的人力物力、时间等尽早发现软件中存在的问题，测试人员应该在测试原则的指导下进行测试工作。下面介绍一下业界公认的6个基本原则。</p>
<h4 id="1-测试应该基于客户的需求"><a href="#1-测试应该基于客户的需求" class="headerlink" title="1.测试应该基于客户的需求"></a>1.测试应该基于客户的需求</h4><p>所有的测试工作都应该建立在满足客户需求的基础上，从客户角度来看，最严重的错误就是软件无法满足要求。有时候，软件产品的测试结果非常完美，但却不是客户最终想要的产品，那么软件产品的开发就是失败的，而测试工作也是没有任何意义的。因此测试应依照客户的需求配置环境，并且按照客户的使用习惯进行测试并评价结果。</p>
<h4 id="2-测试要尽早进行"><a href="#2-测试要尽早进行" class="headerlink" title="2.测试要尽早进行"></a>2.测试要尽早进行</h4><p>软件的错误存在于软件生命周期的各个阶段，因此应该尽早开展测试工作，把软件测试贯穿到软件生命周期的各个阶段中，这样测试人员能够尽早地发现和预防错误，降低错误修复的成本。尽早地开展测试工作有利于帮助测试人员了解软件产品的需求和设计，从而预测测试的难度和风险，制订出完善的计划和方案，提高测试的效率。</p>
<h4 id="3-穷尽测试是不可能的"><a href="#3-穷尽测试是不可能的" class="headerlink" title="3.穷尽测试是不可能的"></a>3.穷尽测试是不可能的</h4><p>由于时间和资源的限制，进行完全(各种输入和输出的全部组合)的测试是不可能的测试人员可以根据测试的风险和优先级等确定测试的关注点，从而控制测试的工作量，在测试成本、风险和收益之间求得平衡。</p>
<h4 id="4-测试缺陷要符合“二八”定理"><a href="#4-测试缺陷要符合“二八”定理" class="headerlink" title="4.测试缺陷要符合“二八”定理"></a>4.测试缺陷要符合“二八”定理</h4><p>缺陷的“二八”定理也称为Pareto原则、缺陷集群效应，一般情况下，软件80%缺陷会集中在20%模块中，缺陷并不是平均分布的。因此在测试时，要抓住主要矛盾，如果发现某些模块比其他模块具有更多的缺陷，则要投入更多的人力、精力重点测试这些模块以提高测试效率。</p>
<h4 id="5-杀虫剂的悖论"><a href="#5-杀虫剂的悖论" class="headerlink" title="5.杀虫剂的悖论"></a>5.杀虫剂的悖论</h4><p>我们都知道虫子的抗药性原理，即一种药物使用久了，虫子就会产生抗药性。而在软件测试中，缺陷也是会产生免疫性的。同样的测试用例被反复使用，发现缺陷的能力就会越来越差;测试人员对软件越熟悉越会忽略一些看起来比较小的问题，发现缺陷的能力也越差，这种现象被称为软件测试的“杀虫剂”现象。它主要是由于测试人员没有及时更新测试用例或者是对测试用例和测试对象过于熟悉，形成了思维定式。</p>
<p>要克服这种情况，就要不断对测试用例进行修改和评审，不断增加新的测试用例，同时，测试人员也要发散思维，不能只是为了完成测试任务而做一些输入和输出的对比。</p>
<h4 id="6-没有缺陷的软件是不存在的"><a href="#6-没有缺陷的软件是不存在的" class="headerlink" title="6.没有缺陷的软件是不存在的"></a>6.没有缺陷的软件是不存在的</h4><p>没有缺陷的软件是不存在的，软件测试是为了找出软件中的缺陷，而不是为了证明软件没有缺陷。</p>
<h3 id="5-测试风险"><a href="#5-测试风险" class="headerlink" title="5.测试风险"></a>5.测试风险</h3><p>软件测试中的软件风险分析是根据预测软件将出现的风险，制定软件测试计划并排列优先等级，风险分析是对软件中潜在的问题进行识别、估计和评价的过程。</p>
<p>风险也包括进度风险、质量风险、人员风险、变更风险、成本风险等</p>
<h3 id="6-软件的质量"><a href="#6-软件的质量" class="headerlink" title="6.软件的质量"></a>6.软件的质量</h3><p>软件质量就是“软件与明确的和隐含的定义的需求相一致的程度”   </p>
<p> 明确的需求指：软件符合明确叙述的功能和性能需求、文档中明确描述的开发标准；</p>
<p>隐性的需求指：所有专业开发的软件都应具有的隐含特征的程度，需要引导的用户需求。</p>
<h4 id="1-软件的质量特点"><a href="#1-软件的质量特点" class="headerlink" title="1.软件的质量特点"></a>1.软件的质量特点</h4><p>功能性：软件在指定条件下使用时，满足用户明确和隐含需求的功能的能力</p>
<p>可靠性：软件在指定条件下使用时，维持规定的性能级别的能力</p>
<p>易用性：在指定条件下使用时，软件被理解、学习、使用和吸引用户的能力</p>
<p>可维护：软件从一种环境迁移到另外一种环境的能力</p>
<h4 id="2-那些原因影响软件的质量"><a href="#2-那些原因影响软件的质量" class="headerlink" title="2. 那些原因影响软件的质量"></a>2. 那些原因影响软件的质量</h4><p>由于软件自身的特点和目前的软件开发模式使得隐藏在软件内部的质量缺陷无法完全根除,因此每一款软件都会存在一些质量问题。影响软件质量的因素有很多,下面介绍几种比较常见的影响因素。</p>
<h4 id="a-需求模糊"><a href="#a-需求模糊" class="headerlink" title="a. 需求模糊"></a>a. 需求模糊</h4><p>在软件开发之前,确定软件需求是一项非常重要的工作,它是后面软件设计与软件开发的基础,也是最后软件验收的标准。但是软件需求是不可视的,往往也说不清楚,导致产品设计、开发人员与客户存在一定的理解误差,开发人员对软件的真正需求不明确,结果开发出的产品与实际需求不符,这势必会影响软件的质量。</p>
<p>除此之外,在开发过程中客户往往会一而再再而三地变更需求,导致开发人员频繁地修改代码,这可能会导致软件在设计时期存在不能调和的误差,最终影响软件的质量。</p>
<h4 id="b-开发过程不规范"><a href="#b-开发过程不规范" class="headerlink" title="b. 开发过程不规范"></a>b. 开发过程不规范</h4><p>现代软件开发,大多数团队都将精力放在开发成本与开发周期上,而不太重视团队成员的工作规范,导致团队成员开发“随意性”比较大,这也会影响软件质量,而且一旦最后软件出现质量问题,也很难定责,导致后期维护困难</p>
<h4 id="c-软件开发人员问题"><a href="#c-软件开发人员问题" class="headerlink" title="c. 软件开发人员问题"></a>c. 软件开发人员问题</h4><p>软件是由人开发出来的,因此个人的意识对产品的影响非常大。除了个人技术水平限制,开发人员问题还包括人员流动,新来的成员可能会继承上一任的产品接着开发下去,两个人的思维意识、技术水平等都会不同,导致软件开发前后不一致,进而影响软件质量。</p>
<h4 id="d-软件缺乏质量控制管理"><a href="#d-软件缺乏质量控制管理" class="headerlink" title="d. 软件缺乏质量控制管理"></a>d. 软件缺乏质量控制管理</h4><p>在软件开发行业,并没有一个量化的指标去度量一款软件的质量,软件开发的管理人员更关注开发成本和进度,毕竟这是显而易见的,并且是可以度量的。但软件质量则不同,软件质量无法用具体的量化指标去度量,而且软件开发的质量并没有落实到具体的责任人,因此很少有人关心软件最终的质量。</p>
<h3 id="7-软件测试的分类"><a href="#7-软件测试的分类" class="headerlink" title="7.软件测试的分类"></a>7.软件测试的分类</h3><p>目前，软件测试已经形成一个完整的、体系庞大的学科，不同的测试领域都有不同的测试方法、技术与名称，有很多读者可能也听过类似的黑盒测试、白盒测试、冒烟测试、单元测试等，其实它们是按照不同的分类方法而产生的测试名称。按照不同的分类标准，可以将软件测试分为很多不同的种类，下面我们详细介绍这些软件测试行业的专业名词。</p>
<ol>
<li>按照测试阶段划分</li>
</ol>
<p>①　单元测试</p>
<p>单元测试是软件开发的第一步测试，目的是为了验证软件单元是否符合软件需求与设计。单元测试大多是开发人员进行的自测。</p>
<p>②　冒烟测试</p>
<p>冒烟测试最初是从电路板测试得来的，当电路板做好以后，首先会加电测试，如果电路板没有冒烟再进行其他测试，否则就必须重新设计后再次测试。</p>
<p>后来这种测试理念被引入到软件测试中。在软件测试中，冒烟测试是指软件构建版本建立后，对系统的基本功能进行简单的测试，这种测试重点验证的是程序的主要功能，而不会对具体功能进行深入测试。</p>
<p>如果测试未通过，需要返回给开发人员进行修正;如果测试通过则再进行其他测试。因此，冒烟测试是对新构建版本软件进行的最基本测试。</p>
<p>③　集成测试</p>
<p>集成测试是冒烟测试之后进行的测试，它是将已经测试过的软件单元组合在一起测试它们之间的接口，用于验证软件是否满足设计需求。</p>
<p>④　系统测试</p>
<p>系统测试是将经过测试的软件在实际环境中运行，并与其他系统的成分(如数据库、硬件和操作人员等)组合在一起进行的测试。</p>
<p>⑤　验收测试</p>
<p>验收测试主要是对软件产品说明进行验证，逐行逐字地按照说明书的描述对软件产品进行测试，确保其符合客户的各项要求。</p>
<ol start="2">
<li>按照测试技术分类</li>
</ol>
<p>按照使用的测试技术可以将软件测试分为黑盒测试与白盒测试。</p>
<h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>不需要关注被测对象的内部结构，仅从用户需求的角度去考虑，是否满足显性或者隐性的需求。如图</p>
<p><img src="https://pic.imgdb.cn/item/6137299144eaada739a75259.png"></p>
<h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>白盒测试又叫透明盒测试，它是指测试人员了解软件程序的逻辑结构、路径与运行过程，在测试时，按照程序的执行路径得出结果。白盒测试就是把软件(程序)当作一个透明的盒子，测试人员清楚地知道从输入到输出的每一步过程，如图白盒测试</p>
<p>白盒测试又叫透明盒测试，它是指测试人员了解软件程序的逻辑结构、路径与运行过程，在测试时，按照程序的执行路径得出结果。白盒测试就是把软件(程序)当作一个透明的盒子，测试人员清楚地知道从输入到输出的每一步过程，如图</p>
<p><img src="https://pic.imgdb.cn/item/613729a144eaada739a76d30.png"></p>
<p>相对于黑盒测试来说，白盒测试对测试人员的要求会更高一点，他要求测试人员具有一定的编程能力，而且要熟悉各种脚本语言。但是在软件公司里，黑盒测试与白盒测试并不是界限分明的，在测试一款软件时往往是黑盒测试与白盒测试相结合对软件进行完整全面的测试。</p>
<ol start="3">
<li>按照软件质量分类</li>
</ol>
<p>按照软件质量特性可以将软件测试分为功能测试与性能测试。</p>
<p>①　功能测试</p>
<p>功能测试就是测试软件的功能是否满足客户的需求，包括准确性、易用性、适合性、互操作性等。</p>
<p>②　性能测试</p>
<p>性能测试就是测试软件的性能是否满足客户的需求，性能测试包括负载测试、压力测试、兼容性测试、可移植性测试和健壮性测试。</p>
<ol start="4">
<li>按照自动化程度来分类</li>
</ol>
<p>按照自动化程度可以将软件测试分为手工测试与自动化测试。</p>
<p>①　手工测试</p>
<p>手工测试是测试人员一条一条地执行代码完成测试工作。手工测试比较耗时费力，而且测试人员如果是在疲惫状态下，则很难保证测试的效果。</p>
<p>②　自动化测试</p>
<p>自动化测试是借助脚本、自动化测试工具等完成相应的测试工作，它也需要人工的参与，但是它可以将要执行的测试代码或流程写成脚本，执行脚本完成整个测试工作。</p>
<ol start="5">
<li>按照测试类型分类</li>
</ol>
<p>软件测试类型有多种，包括界面类测试、功能测试、性能测试、安全性测试、文档测试等，其中功能测试与性能测试前面已经介绍，下面主要介绍其他几种测试。</p>
<p>①　界面类测试</p>
<p>界面类测试是验证软件界面是否符合客户需求，包括界面布局是否美观、按钮是否齐全等。</p>
<p>②　安全性测试</p>
<p>安全性测试是测试软件在没有授权的内部或外部用户的攻击或恶意破坏时如何进行处理，是否能保证软件与数据的安全。</p>
<p>③　文档测试</p>
<p>文档测试以需求分析、软件设计、用户手册、安装手册为主，主要验证文档说明与实际软件之间是否存在差异。</p>
<ol start="6">
<li>其他分类</li>
</ol>
<p>还有一些软件测试无法具体归到哪一类，但在测试行业中也会经常进行这些测试，如α测试、β测试、回归测试等，具体介绍如下。</p>
<p><strong>①</strong>　<em><strong>*α测试*</strong></em></p>
<p>α测试是指对软件最初版本进行测试。软件最初版本一般不对外发布，在上线之前，由开发人员和测试人员或者用户协助进行测试。测试人员记录使用过程中出现的错误与问题整个测试过程是可控的。</p>
<p><strong>②</strong>　<em><strong>*β测试*</strong></em></p>
<p>β测试是指对上线之后的软件版本进行测试，此时软件已上线发布，但发布的版本中可能会存在较轻微的Bug，由用户在使用过程中发现错误与问题并进行记录，然后反馈给开发人员进行修复。</p>
<p><strong>③</strong>　<em><strong>*回归测试*</strong></em></p>
<p>当测试人员发现缺陷以后，会将缺陷提交给开发人员，开发人员对程序进行修改，修改之后，测试人员会对修改后的程序重新进行测试，确认原有的缺陷已经消除并且没有引入新的缺陷，这个重新测试的过程就叫作回归测试。回归测试是软件测试工作中非常重要的一部分，软件开发的各个阶段都会进行多次回归测试。</p>
<p><strong>④</strong>　<em><strong>*随机测试*</strong></em></p>
<p>随机测试是没有测试用例、检查列表、脚本或指令的测试，它主要是根据测试人员的经验对软件进行功能和性能抽查。随机测试是根据测试用例说明书执行测试用例的重要补充手段，是保证测试覆盖完整性的有效方式和过程。</p>
<h1 id="三、软件测试的流程"><a href="#三、软件测试的流程" class="headerlink" title="三、软件测试的流程"></a>三、软件测试的流程</h1><h3 id="1-测试需求分析阶段："><a href="#1-测试需求分析阶段：" class="headerlink" title="1.测试需求分析阶段："></a>1.测试需求分析阶段：</h3><p>阅读需求，理解需求，主要就是对业务的学习，分析需求点，参与需求评审会议;</p>
<h3 id="2-测试计划阶段："><a href="#2-测试计划阶段：" class="headerlink" title="2.测试计划阶段："></a>2.测试计划阶段：</h3><p>根据自己的角色说明 如:测试经理主要任务就是编写测试计划，参考软件需求规格说明书，项目总体计划，内容包括测试范围(来自需求文档)，进度安排，人力物力的分配，整体测试策略的制定。风险评估与规避措施有一个制定。测试人员的话一般是领取分配的测试任务;</p>
<h3 id="3-测试设计阶段："><a href="#3-测试设计阶段：" class="headerlink" title="3.测试设计阶段："></a>3.测试设计阶段：</h3><p>主要是编写测试用例，会参考需求文档(原型图)，概要设计，详细设计等文档，用例编写完成之后会进行评审;</p>
<h3 id="4-测试执行阶段："><a href="#4-测试执行阶段：" class="headerlink" title="4.测试执行阶段："></a>4.测试执行阶段：</h3><p>搭建环境，执行冒烟测试(预测试)，然后进入正式测试，bug管理,根据公司情况进行日报,周报跟踪进度及风险控制;</p>
<h3 id="5-测试评估阶段："><a href="#5-测试评估阶段：" class="headerlink" title="5.测试评估阶段："></a>5.测试评估阶段：</h3><p>出测试报告，确认是否可以上线。</p>
<h1 id="四、测试相关文档介绍"><a href="#四、测试相关文档介绍" class="headerlink" title="四、测试相关文档介绍"></a>四、测试相关文档介绍</h1><p>在软件研发过程当中，会产生很多的文档，下面罗列测试阶段所产生的文档，<strong>包含但不仅限于如下文档</strong>。</p>
<table>
<thead>
<tr>
<th><em><strong>*文档的名称*</strong></em></th>
<th><em><strong>*包括但不限于以下内容*</strong></em></th>
<th><em><strong>*文档编写目的*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>测试计划</td>
<td>测试的范围、测试的准则、测试的手段、测试工具、停止的标准、硬/软件环境、测试规划、测试执行、工作量预估、资源安排、进度安排、风险管理等。</td>
<td>明确测试工作内容（范围）、测试工作的方法以及测试工作所需要的各种资源。</td>
</tr>
<tr>
<td>测试用例</td>
<td>用例编号、用例名称、测试背景、测试数据、操作步骤、预期结果、实际结果、优先级、重要级、编写人、执行人、备注等。</td>
<td>避免漏测、多测，能够对项目的需求做一个理解，可以作为测试人员工作量的一个考核。</td>
</tr>
<tr>
<td>缺陷报告</td>
<td>缺陷编号、缺陷描述、严重度、缺陷状态、发现人、发现时间、修复时间、所属版本、所属模块、修复的优先级、详细描述、下一步处理人等。</td>
<td>把软件存在的缺陷准确的描述出来，便于开发人员修正，反映了当前产品的质量状态，更是测试人员价值的体现。</td>
</tr>
<tr>
<td>测试报告</td>
<td>包括项目背景、需求分析、测试时间、测试环境、评审记录、测试范围、测试用例、功能实现清单、缺陷统计、测试统计(包含资源、执行、问题统计)、测试总结是否通过、测试的风险。</td>
<td>把测试的过程和结果写成文档，对发现的问题和缺陷进行分析，为纠正软件的存在的质量问题提供依据，同时为软件验收和交付打下基础。</td>
</tr>
<tr>
<td>测试日、周报</td>
<td>1.当前测试进度的关键性数据(用例执行进度、发现问题情况、待回归的问题)2.遇到哪些测试活动中不能解决的问题风险，需要什么样的帮助。3.下一阶段的工作计划是什么？</td>
<td>要求内容是每日/周测试活动的概述，和下一天/周测试活动的计划，要求反映出当前测试进度，成果及问题。</td>
</tr>
</tbody></table>

    </div>
    
    <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            <span class="reward-type">
                <img class="alipay" src="C:\hexo\themes\hexo-theme-snippet-master\source\img\33.jpg"><b>支付宝打赏</b>
            </span>
            
            
            <span class="reward-type">
                <img class="wechat" src="C:\hexo\themes\hexo-theme-snippet-master\source\img\12.jpg"><b>微信打赏</b>
            </span>
            
        </div>
    </div>
    <p class="reward-tip">
        赞赏是不耍流氓的鼓励
    </p>
</div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">hujun</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2021/08/10/http%E5%8D%8F%E8%AE%AE/" class="pre-post btn btn-default" title='http协议'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            http协议</span>
    </a>
    
    
</div>

<div id="comments">
    
    
<div id="vcomments" class="valine"></div>

<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

<script>
    new Valine({
        av: AV,
        el: '#vcomments',
        appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
        appKey: 'erIpQac4azoCmgfBB7Dl9maa',
        placeholder: '说点什么吧',
        notify: false,
        verify: true,
        avatar: 'mm',
        meta: 'nick,mail'.split(','),
        pageSize: '10',
        path: window.location.pathname,
        lang: 'en'.toLowerCase()
    })
    </script>


</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            Table of Contents
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-text">一、软件研发流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E4%BA%A7%E5%93%81%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">1. 软件产品的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-text">2. 软件工程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%EF%BC%9F"><span class="toc-text">1.什么是软件工程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%EF%BC%9F"><span class="toc-text">2. 为什么需要软件工程？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-text">3. 软件的开发模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-text">1）瀑布模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89V%E6%A8%A1%E5%9E%8B"><span class="toc-text">2）V模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">3）快速原型模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89-%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B"><span class="toc-text">4） 迭代模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">5）螺旋模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B%E7%94%B1%E5%B7%B4%E5%88%A9%C2%B7%E7%8E%BB%E5%A7%86-Barry-Boehm-%E4%BA%8E1988%E5%B9%B4%E6%8F%90%E5%B2%80%EF%BC%8C%E8%AF%A5%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88%E4%BA%86%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B%E3%80%81%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%AE%83%E6%9C%80%E5%A4%A7%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E5%BC%95%E5%85%A5%E4%BA%86%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9E%8B%E6%89%80%E5%BF%BD%E7%95%A5%E7%9A%84%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%A1%B9%E7%9B%AE%E4%B8%8D%E8%83%BD%E6%8E%92%E9%99%A4%E9%87%8D%E5%A4%A7%E9%A3%8E%E9%99%A9%EF%BC%8C%E5%B0%B1%E5%81%9C%E6%AD%A2%E9%A1%B9%E7%9B%AE%E4%BB%8E%E8%80%8C%E5%87%8F%E5%B0%8F%E6%8D%9F%E5%A4%B1%E3%80%82%E8%BF%99%E7%A7%8D%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83%E9%80%82%E5%90%88%E5%BC%80%E5%8F%91%E5%A4%8D%E6%9D%82%E7%9A%84%E5%A4%A7%E5%9E%8B%E8%BD%AF%E4%BB%B6%E3%80%82"><span class="toc-text">螺旋模型由巴利·玻姆(Barry Boehm)于1988年提岀，该模型融合了瀑布模型、快速原型模型，它最大的特点是引入了其他模型所忽略的风险分析，如果项目不能排除重大风险，就停止项目从而减小损失。这种模型比较适合开发复杂的大型软件。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4.软件开发生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F%E9%87%8C%E9%9D%A2%E7%9A%84%E6%88%90%E5%91%98%E5%8F%8A%E5%85%B6%E8%81%8C%E8%B4%A3"><span class="toc-text">5. 项目团队里面的成员及其职责</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA"><span class="toc-text">二、软件测试的基础理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.软件测试的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%8B%E8%AF%95%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.测试的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">3.软件测试的目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%80%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">4.软件测试所遵循的原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B5%8B%E8%AF%95%E5%BA%94%E8%AF%A5%E5%9F%BA%E4%BA%8E%E5%AE%A2%E6%88%B7%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-text">1.测试应该基于客户的需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%8B%E8%AF%95%E8%A6%81%E5%B0%BD%E6%97%A9%E8%BF%9B%E8%A1%8C"><span class="toc-text">2.测试要尽早进行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A9%B7%E5%B0%BD%E6%B5%8B%E8%AF%95%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9A%84"><span class="toc-text">3.穷尽测试是不可能的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B5%8B%E8%AF%95%E7%BC%BA%E9%99%B7%E8%A6%81%E7%AC%A6%E5%90%88%E2%80%9C%E4%BA%8C%E5%85%AB%E2%80%9D%E5%AE%9A%E7%90%86"><span class="toc-text">4.测试缺陷要符合“二八”定理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9D%80%E8%99%AB%E5%89%82%E7%9A%84%E6%82%96%E8%AE%BA"><span class="toc-text">5.杀虫剂的悖论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%B2%A1%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%98%AF%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84"><span class="toc-text">6.没有缺陷的软件是不存在的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B5%8B%E8%AF%95%E9%A3%8E%E9%99%A9"><span class="toc-text">5.测试风险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%B4%A8%E9%87%8F"><span class="toc-text">6.软件的质量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%B4%A8%E9%87%8F%E7%89%B9%E7%82%B9"><span class="toc-text">1.软件的质量特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%82%A3%E4%BA%9B%E5%8E%9F%E5%9B%A0%E5%BD%B1%E5%93%8D%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%B4%A8%E9%87%8F"><span class="toc-text">2. 那些原因影响软件的质量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E9%9C%80%E6%B1%82%E6%A8%A1%E7%B3%8A"><span class="toc-text">a. 需求模糊</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%8D%E8%A7%84%E8%8C%83"><span class="toc-text">b. 开发过程不规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E9%97%AE%E9%A2%98"><span class="toc-text">c. 软件开发人员问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E8%BD%AF%E4%BB%B6%E7%BC%BA%E4%B9%8F%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86"><span class="toc-text">d. 软件缺乏质量控制管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">7.软件测试的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-text">黑盒测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-text">白盒测试</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">三、软件测试的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B5%8B%E8%AF%95%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-text">1.测试需求分析阶段：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-text">2.测试计划阶段：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-text">3.测试设计阶段：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-text">4.测试执行阶段：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-text">5.测试评估阶段：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3%E4%BB%8B%E7%BB%8D"><span class="toc-text">四、测试相关文档介绍</span></a></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    Total:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    Visitors:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash.js"></script>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
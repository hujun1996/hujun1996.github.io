{"meta":{"title":"HERO","subtitle":"","description":"","author":"hujun","url":"http://example.com"},"pages":[],"posts":[{"title":"wireshark的使用","slug":"wireshark的使用","date":"2021-09-04T06:51:53.000Z","updated":"2021-09-04T06:54:37.119Z","comments":true,"path":"2021/09/04/wireshark的使用/","link":"","permalink":"http://example.com/2021/09/04/wireshark%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1","categories":[],"tags":[],"keywords":[]},{"title":"Appium的数据配置与日志收集","slug":"Appium的数据配置与日志收集","date":"2021-09-03T10:18:34.000Z","updated":"2021-09-03T11:18:28.787Z","comments":true,"path":"2021/09/03/Appium的数据配置与日志收集/","link":"","permalink":"http://example.com/2021/09/03/Appium%E7%9A%84%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/","excerpt":"","text":"一、yaml概述1） yaml 简介 YAML 是一种简洁的非标记语言。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。 YAML特别适合在脚本语言中使用，列一下现有的语言实现：Ruby，Java，Perl，Python，PHP，JavaScript等。 YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。比如同一段数据Josn和Yaml的表示分别如下： jason 1&#123; name: &#x27;Tom Smith&#x27;,age: 37,spouse: &#123; name: &#x27;Jane Smith&#x27;, age: 25 &#125;,children: [ &#123; name: &#x27;Jimmy Smith&#x27;, age: 15 &#125;,&#123; name: &#x27;Jenny Smith&#x27;, age: 12 &#125; ] &#125; yaml 12345678910name: Tom Smithage: 37spouse: name: Jane Smith age: 25children: name: Jimmy Smith age: 15 name: Jenny Smith age: 12 2）语法特点【注意】 · 大小写敏感 · 使用缩进表示层级关系 · 缩进时不允许使用Tab键，只允许使用空格。 · 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 3）yaml下载安装 官网 · 下载安装：cmd 输入pip install pyyaml或者pip3 install pyyaml · 安装完成后在python引入yaml检测是否安装成功。 123456C:\\Windows\\System32&gt;pythonPython 3.6.6 (v3.6.6:4cf1f54eb7, Jun 27 2018, 03:37:03) [MSC v.1900 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import yaml&gt;&gt;&gt; 二、yaml数据支持类型1.支持数据类型 1. **纯量(scalars)**：单个的、不可再分的值 2. 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 3. 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 2.纯量 数据最小的单位，不可以再分割。类似于Python中单个变量 1flag 3.list数组 与Python的list结构类似，数组元素使用“-”开头，也可以根据缩进进行数组嵌套。 123456- Jack- Harry- Sunny# 也可以写成一行[Jack,Harry,Sunny] 对应到python的list写法如下： 1[&#x27;Jack&#x27;,&#x27;Harry&#x27;,&#x27;Sunny&#x27;] 4.对象 12345platformName: AndroidplatformVersion: 7.1.2# Yaml 也允许另一种写法，将所有键值对写成一个行内对象。&#123;platformName: Android,platformVersion: 7.1.2&#125; 注意：冒号后面一定要有空格！对应到python字典的写法如下： 1&#123;&#x27;platformName&#x27;: &#x27;Android&#x27;, &#x27;platformVersion&#x27;: &#x27;6.0.1&#x27;&#125; 数据嵌套 yaml数据嵌套表示可以将上面的各类数据根据实际场景进行组合嵌套。 数据场景： Tom Smith 37岁，他有一个妻子叫 Jane Smith，35岁。 另外他有2个孩子，一个叫Jimmy Smith，15岁；另外一个叫Jenny Smith ，12岁。 yaml语法表示如下： familyInfo.yaml 12345678910name: Tom Smithage: 37spouse: name: Jane Smith age: 35children: - name: Jimmy Smith age: 15 - name: Jenny Smith age: 12 转化为Python的写法为： 1&#123;&#x27;name&#x27;:&#x27;Tom Smith&#x27;,&#x27;age&#x27;:37,&#x27;spouse&#x27;:&#123;&#x27;name&#x27;:&#x27;Jane Smith&#x27;,&#x27;age&#x27;:25&#125;,&#x27;childern&#x27;:[&#123;&#x27;name&#x27;:&#x27;Jimmy Smith&#x27;,&#x27;age&#x27;:15&#125;,&#123;&#x27;name&#x27;:&#x27;Jenny Smith&#x27;,&#x27;age&#x27;:12&#125;]&#125; 三、yaml数据操作1.数据读取1）测试场景 · 读取配置中的所有信息 · 读取yaml数据表中Tom Smith的姓名、年龄、信息 · 单独读取配偶的姓名和年龄信息 · 分别读取两个孩子的姓名、年龄信息 2）load方法 load(stream, Loader=Loader) 解析文件流中的第一个YAML文档并生成相应的Python对象。 3）代码实现 12345678910111213141516171819mport yamlfile=open(&#x27;runtest.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(file)print(data)print(data[&#x27;name&#x27;])print(data[&#x27;age&#x27;])print(data[&#x27;spouse&#x27;])print(data[&#x27;spouse&#x27;][&#x27;name&#x27;])print(data[&#x27;spouse&#x27;][&#x27;age&#x27;])print(data[&#x27;children&#x27;])print(data[&#x27;children&#x27;][0][&#x27;name&#x27;])print(data[&#x27;children&#x27;][0][&#x27;age&#x27;])print(data[&#x27;children&#x27;][1][&#x27;name&#x27;])print(data[&#x27;children&#x27;][1][&#x27;age&#x27;]) 2.数据修改如果想改变某个数据，可以使用如下方法： 12345import yamlfile=open(&#x27;runTest.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(file)data[&#x27;name&#x27;]=&#x27;Test123&#x27;print(data[&#x27;name&#x27;]) 注意：此处只是变量类型的数据变更，不会真正修改到yaml配置表中的数据。 3.数据转化方法：dump()可以将Python对象序列化成YAML流。如果stream为None，则返回生成的字符串。 1）测试场景 将下面python数据类型转化为yaml数据类型 2）代码实践 1234567891011import yamlcity=[&#x27;changsha&#x27;,&#x27;wuhan&#x27;,&#x27;beijing&#x27;]person=&#123;&#x27;tom&#x27;:&#x27;18&#x27;&#125;#python dataprint(city)print(person)#yaml dataprint(yaml.dump(city))print(yaml.dump(person)) 运行结果： 1234567[&#x27;changsha&#x27;, &#x27;wuhan&#x27;, &#x27;beijing&#x27;]&#123;&#x27;tom&#x27;: &#x27;18&#x27;&#125;- changsha- wuhan- beijingtom: &#x27;18&#x27; 4.Capability配置数据分离1）测试场景 将capability的各项参数值与代码进行分离。 2）场景分析 我们可以把之前capability中各项写死的配置信息来抽离出来，存放在一个yaml配置文件中，使用 对象数据类型来存储数据；然后调用load()方法读取数据，从而实现数据和代码的分离。 3）代码实践 参数配置表：desired_caps.yaml 123456789platformName: AndroidplatformVersion: 7.1.2deviceName: 127.0.0.1:62025app: D\\kaoyan3.1.0.apknoReset: FalseappPackage: com.tal.kaoyanappActivity: com.tal.kaoyan.ui.activity.SplashActivityip: 127.0.0.1port: 4723 Python脚本 12345678910111213141516171819from appium import webdriverimport yamlfile=open(&#x27;desired_caps.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(file)desired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps) 报错分析 1yaml.scanner.ScannerError: mapping values are not allowed here 该报错说明map对象数据类型写法错误，一般为“：”后面没有留空格。如： platformName:Android 四、日志概述1）日志作用 不管是在项目开发还是测试过程中，项目运行一旦出现问题日志信息就非常重要了。日志是定位问题的重要手段，就像侦探人员要根据现场留下的线索来推断案情。 2）日志级别 脚本运行会有很多的情况，比如调试信息、报错异常信息等。日志要根据这些不同的情况来继续分级管理，不然对于排查问题的筛选会有比较大的干扰。 。日志一般定位的级别如下： 级别 何时使用 DEBUG 调试信息，也是最详细的日志信息。 INFO 证明事情按预期工作。 WARNING 表明发生了一些意外，或者不久的将来会发生问题（如‘磁盘满了’）。软件还是在正常工作。 ERROR 由于更严重的问题，软件已不能执行一些功能了。 CRITICAL 严重错误，表明软件已不能继续运行了。 首先我们日志需要按照info、debug、error等级别来进行区分的。当然这个级别可以自己去设置。在一般的情况下我们普通的输出我们直接用info类型，调试的时候用debug类型，如果预计有错误时那么我们就需要用error类型的日志，一般情况去info级别最为合适。 3）日志格式 日志格式化是为了提高日志的可阅读性，比如：时间+模块+行数+日志具体信息 的内容格式。如果日志信息杂乱无章的全部输出来，这样也不利于定位问题。 4）日志位置 一个项目中会有很多的日志采集点，而日志采集点必须结合业务属性来设置。比如在登录代码执行前可以插入“准备登录..”日志信息,如果登录完成之后，再设置登录的提示日志就会给人造成误解，无法判断到底是登录之前的问题还是登录之后的问题，因此日志采集点的位置很重要。 五、logging 模块1）简介 Python的logging模块提供了通用的日志系统，这个模块提供不同的日志级别，并可以采用不同的方式记录日志，比如文件，HTTP GET/POST，SMTP，Socket等，甚至可以自己实现方式记录日志。 12#导入logging模块import logging 2）logging构成 logging模块包括logger，Handler，Filter，Formatter四个部分。 · Logger 记录器，用于设置日志采集。 · Handler 处理器，将日志记录发送至合适的路径。 · Filter 过滤器，提供了更好的粒度控制，它可以决定输出哪些日志记录。 · Formatter 格式化器，指明了最终输出中日志的格式。 3）logger 记录器 Logger是一个树形层级结构，在使用接口debug，info，warn，error，critical；使用之前必须创建Logger实例，即创建一个记录器，如果没有显式的进行创建，则默认创建一个root logger，并应用默认的日志级别(WARN)，Handler和Formatter。 方法： basicConfig(参数) 为日志记录系统做基本配置。 部分参数 filename 指定日志文件名称 filemode 指定打开文件的模式，如果指定了filename（如果文件模式未指定，则默认为’a） 文件读写模式 1234567891011w 以写方式打开，W 文件若存在，首先要清空，然后（重新）创建a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)r+ 以读写模式打开w+ 以读写模式打开 (参见 w )a+ 以读写模式打开 (参见 a ) format 为处理程序使用指定的格式字符串 datefmt 使用指定的日期/时间格式。样式如果指定了格式字符串，则使用它来指定 格式字符串的类型. level 将根记录器级别设置为指定级别 12345678import logginglogging.basicConfig(level=logging.DEBUG)logging.basicConfig(level=logging.INFO)logging.debug(&#x27;debug info&#x27;)logging.info(&#x27;hello tom！&#x27;)logging.warning(&#x27;warning info&#x27;)logging.error(&#x27;error info&#x27;)logging.critical(&#x27;critical info&#x27;) 4）haddler 处理器 Handler 处理器，将日志记录发送至合适的路径,Handler处理器类型有很多种，比较常用的有三个： 1.streamhandler 将日志记录输出发送到诸如sys.stdout，sys.stderr或任何类似文件流的对象。 2.filehandler 将日志记录输出发送到磁盘文件。 它继承了StreamHandler的输出功能。 3.nullhandler 5）formatter 使用Formatter对象设置日志信息最后的规则、结构和内容，默认的时间格式为%Y-%m-%d %H:%M:%S。 *格式* *描述* %(levelno)s 打印日志级别的数值 %(levelname)s 打印日志级别名称 %(pathname)s 打印当前执行程序的路径 %(filename)s 打印当前执行程序名称 %(funcName)s 打印日志的当前函数 %(lineno)d 打印日志的当前行号 %(asctime)s 打印日志的时间 %(thread)d 打印线程id %(threadName)s 打印线程名称 %(process)d 打印进程ID %(message)s 打印日志信息 使用方法： 12345678import logginglogging.basicConfig(filename=&#x27;runlog.log&#x27;,level=logging.DEBUG,format=&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;)logging.debug(&#x27;debug info&#x27;)logging.info(&#x27;hello tom！&#x27;)logging.warning(&#x27;warning info&#x27;)logging.error(&#x27;error info&#x27;)logging.critical(&#x27;critical info&#x27;) 输出结果： 2021-09-02 11:50:20,094 ��־.py[line:5] DEBUG debug info2021-09-02 11:50:41,359 ��־.py[line:5] DEBUG debug info2021-09-02 11:50:41,360 ��־.py[line:6] INFO hello tom��2021-09-02 11:50:41,360 ��־.py[line:7] WARNING warning info2021-09-02 11:50:41,360 ��־.py[line:8] ERROR error info2021-09-02 11:50:41,360 ��־.py[line:9] CRITICAL critical info 六、logging实践操作1）测试场景 将前面所学的启动考研帮App的脚本增加log采集功能，设置指定的日志格式输出，并将日志保存到指定文件。 2）代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from appium import webdriverimport yamlfrom selenium.common.exceptions import NoSuchElementExceptionimport loggingfile=open(&#x27;desired_caps.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(file)logging.basicConfig(level=logging.INFO,filename=&#x27;runlog.log&#x27;, format=&#x27;%(asctime)s %(filename)s[line:%(lineno)d]%(levelname)s%(message)s&#x27;)desired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]logging.info(&#x27;start app...&#x27;)driver=webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;,desired_caps)def check_cancelBtn(): logging.info(&#x27;check cancelBtn&#x27;) try: cancelBtn = driver.find_element_by_id(&#x27;android:id/button2&#x27;) except NoSuchElementException: logging.info(&#x27;no cancelBtn&#x27;) else: cancelBtn.click()def check_skipBtn(): logging.info(&#x27;check skipBtn&#x27;) try: skipBtn = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;) except NoSuchElementException: logging.info(&#x27;no skipBtn&#x27;) else: skipBtn.click()check_cancelBtn()check_skipBtn() 3）日志格式配置 将log输出格式，输出路径等参数抽离出来作为一个配置表，如下所示： log.conf 1234567891011121314151617181920212223242526272829303132333435[loggers]keys=root,infoLogger[logger_root]level=DEBUGhandlers=consoleHandler,fileHandler[logger_infoLogger]handlers=consoleHandler,fileHandlerqualname=infoLoggerpropagate=0[handlers]keys=consoleHandler,fileHandler[handler_consoleHandler]class=StreamHandlerlevel=INFOformatter=form02args=(sys.stdout,)[handler_fileHandler]class=FileHandlerlevel=INFOformatter=form01args=(&#x27;runlog.log&#x27;, &#x27;a&#x27;)[formatters]keys=form01,form02[formatter_form01]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s[formatter_form02]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s 在需要调用的模块增加如下代码： 1234567import loggingimport logging.configCON_LOG=&#x27;log.conf&#x27;logging.config.fileConfig(CON_LOG)logging=logging.getLogger() 方法： 1fileConfig(fname, defaults=None, disable_existing_loggers=True) 该放在作用是从ConfigParser格式的文件中读取日志配置，同时如果当前脚本有配置log参数，则覆盖当前log配置选项。 6）代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from appium import webdriverimport yamlfrom selenium.common.exceptions import NoSuchElementExceptionimport loggingimport logging.configstream=open(&#x27;desired_caps.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(stream)CON_LOG=&#x27;log.conf&#x27;logging.config.fileConfig(CON_LOG)logging=logging.getLogger()desired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps)def check_updateBtn(): logging.info(&quot;check_pdateBtn&quot;) try: element = driver.find_element_by_id(&#x27;android:id/button2&#x27;) except NoSuchElementException: logging.info(&#x27;update element is not found!&#x27;) else: element.click()def check_skipBtn(): logging.info(&quot;check_skipBtn&quot;) try: element = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;) except NoSuchElementException: logging.info(&#x27;skipBtn element is not found!&#x27;) else: element.click()check_updateBtn()check_skipBtn()","categories":[],"tags":[{"name":"appium的数据配置与日志手机","slug":"appium的数据配置与日志手机","permalink":"http://example.com/tags/appium%E7%9A%84%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA/"}],"keywords":[]},{"title":"Appium基础操作","slug":"Appium基础操作","date":"2021-09-02T09:39:25.000Z","updated":"2021-09-04T05:06:44.218Z","comments":true,"path":"2021/09/02/Appium基础操作/","link":"","permalink":"http://example.com/2021/09/02/Appium%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","excerpt":"","text":"一、name 定位根据name进行定位，对于android来说，就是text属性 但是由于text稳定性不是很好，所以appium 1.5开始废弃了该方法。 123from Capability import *driver.find_element_by_name(&#x27;请输入用户名&#x27;).send_keys(&#x27;&#x27;)driver.find_element_by_name(&#x27;登录&#x27;).click() 二、classname 定位classname定位是根据元素类型来进行定位，在元素class中，一般有id不使用classname定位。 1234from Capability import *driver.find_element_by_class_name(&#x27;android.widget.EditText&#x27;).send_keys(&#x27;hj18594962283&#x27;)driver.find_element_by_class_name(&#x27;android.widget.EditText&#x27;).send_keys(&#x27;jxx.hxx21.&#x27;)driver.find_element_by_class_name(&#x27;android.widget.Button&#x27;).click() 三、相对定位相对定位是先找到该元素的有对应属性的父元素节点，然后基于父元素进行元素定位。 案例 通过打开考研帮注册界面 123456from Capability import driverdriver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_register_text&#x27;).click()root_element=driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_parentlayout&#x27;)root_element.find_element_by_class_name(&#x27;android.widget.ImageView&#x27;).click() 四、xpath定位xpath定位是一种路径定位方式，主要是依赖于元素绝对路径或者相关属性来定位，但是绝对路径xpath执行效率比较低（特别是元素路径比较深的时候），一般使用比较少。通常使用xpath相对路径和属性定位。 表达式 描述 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 nodename 选取此节点的所有子节点。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 使用xpath定位元素来进行登录操作。 1234from Capability import driverdriver.find_element_by_xpath(&#x27;//android.widget.EditText[@text=&quot;请输入用户名&quot;]&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_xpath(&#x27;//*[@class=&quot;android.widget.EditText&quot; and @index=&quot;3&quot;]&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_xpath(&#x27;//android.widget.Button&#x27;).click() 五、LIST 定位List定位首先是使用find_elements_by_XX获取一组相同的class属性的元素，然后使用数组下标来区分标记不同元素进行相关操作。 通过考研帮注册，选择指定头像 1234567891011from Capability import driverdriver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_register_text&#x27;).click()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_userheader&#x27;).click()images=driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/item_image&#x27;)images[2].click()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/save&#x27;).click() 经过实践执行测试用户注册功能时，发现无法完成注册功能，可能与APP有关 执行的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from Capability import driverimport random#进入注册界面选择并设置头像driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_register_text&#x27;).click()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_userheader&#x27;).click()images=driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/item_image&#x27;)images[2].click()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/save&#x27;).click()#注册信息填写username=&#x27;Test&#x27;+&#x27;FLY&#x27;+str(random.randint(1000,9000))print(&#x27;username: %s&#x27; %username)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_username_edittext&#x27;).send_keys(username)password=&#x27;appium&#x27;+str(random.randint(1000,9000))print(&#x27;password: %s&#x27; %password)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_password_edittext&#x27;).send_keys(password)email=&#x27;pwd&#x27;+str(random.randint(1000,9000))+&#x27;@163.com&#x27;print(&#x27;email: %s&#x27; %email)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_email_edittext&#x27;).send_keys(email)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_register_btn&#x27;).click()#院校选择driver.find_element_by_id(&#x27;com.tal.kaoyan:id/perfectinfomation_edit_school_name&#x27;).click()#选择省份driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/more_forum_title&#x27;)[1].click()#选择具体院校--同济大学driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/university_search_item_name&#x27;)[1].click()#专业选择driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_perfectinfomation_major&#x27;).click()#选择经济学类-统计学-经济统计学driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/major_subject_title&#x27;)[1].click()driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/major_group_title&#x27;)[2].click()driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/major_search_item_name&#x27;)[1].click()#点击“进入考研帮”按钮driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_perfectinfomation_goBtn&#x27;).click() 六、UIAutomator定位简介UIAutomator元素定位是 Android 系统原生支持的定位方式，虽然与 xpath 类似，但比它更加好用，且支持元素全部属性定位.定位原理是通过android 自带的android uiautomator的类库去查找元素。使用如下：find_element_by_android_uiautomator() 可以运用UiAutomator元素定位。 定位方法 · id定位 · text定位 · class name定位 id定位是根据元素的resource-id属性来进行定位，使用 UiSelector().resourceId()方法即可。 1234567from Capability import driverdriver.find_element_by_android_uiautomator(&#x27;newUiSelector().resourceId(&quot;com.tal.kaoyan:id/login_email_edittext&quot;)&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_android_uiautomator(&#x27;newUiSelector().resourceId(&quot;com.tal.kaoyan:id/login_password_edittext&quot;)&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_android_uiautomator&#x27;new UiSelector().resourceId(&quot;com.tal.kaoyan:id/login_login_btn&quot;)&#x27;).click() 七、元素等待作用设置元素等待可以更加灵活的制定等待定位元素的时间，从而增强脚本的健壮性，提高执行效率。 元素等待类型分为强制等待、隐式等待、显示等待 强制等待 设置固定的等待时间，使用sleep()方法即可实现 123from time import sleep#强制等待2秒sleep(2) 隐式等待 隐式等待是针对全部元素设置的等待时间 1driver.implicitly_wait(40) 显式等待 显示等待是针对某个元素来设置的等待时间 方法WebDriverWait格式参数如下： 12345678910from selenium.webdriver.support.ui import WebDriverWaitWebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)driver : WebDrivertimeout : 最长超时时间，默认以秒为单位poll_frequency : 休眠时间的间隔时间，默认为0.5秒ignored_exceptions : 超时后的异常信息，默认情况下抛NoSuchElementException异常。WebDriverWait()一般和until()或until_not()方法配合使用，另外，lambda提供了一个运行时动态创建函数的方法。from selenium.webdriver.support.ui import WebDriverWaitWebDriverWait(driver,10).until(lambda x:x.find_element_by_id(&quot;elementID&quot;)) 八、截图方法方法一 save_screenshot() 该方法直接保存当前屏幕截图到当前脚本所在文件位置。 1driver.save_screenshot(&#x27;login.png&#x27;) 方法二 截图保留到指定文件路径 1driver.get_screenshot_as_file(&#x27;./images/login.png&#x27;) “./“是在运行的py的目录下，images是存在该目录里，如果没有这个文件夹，需要手动建立 考研帮登录后截图测试脚本 1234567891011from Capability import driverdriver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).clear()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.save_screenshot(&#x27;login.png&#x27;)driver.get_screenshot_as_file(&#x27;./images/login.png&#x27;)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_login_btn&#x27;).click() 九、滑动效果在Appium中模拟用户滑动操作需要使用swipe方法，该方法定义如下： 12345678910111213def swipe(self, start_x, start_y, end_x, end_y, duration=None): &quot;&quot;&quot;Swipe from one point to another point, for an optional duration. :Args: - start_x - x-coordinate at which to start - start_y - y-coordinate at which to start - end_x - x-coordinate at which to stop - end_y - y-coordinate at which to stop - duration - (optional) time to take the swipe, in ms. :Usage: driver.swipe(100, 100, 100, 400) 注释———-swipe()方法的参数说明： start_x：起始横坐标 start_y：起始纵坐标 end_x：结束时横坐标 end_y：结束时纵坐标 duration：滑动持续时间，单位毫秒，默认None（一般设置500-1000毫秒比较合适） 实现平面上各个方向位置滑动 通过调用get_size()、swipeLeft()函数来实现滑动效果 1234567891011121314151617#获取屏幕尺寸def get_size(): x=driver.get_window_size()[&#x27;width&#x27;] y=driver.get_window_size()[&#x27;height&#x27;] return x,y#显示屏幕尺寸（width,height）l=get_size()print(l)#向左滑动def swipeLeft(): l=get_size() x1=int(l[0]*0.9) y1=int(l[1]*0.5) x2=int(l[0]*0.1) driver.swipe(x1,y1,x2,y1,1000) Capability.py 123456789101112131415161718192021222324252627282930313233343536373839404142from appium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptiondesired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=&#x27;Android&#x27;desired_caps[&#x27;deviceName&#x27;]=&#x27;127.0.0.1:62025&#x27;desired_caps[&#x27;platforVersion&#x27;]=&#x27;7.1.2&#x27;desired_caps[&#x27;app&#x27;]=r&#x27;d:\\kaoyan.apk&#x27;desired_caps[&#x27;appPackage&#x27;]=&#x27;com.tal.kaoyan&#x27;desired_caps[&#x27;appActivity&#x27;]=&#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;desired_caps[&#x27;noReset&#x27;]=&#x27;False&#x27;driver=webdriver.Remote(&#x27;http://localhost:4723/wd/hub&#x27;,desired_caps)driver.implicitly_wait(2)def check_cancelBtn(): print(&#x27;check cancelBtn&#x27;) try: cancelBtn = driver.find_element_by_id(&#x27;android:id/button2&#x27;) except NoSuchElementException: print(&#x27;no cancelBtn&#x27;) else: cancelBtn.click()def check_skipBtn(): print(&#x27;check skipBtn&#x27;) try: skipBtn=driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;) except NoSuchElementException: print(&#x27;no skipBtn&#x27;) else: skipBtn.click()check_cancelBtn()check_skipBtn()","categories":[],"tags":[{"name":"appuim 基础","slug":"appuim-基础","permalink":"http://example.com/tags/appuim-%E5%9F%BA%E7%A1%80/"}],"keywords":[]},{"title":"monkey日志管理","slug":"monkey日志管理","date":"2021-09-01T11:43:05.000Z","updated":"2021-09-01T11:51:10.789Z","comments":true,"path":"2021/09/01/monkey日志管理/","link":"","permalink":"http://example.com/2021/09/01/monkey%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/","excerpt":"","text":"自定义脚本的稳定性测试常规Monkey测试执行的是随机的事件流，但如果只是想让Monkey测试某个特定场景这时候就需要用到自定义脚本了，Monkey支持执行用户自定义脚本的测试，用户只需要按照Monkey脚本的规范编写好脚本，存放到手机上，启动Monkey通过-f 参数调用脚本即可 需求分析获取元素坐标点位置Monkey脚本只能通过****坐标****的方式来定位点击和移动事件的屏幕位置，这里就需要提前获取坐标信息。获取坐标信息的方法很多，最简单的方法就是打开手机中的开发人员选项，打开“显示指针位置”。随后，在屏幕上的每次操作，在导航栏上都会显示坐标信息。 monkey脚本APILaunchActivity(pkg_name, cl_name)：启动应用的Activity。参数：包名和启动的Activity。 Tap(x, y, tapDuration)： 模拟一次手指单击事件。参数：x,y为控件坐标，tapDuration为点击的持续时间，此参数可省略。 UserWait(sleepTime)： 休眠一段时间 DispatchPress(keyName)： 按键。参数： keycode。 RotateScreen(rotationDegree, persist)： 旋转屏幕。 参数：rotationDegree为旋转角度， e.g. 1代表90度；persist表示旋转之后是否固定，0表示旋转后恢复，非0则表示固定不变。 DispatchString(input)： 输入字符串。 DispatchFlip(true/false)： 打开或者关闭软键盘。 PressAndHold(x, y, pressDuration)： 模拟长按事件。 Drag(xStart, yStart, xEnd, yEnd, stepCount)： 用于模拟一个拖拽操作。 PinchZoom(x1Start, y1Start, x1End, y1End, x2Start, y2Start, x2End, y2End, stepCount)： 模拟缩放手势。 LongPress()： 长按2秒。 DeviceWakeUp()： 唤醒屏幕。 PowerLog(power_log_type, test_case_status)： 模拟电池电量信息。 WriteLog()： 将电池信息写入sd卡。 RunCmd(cmd)： 运行shell命令。 DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFlags)： 向指定位置，发送单个手势。 DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFilags)： 发送按键消息。 LaunchInstrumentation(test_name,runner_name)： 运行一个instrumentation测试用例。 DispatchTrackball： 模拟发送轨迹球事件。 ProfileWait： 等待5秒。 StartCaptureFramerate()： 获取帧率。 EndCaptureFramerate(input)： 结束获取帧率。 monkey脚本格式头部 123456type = raw events count = 1 speed = 1.0 //下面为monkey命令 start data &gt;&gt; 具体的monkey脚本内容 编写脚本 kyb.txt 1234567891011121314151617181920212223242526272829#头文件信息type = raw events count = 1speed = 1.0#启动测试start data &gt;&gt;LaunchActivity(com.tal.kaoyan,com.tal.kaoyan.ui.activity.SplashActivity)UserWait(2000)Tap(624,900,1000) #点击取消升级UserWait(2000)Tap(806,64,1000) #点击跳过UserWait(2000)Tap(217,378,1000) #点击用户名输入框DispatchString(账户)UserWait(2000)Tap(197,461,1000) #点击密码输入框DispatchString(密码)UserWait(2000)Tap(343,637,1000) #点击登录按钮 执行脚本 脚本编写完成后，传到手机设备上，然后执行。 123adb push C:\\Users\\admin\\Desktop\\kyb1.txt /sdcardadb shell monkey -f /sdcard/kyb1.txt -v 1 执行结果 123456789101112131415C:\\Users\\admin&gt;adb shell monkey -f /sdcard/kyb.txt -v 1:Monkey: seed=1524592021303 count=1:IncludeCategory: android.intent.category.LAUNCHER:IncludeCategory: android.intent.category.MONKEYReplaying 0 events with speed 1.0:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.tal.kaoyan/.ui.activity.SplashActivity;end // Allowing start of Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.tal.kaoyan/.ui.activity.SplashActivity &#125; in package com.tal.kaoyan:Sending Touch (ACTION_DOWN): 0:(267.0,1233.0) // Allowing start of Intent &#123; act=com.android.systemui.recent.action.TOGGLE_RECENTS cmp=com.android.systemui/.recent.RecentsActivity &#125; in package com.android.systemui:Sending Touch (ACTION_UP): 0:(267.0,1233.0)Events injected: 5:Sending rotation degree=0, persist=false:Dropped: keys=0 pointers=0 trackballs=0 flips=0 rotations=0## Network stats: elapsed time=7201ms (0ms mobile, 0ms wifi, 7201ms not connected)// Monkey finished 注意事项 头文件代码书写注意“=”两边预留空格，否则会出现如下报错 1java.lang.NumberFormatException: Invalid int: &quot;&quot; 参考资料","categories":[],"tags":[{"name":"monkey日志管理","slug":"monkey日志管理","permalink":"http://example.com/tags/monkey%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"}],"keywords":[]},{"title":"monkey","slug":"monkey","date":"2021-08-31T10:13:54.000Z","updated":"2021-09-01T11:41:54.865Z","comments":true,"path":"2021/08/31/monkey/","link":"","permalink":"http://example.com/2021/08/31/monkey/","excerpt":"","text":"monkey 理论monkey定义andriod自动化测试工具，对被测程序进行压力测试，检查和评估被测程序的稳定性。 monkey官方文档 monkey路径Monkey程序是Android系统自带的，其启动脚本是位于Android系统的/system/bin目录的Monkey文件，其jar包是位于Android系统的/system/framework目录的Monkey.jar文件。用户主要是通过adb命令来启动Monkey的，Monkey在运行时，会根据命令行参数的配置，生成伪随机的事件流，并在Android设备上执行对应的测试事件。 monkey 启动步骤 连接模拟器 12adb connect 127.0.0.1:62001#连接adb devices#检查设备连接情况 连接成功后输入命令 1adb shell 进入到指定目录1cd /system/bin 输入monkey 命令看到一串信息提示就是成功，没有报错即可。 强制关闭 monkey adb shell ps 查看全部在运行的进程 查找出com.android.commands.monkey 进程PID adb shell kill pid 杀掉monkey进程 monkey 命令monkey命令格式如下： 1$ adb shell monkey [options] &lt;event-count&gt; · [options] 是指monkey可传入的参数，是可选项（如果不指定options，Monkey将以无反馈模式启动，并把事件任意发送到安装在目标环境中的全部包） · 是指随机发送事件数。如：输入100就是执行100个伪随机事件，为必选项。 monkey 参数参数分类· 常规类参数 · 事件类参数 · 约束类参数 · 调试类参数 1.常规类参数常规类参数包括帮助参数和日志信息参数。 1.帮助类参数 1monkey -h 2.日志级别 1$ adb shell monkey -v &lt;event-count&gt; -v：打印出日志信息，每个-v将增加反馈信息的级别。-v越多日志信息越详细，不过目前最多支持3个-v 2.事件类参数1.执行指定脚本 1234$ adb shell monkey -f &lt;scriptfile&gt; &lt;event-count&gt;eg：$ adb shell monkey -f /mnt/sdcard/test1 2.伪随机数生成种子值 1234$ adb shell monkey -s &lt;seed&gt; &lt;event-count&gt;eg:$ adb shell monkey -s 666 100 3.设置间隔 如果你希望在每一个指令之间加上固定的间隔时间，可以用–throttle（注意，前面是–）命令。 123$ adb shell monkey --throttle &lt;milliseconds&gt;eg:$ adb shell monkey --throttle 3000 5 –throttle：后面接时间，单位为ms（），表示事件之间的固定延迟（即执行每一个指令间隔的时间），若不接该选项，monkey将不会延迟。 4.调整触摸事件百分比 如果你希望调整触摸事件的百分比，记住使用–pct-touch。 123$ adb shell monkey --pct-toucheg:$ adb shell monkey -v -v --pct-touch 100 200 注意：触摸事件不单单是按键，它泛指发生在某一位置的一个down-up事件 5.调整手势事件百分比 123$ adb shell monkey --pct-motioneg:$ adb shell monkey -v -v --pct-motion 100 200 6.调整应用启动事件的百分比 1$ adb shell monkey --pct-appswtich &lt;percent&gt; 7.调整屏幕旋转事件百分比 1$ adb shell monkey --pct-rotation &lt;percent&gt; 约束类参数1.包约束 -p：后面接一个或多个包名（&lt;”allowed-package-name”&gt;），如果应用需要访问其他包里的Activity，那相关的包也需要在此同时指定。如果不指定任何包，monkey将允许系统启动全部包里的Activity。 12345$ adb shell monkey -p &lt;allowed-package-name&gt; &lt;event-count&gt;eg：$ adb shell monkey -p com.tal.kaoyan 500$ adb shell monkey -p com.tal.kaoyan -p com.tencent.mm 500 2.activity类约束 1adb shell monkey -c &lt;main-category&gt; &lt;event-count&gt; 调试类参数1.应用程序崩溃后继续发送时间 1$ adb shell monkey --ignore-crashes &lt;event-count&gt; 2.超时错误继续发送事件 1$ adb shell monkey --ignore-timeouts 3.应用程序权限错误发生后继续发送事件 1$ adb shell monkey --ignore-security-exceptions 测试命令 12345678adb shell monkey -p com.tal.kaoyan--pct-touch 40 --pct-motion 25 --pct-appswitch 10--pct-rotation 5-s 1666 --throttle 400--ignore-crashes--ignore-timeouts-v -v 200","categories":[],"tags":[{"name":"monkey","slug":"monkey","permalink":"http://example.com/tags/monkey/"}],"keywords":[]},{"title":"MonkeyRunner API","slug":"MonkeyRunner-API","date":"2021-08-31T05:58:58.000Z","updated":"2021-08-31T10:08:08.649Z","comments":true,"path":"2021/08/31/MonkeyRunner-API/","link":"","permalink":"http://example.com/2021/08/31/MonkeyRunner-API/","excerpt":"","text":"MonkeyRunner工具主要有三个类： MonkeyRunner MonkeyDevice MonkeyImage ​ 官方API文档 1.MonkeyRunner 类：MonkeyRunner提供连接真机和模拟器、输入、暂停、警告框等方法 alert() 警告框 choice() 选项列表框 help() API帮助文档 input() 输入 sleep() 暂停 waitForConnection() 等待设备连接 常用方法waitForConnection(float timeout,string deviceid)， 12345from com.android.monkeyrunner import MonkeyRunner as mrprint(&quot;connect devices...&quot;)device=mr.waitForConnection()# device=mr.waitForConnection(5,&#x27;127.0.0.1:62001&#x27;) 2.MonkeyDevices类MonkeyDevice类提供了安装和卸载程序包、开启Activity、发送按键和点击事件、运行测试包等方法。 broadcastInternt() 发送广播 drag() 拖动 getProperty() 获取当前设备属性 getSystemProperty() 获取当前设备属性 installPackage() 安装应用 instrument() 执行测试用例 press() 按键 reboot() 重启 removePackage() 删除指定Package shell() 执行命令 startActivity() 启动应用 touch() 点击 常用方法 · installPackage (string path) · removePackage (string package) · startActivity (string uri, string action, string data, string mimetype, iterable categories dictionary extras, component component, flags) · touch (integer x, integer y, integer type) touch参数说明 integer x，x坐标值。integer y，y坐标值。integer type，key event类型（如DOWN、UP、DOWN_AND_UP）。 DOWN为按下事件 UP为弹起事件 DOWN_AND_UP为按下弹起事件。 · drag (tuple start, tuple end, float duration, integer steps) drag参数详细说明如下： tuple start，拖拽起始位置，为tuple类型的(x,y)坐标点。tuple end，拖拽终点位置，为tuple类型的(x,y)坐标点。float duration，拖拽手势持续时间，默认为1.0s。-integer steps，插值点的步数，默认值为10。 实践案例：连接设备，安装考研帮App并启动 代码如下： 1234567891011121314151617181920from com.android.monkeyrunner import MonkeyRunner as mrfrom com.android.monkeyrunner import MonkeyDevice as mdprint(&quot;connect devices...&quot;)device=mr.waitForConnection()print(&quot;install app...&quot;)device.installPackage(r&#x27;C:\\Users\\admin\\Desktop\\kaoyan3.1.0.apk&#x27;)package = &#x27;com.tal.kaoyan&#x27;activity = &#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;runComponent = package + &#x27;/&#x27; + activityprint(&quot;launch App...&quot;)device.startActivity(component=runComponent)代码执行方式monkeyrunner scripfileC:\\Users\\admin&gt;monkeyrunner E:\\monkeyrunner_script\\kyb.py 3.MonkeyImage类MonkeyImage类在测试过程中用来保存各种格式的测试截图，并可以进行图像对比。 convertToBytes() 转换图像格式 getRawPixel() 获取当前坐标像素元组 getRawPixelint() 获取当前坐标像素元组 sameAs() 图像对比 writeToFile() 保存图像文件 getSubimage() 截取子图像 常用方法 · takeSnapshot() 进行屏幕截图 · writeToFile() 保存图像文件到指定的文件路径 用法示例 1234from com.android.monkeyrunner import MonkeyImage as mi print(&quot;takeSnapshot&quot;)screenshot=device.takeSnapshot() screenshot.writeToFile(r&#x27;E:\\monkeyrunner_script\\test.png&#x27;,&#x27;png&#x27;) 综合实践测试场景· 连接设备，自动安装并启动考研帮app · 启动后登录账号，然后截图并保存到指定文件位置。 思路分析· 连接设备 · 安装app · 启动app · 输入用户名密码点击登录按钮 · 截图 脚本实现kyb_login.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344from com.android.monkeyrunner import MonkeyRunner as mrfrom com.android.monkeyrunner import MonkeyDevice as mdfrom com.android.monkeyrunner import MonkeyImage as miprint(&quot;connect devices...&quot;)device=mr.waitForConnection()print(&quot; install app&quot;)device.installPackage(r&#x27;C:\\Users\\admin\\Desktop\\kaoyan3.1.0.apk&#x27;)print(&quot;launch app...&quot;)package=&#x27;com.tal.kaoyan&#x27;activity=&#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;runComponent=package+&#x27;/&#x27;+activitydevice.startActivity(component=runComponent)mr.sleep(3)print(&quot;touch cancel button&quot;)device.touch(618,895,&#x27;DOWN_AND_UP&#x27;)mr.sleep(1)print(&quot;touch skip button&quot;)device.touch(804,67,&#x27;DOWN_AND_UP&#x27;)mr.sleep(1)print(&quot;input username and password&quot;)device.touch(57,373,&#x27;DOWN_AND_UP&#x27;)mr.sleep(2)device.type(账户)device.touch(152,480,&#x27;DOWN_AND_UP&#x27;)mr.sleep(2)device.type(密码)mr.sleep(2)print(&quot;touch login button&quot;)device.touch(331,634,&#x27;DOWN_AND_UP&#x27;)print(&quot;takeSnapshot&quot;)screenshot=device.takeSnapshot()screenshot.writeToFile(r&#x27;D:\\monkeyrunner\\kyb.png&#x27;,&#x27;png&#x27;) 注意事项方法调用错误 1AttributeError: type object &#x27;com.android.monkeyrunner.XXXXX&#x27; has no attribute XXXXXX 检查调用的方法名是否写错，特别是注意区分大小写。 字符编码错误 1SyntaxError: Non-ASCII character in file &#x27;E:\\monkeyrunner_script\\kyb.py&#x27;, but no encoding declared; 需要在代码顶部补充 # -- coding: utf-8 -- 或者去掉代码中的中文字符","categories":[],"tags":[{"name":"Monkeyrunner","slug":"Monkeyrunner","permalink":"http://example.com/tags/Monkeyrunner/"}],"keywords":[]},{"title":"从0开始搭建一个博客站点","slug":"从0开始搭建一个博客站点","date":"2021-08-30T07:41:14.000Z","updated":"2021-08-30T10:37:50.229Z","comments":true,"path":"2021/08/30/从0开始搭建一个博客站点/","link":"","permalink":"http://example.com/2021/08/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/","excerpt":"","text":"1.Hexo的入门 hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。 hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。 参考：官网文档 1.1安装node.js网上安装教程 验证安装是否成功 进入cmd 输入node -v 出现相应的版本号ok 12C:\\Windows\\System32&gt;node -vv14.17.5 1.2安装gitgit安装教程 验证git安装成功与否 进入cmd 输入 git version 出现相应的版本号ok 12C:\\Windows\\System32&gt;git versiongit version 2.33.0.windows.2 1.3安装、配置hexo文件1.进入git bash窗口 2.输入以下命令 1npm install -g hexo-cli 3.出现一堆代码 4.输入以下命令 123hexo init d:/文件夹名 ----表示在d盘创建这个文件夹 cd 文件名 ----进入文件夹 npm install ----安装 1.4关于hexo文件夹里面的内容1.4.1 hexo文件目录安装hexo完毕，d盘目录下你创建的文档下面的内容： 1234567891011├── _config.yml├── .deploy_git├── .github├── public├── themes├── source| └── .gitkeep ├── scraffolds| ├── draft.md ├── page.md └── post.md 1.4.2 hexo目录文件介绍（了解）_confifig.yml 网站的配置信息，您可以在此配置大部分的参数。 package.json 已经默认给你安装的应用程序的信息 scaffffolds 模版文件夹。当您新建文章时，Hexo 会根据 scaffffold 来建立文件，了解即可 source 资源文件夹是存放用户资源的地方。一般你通过命令创建的文章都存储在 _posts 文件夹里面 themes 这个主要存放的hexo的主题文件，类似英雄皮肤，通过更改不同主题来实现不同酷炫的效果。 1.5_confifig.yml配置文件详解（了解）1.5.1网站相关 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 你的名字 language 网站使用的语言 timezone 网站时区时区列表 1.5.2网址相关 参数 描述 url 网址 root 网站根目录 permalink 文章永久链接 格式 permalink_defaults 永久链接中各部分的默认值 1.5.3目录相关 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public archive_dir 标签文件夹 tags category_dir 归档文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 1.5.4日期与格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 1.6hexo相关命令指令参考 1.7建立远程博客访问1.7.1 本地启动hexo启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可： 1hexo server 或者 hexo s 浏览器访问网址：http://localhost:4000/ 至此，你的hexo本地博客已经搭建成功。 1.7.2GithubPages的使用在开始之前创建github官网账号，并创建一个仓库 注意仓库名的格式： 仓库名为：Github账号名称.github.io 1.安装 hexo-deployer-git插件。在命令（Git Bash）运行以下命令 $ npm install hexo-deployer-git --save 2.添加SSH key 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可。 邮箱地址和注册github的邮箱保持一致。 $ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如 C:\\users\\administrator\\.ssh\\id_rsa.pub)，粘贴到 New SSH KEY即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com $ yes 3.修改 _config.yml （在站点目录下）。文件末尾修改为： 123456# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy:type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面的格式type和repo的冒号后面需要空格两下； ​ 上面仓库地址写ssh地址，不写http地址 。 4.推送到GithubPages。在命令行（即Git Bash）依次输入以下命令，返回 INFO Deploy done: git即成功推送： 12$ hexo g $ hexo d 或 1$ hexo g -d 5.等待1分钟左右，浏览器访问网址： https://&lt;Github账号 名称&gt;.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为 https://&lt;Github账号名称&gt;.github.io 。","categories":[],"tags":[{"name":"hexo 搭建","slug":"hexo-搭建","permalink":"http://example.com/tags/hexo-%E6%90%AD%E5%BB%BA/"}],"keywords":[]},{"title":"胡俊学习经历","slug":"胡俊学习经历","date":"2021-08-28T08:38:36.000Z","updated":"2021-08-30T03:35:14.336Z","comments":true,"path":"2021/08/28/胡俊学习经历/","link":"","permalink":"http://example.com/2021/08/28/%E8%83%A1%E4%BF%8A%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86/","excerpt":"","text":"黑盒测试一、测试活动1、需求分析2、测试计划3、用例设计4、用例执行5、测试报告（天猫项目）二、等价类测试法1. 什么是等价类是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。2、划分等价类可以把全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件就可以用少量代表性的测试数据取得较好的测试结果3、划分等价类的方法1）区间；2）数值集合划分；3）输入是布尔量，确定有效和无效等价类；4）按照数值划分；5）按照限制条件或规则划分；6）细分等价类4、设计测试用例（原则）1）为每一个等价类规定一个唯一的编号；2）设计一个新的测试用例,使其尽可能多地覆盖尚未被覆盖地有效等价类,重复这一步，直到所有的有效等价类都被覆盖为止；3） 设计一个新的测试用例,使其仅覆盖一个尚未被覆盖的无效等价类,重复这一步，直到所有的无效等价类都被覆盖为止；（三角形案例）三、边界值分析1.定义边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。2.与等价类的区别边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。3.边界值分析设计1）确定边界情况；2）选取正好等于、刚刚大于、刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据；健壮性测试：有效和无效均要测试；0作为边界值要反复测试强性测试：有效覆盖弱性测试：无效覆盖弱健壮性：有效、无效均覆盖部分三角形问题的边界值分析测试用例","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2021-08-27T11:11:52.026Z","updated":"2021-08-27T11:11:52.026Z","comments":true,"path":"2021/08/27/hello-world/","link":"","permalink":"http://example.com/2021/08/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"http协议","slug":"http协议","date":"2021-08-10T05:58:20.000Z","updated":"2021-09-04T06:48:19.562Z","comments":true,"path":"2021/08/10/http协议/","link":"","permalink":"http://example.com/2021/08/10/http%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"一、http协议简介1）协议简介超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的 一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了 提供一种发布和接收 HTML(超文本标记语言) 页面的方法。 HTTP 协议在网络 OSI 模型中属于应用层协议，应用层协议除了 HTTP 还有：FTP， SMTP，DNS，RIP，Telnet 等。 HTTP 协议工作于客户端—服务端架构上。浏览器作为 HTTP 客户端通过 URL(网址) 向 HTTP 服务端（即 Web 服务器） 发送请求。 2）什么是超文本？超文本英文名称叫做 Hypertext，我们在浏览器里面看到的网页就是超文本解析而成的， 其网页源代码是一系 列 HTML 代码，里面包含了一系列标签，如 img 显示图片，p 指定显 示段落等，浏览器解析这些标签后便形成了我们平常看到的网页，而这网页的源代码 HTML 就可以称作超文本。 例如我们在 Chrome 浏览器里面打开如百度页面，右键点击”查看源代码”，这些源代 码都是超文本。 3）什么是URL？我们在浏览器的地址栏里输入的网站地址叫做 URL (Uniform Resource Locator，统 一资源定位符)。就像每家每 户都有一个门牌地址一样，每个网页也都有一个 Internet 地 址（如：http://www.baidu.com）。 当你在浏览器的 地址框中输入一个 URL 或是单击一个超级链接时，URL 就确定了要浏 览的地址。浏览器通过超文本传输协议(HTTP)， 将 Web 服务器上站点的网页代码提取出 来，并翻译成漂亮的网页。 4）http 功能HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从服务器传输 超文本到本地浏览器的传输协议。 它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本 文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 5）http的特点无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户端的请求，并收到 客户端的应答后， 即断开连接。采用这种方式可以节省传输时间。 媒体独立：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可 以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 来传输。无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。如果服务 器不需要先前信 息，那么它的应答就比较快。但是缺少状态意味着如果后续处理需要前面 的信息，则它必须重传，这样可 能导致每次连接传送的数据量增大，此时可以设置缓存。 6）HTTP和HTTPS 的区别现在在浏览很多网站时，通过浏览器地址栏可以看到有的网站是 https 开头 （https://www.baidu.com/ ）, 但是 有的是 http 开头（如： http://www.weather.com.cn ）这两种有什么区别呢？难道加了 s 就是复数吗？ HTTPS 的全称是 Hyper Text Transfer Protocol over Secure Socket Layer，是以 安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层（Secure Sockets Layer 安全套接层），简称为 HTTPS。 S 其实是 Security 单词的首字母 HTTPS 的安全基础是 SSL，因此通过它传输的内容都是经过 SSL 加密的，它的主要作用 可以分为两种： 是建立一个信息安全通道，来保证数据传输的安全。 确认网站的真实性，凡是使用了 https 的网站，都可以通过点击浏览器地址栏的锁头标 志来查看网站认证之 后的真实信息，也可以通过 CA 机构颁发的安全签章来查询。现在越来越多的网站和 APP 都已经向 HTTPS 方向发展。例如：谷歌从 2017 年 1 月推出的 Chrome 56 开始， 对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户“此网页不安全”。 7）http与tcp/ip的特点：TCP/IP 协议是传输层协议，主要解决数据如何在网络中传输，而 HTTP 是应用层协 议，主要解决如何包装数据。 关于 TCP/IP 和 HTTP 协议的关系，网络有一段比较容易理解的介绍：“我们在传输 数据时，可以只使用（传输层） TCP/IP 协议，但是那样的话，如果没有应用层，便无法 识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很 多，比如 HTTP、FTP、TELNET 等，也可以自己定义应用层协议。 WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做 传输层协议将它发到网络上。” 二、http请求我们在浏览器输入百度首页的地址：https://www.baidu.com/ 输入之后浏览器会给 我们打开百度首页。 实际上这 个过程是浏览器向网站所在的服务器发送了一个 Request，即请求，网站服 务器接收到这个 Request 之后进行处 理和解析，然后返回对应的一个 Response，即响 应，然后传回给浏览器，Response 里面就包含了页面的源代码等内容，浏览器再对其进行解析便将网页呈现了出来。 例子：使用火狐浏览器，打开百度，查看页面的请求过程 点击呈现详细步骤 1）请求的四部分•Request Method: 请求方式 •Request URL: 请求链接 •Request Headers: 请求头 •Request Body: 请求体 2）请求方式—抓用户名和密码请求方式，常见的两种类型： GET 用于信息获取，而且应该是安全的和幂等的(幂等的的意思就是一个操作不会修改 状态信息，并且每次操作的时候都返回同样的结果。) 从发送请求的角度，GET 请求相当 于我们在数据库中做了查询的操作， 这样的操作不影响数据库本身的数据。 POST 表示可能会修改服务器上资源的请求，也相当于在数据库中做了修改的操作， 会影响数据库本身的数据（比如：注册了账户，发了帖子，做了评论，得到了积分等。这种 情况下，资源状态被改变了）。 案例： get请求： 1在浏览器地址栏输入：https://www.baidu.com/s?wd=appium并回车,这个其实就是在百度搜索appium这个关键词。URL中包含了请求的参数信息，这里参数wd就是要搜寻的关键字 post请求： 1234一般来说，网站登录验证的时候，需要提交用户名密码，这里包含了敏感信息，使用 GET 方式请求的话密码就会 暴露在 URL 里面，造成密码泄露，所以这里最好以 POST 方 式发送。文件的上传时，由于文件内容比较大，也会 选用 POST 方式。比如百度账户登 录，如下图所示： 例如：使用火狐浏览器抓用户名和密码 当然也可以使用fiddler抓包 3）请求网址（url）Request URL 就是请求的网址，即统一资源定位符，用 URL 可以唯一确定我们想请求的资源。 比如： https://www.baidu.com/ 4）请求头（request headers）请求头，用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、Referer、 User-Agent 等，下面将一些 常用的头信息说明如下： 123456789Accept，请求报头域，用于指定客户端可接受哪些类型的信息。 • Accept-Language，指定客户端可接受的语言类型。 • Accept-Encoding，指定客户端可接受的内容编码。 • Host，用于指定请求资源的主机 IP 和端口号，其内容为请求 URL 的原始服务器或网关 的位置。从 HTTP 1.1 版本开始，Request 必须包含此内容。 • Cookie，也常用复数形式 Cookies，是网站为了辨别用户进行 Session 跟踪而储存在 用户本地的数据。Cookies 的主要功能就是维持当前访问会话。 • Referer，此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做 相应的处理，如 做来源统计、做防盗链处理等。 • User-Agent，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统 及版本、浏览器 及版本等信息。 • Content-Type，即 Internet Media Type，互联网媒体类型，也叫做 MIME 类型，在 HTTP 协议消息头 中，使用它来表示具体请求中的媒体类型信息。例如 application/x-www-form-urlencoded 表示表单数 据， text/html 代表 HTML 格式， image/gif 代表 GIF 图片，application/json 代表json文件 5）请求体即请求体，一般用于 POST 请求中，主要定义向服务器提交的数据类型，而对于 GET 请求 Request Body 则为 空。 比如在登录之前我们填写了用户名和密码信息，提交时就这些内容就会以 Form Data 的形式提交给服务器，此时注意 Request Headers 中指定了 Content-Type 为 application/x-www-form-urlencoded。 Postman看 只有设 置 Content-Type 为 application/x-www-form-urlencoded 才会以 Form Data 形式提交，另外我们也可以 将 Content-Type 设置为 application/json 来 提交 Json 数据，或者设置为 multipart/form-data 来上传文件。 常用 Content-Type 和 POST 提交数据方式的关系： Content-Type 提交数据方式 application/x-www-form-urlencoded Form表单提交 multipart/form-data 表单文件上传提交 application/jason 序列化Json数据提交 text/html XML数据提交 三、http的响应1）响应的三部分上述内容讲述的 http 协议的请求，接着描述 http 协议的响应。 Response，即响应，由服务端返回给客户端。Response 可以划分为三部分: • Response Status Code ：响应状态码 • Response Headers ：响应头 • Response Body ：响应提 Response Status Code 响应状态码，此状态码表示了服务器的响应状态，如 200 则代表服务器正常响应，404 则代表页面未找到，500 则 代表服务器内部发生错误。常用响应状态码如下： 可以参考完整的 http 协议的响应状态码： 响应状态码的含义 1XX： 请求未完成 2XX: 表示响应成功 3XX：表示转发/重定向 4XX: 路径找不到 5XX：服务器内部资源错误 2）响应头响应头，其中包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等，下面将一些常用的头信息说明如下： *Date，标识 Response 产生的时间。 Last-Modified，指定资源的最后修改时间。 •Content-Encoding，指定 Response 内容的编码。 •server，包含了服务器的信息，名称，版本号等。 •Content-Type，文档类型，指定了返回的数据类型是什么，如 text/html 则代表返回 HTML 文档， application/x-javascript 则代表返回 JavaScript 文件，image/jpeg 则 代表返回了图片。 • Set-Cookie，设置 Cookie，Response Headers 中的 Set-Cookie 即告诉浏览器需要 将此内容放在 Cookies 中，下次请求携带 Cookies 内容。 **• Expires,**指定 Response 的过期时间，使用它可以控制代理服务器或浏览器将内容更 新到缓存中，如果再 次访问时，直接从缓存中加载，降低服务器负载，缩短加载时间。 3）响应体即响应体，响应的正文数据都是在响应体中，如请求一个网页，它的响应体就是网页的 HTML 代码，请求一张图 片，它的响应体就是图片的二进制数据。","categories":[],"tags":[{"name":"http协议","slug":"http协议","permalink":"http://example.com/tags/http%E5%8D%8F%E8%AE%AE/"}],"keywords":[]}]}
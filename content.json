{"meta":{"title":"HERO","subtitle":"","description":"","author":"hujun","url":"http://example.com"},"pages":[],"posts":[{"title":"性能测试工具-Jmeter","slug":"性能测试工具-Jmeter","date":"2021-09-17T09:08:47.000Z","updated":"2021-09-17T10:57:32.447Z","comments":true,"path":"2021/09/17/性能测试工具-Jmeter/","link":"","permalink":"http://example.com/2021/09/17/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-Jmeter/","excerpt":"","text":"一、线程组处理每个JMeter测试计划的第一步就是添加线程组。这个线程组会告诉JMeter你想要模拟的用户数量，用户应该发送请求的频率和应该发送的数量。 如上图所示，在图中红框位置点击右键，选择：添加-Threads(User)-线程组，这时可以看到这个线程组已经在测试计划下面了，如果没有看到，就点击测试计划元件展开这个测试计划树。 下一步，你需要修改这些默认的属性。如果你还没有选择线程组元件,则从测试计划树型结构中选择它。这时你应该看到JMeter窗口右边的线程组控制面板了。 循环次数设置为Y次，线程数设置为X时，那么每个线程会执行Y/X次请求 如果勾选上永远，则jmeter不会自己停止下来，直到用户手工停止 而对应LR中经常会设置请求异常时继续执行这种情况，对应上图：在取样器错误后要执行的动作，单选：继续即可 当用户勾选：调度器时，会出现调度器配置，调度器的配置遵循如下判断： 而对于Ramp-Up Period和线程数的关系，Jmeter是如下处理的： 于是对应在LR中我们经常会设置如下场景： LR场景 JMeter设置 并发20个用户持续执行10分钟 线程数填写：20，勾选调度器，设置启动时间后，持续时间写上600 并发20个用户启动时需要每10s启动2个用户 线程数填写：20，Ramp-up Period（in seconds）：100每10s启动2个用户，则20个用户需要启动时间为100s，此设置的实际效果是100s启动20个用户，每5s启动1个用户，与LR的期望效果略为不同 二、取样器2.1 HTTP请求http请求取样器可以发送一个http/https的请求给web服务器，可以通过配置控制是否需要jmeter解析html文件中的图片和其它内嵌资源，并发送http请求下载这些资源，如下类型的内嵌资源可以被检索： （1）image （2）applets （3）stylesheets （4）external scripts （5）frames、iframes （6）background images (body、 table、TD、TR) （7）background sound 默认使用的解析器是htmlparser，详细介绍见：http://baike.baidu.com/view/1174491.htm，如果需要更换htmlparser的类，修改jmeter.properties的值即可。当你需要发送多个请求到同一个web服务器时，可以考虑使用HTTP Request Defaults Configuration（HTTP请求默认值）配置元件，这样你就可以不必为每个http请求都写入相同的信息，或者，你也可以使用http proxy服务器来录制发送的http请求，这样当你在创建很多http请求时能够很大程度上节省你的时间。 HTTP请求有一个下拉框可以选择http协议的实现，目前可设置4个选项： （1）Java：由jvm提供，与HTTPClient相比有一定的局限性，如无法控制连接如何重用，当一个连接被jmeter释放后不一定能够重新被同一个线程使用，且目前存在bug，具体可自行搜索 （2）HTTPClient3.1：使用Apache Commons HttpClient 3.1，这个版本目前已不再开发，未来的jmeter版本会丢弃这个版本 （3）HTTPClient4：使用Apache HttpComponents HttpClient 4.x （4）空白：即不设置任何选项，会默认读取jmeter.properties文件中设置的jmeter.httpsampler的值，目前默认使用HttpClient4 对于普通登录，例如你需要在一个表单可输入登录名和密码时，你需要先了解表单的按钮提交时会如何处理，然后再创建一个http请求选择method为post（通常情况），并构造表单可要求的正确参数一并提交。如果页面使用http协议，你还可以使用jmeter的proxy代理去捕捉登录时发起的请求参数。 在jmeter2.2版本，只有一个单一的SSL上下文被用在所有线程的取样器中，这样做无法模拟多个用户产生压力。现在的版本可以为每个线程设置一个单独的SSL上下文，是否回到之前共享一个SSL上下文的方式，可以通过https.sessioncontext.shared=true来控制。 默认情况下，SSL的上下文会在测试过程可被保持的，在2.5.1的版本之后，SSL的会话可以选择性地在每次迭代中进行重置，这可通过设置https.use.cached.ssl.context=false来实现，这个设置不适用于java实现的http请求。Jmeter默认的SSL协议是使用TLS，如果服务器需要不同的如SSLv3，那么可以修改https.default.protocol=SSLv3的，jmeter可以使用其它额外的协议，可以直接修改https.socket.protocols属性值。 如果你的请求需要cookies，那么你可以添加一个http cookie管理器，只要添加到线程组中即可使用，这个cookie管理器，所有的http请求均可共享使用。 Server Name or IP：web服务器的域名或ip地址，如www.google.com，不需要加上http://前缀 Port：web服务器监听请求的端口号，默认是80端口 Connect Timeout：连接超时时间，即等待连接打开的毫秒数。当HTTP请求中implementation选择java时，需要java1.5或以上版本 Response Timeout：响应超时时间，即等待服务器返回响应的毫秒数。当HTTP请求中implementation选择java时，需要java1.5或以上版本 Implementation：3个选项java、HttpClient3.1、HttpClient4，如果此处没有指定，则默认值取决于jmeter的配置项jmeter.httpsampler，当取不到时，会使用java这个选项 Protocol：http或https Method：http的get、post请求，此处还包含head、put、options、trace、delete、patch Content encoding：所发送请求的报文内容所使用的编码 Path：资源的路径（如/servlets/myServlet），如果资源需要带上查询参数的话，可以添加到Send Parameters With the Request部分，需要注意的是，path必须填写完整的路径 Redirect Automatically：设置是否自动重定向，可以用在GET和HEAD请求中，勾选此项时，如果服务器返回重定向相关的状态码，会直接取得Response headers中的location值进行重定向请求，察看结果树视图中，看不到重定向的样本，只能看到一个样本。对于POST或PUT的请求，忽略此设置。具体可参考重定向相关内容：http://www.cnblogs.com/wodemeng/archive/2011/09/01/2161859.html Follow Redirects：此选项的设置与Redirect Automatically有互斥关系，当不勾选Redirect Automatically时，才能勾选Follow Redirects。如果设置了此选项，jmeter的取样器将会检查响应是否需要重定向，如果有则会随后发起请求。使用察看结果树视图可以看到，最初的请求和随后的重定向请求都会显示在结果树中。父取样器请求的URL和数据字段都会从最后一个请求中取得，但父样本的字节数和执行时间将包含子取样器的所有数据 Use KeepAlive：需要先介绍keep-aliver模式：HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。勾选此选项，jmeter会在http头加入”Connection: Keep-Alive”，才能启用Keep-Alive，它需要选择HttpClient的实现才能起作用 Use multipart/form-data for HTTP POST：使用multipart/form-data或者application/x-www-form-urlencoded设置post请求提交数据所使用的格式，详细介绍见：http://www.cnblogs.com/mumue/archive/2012/05/24/2515984.html Send parameters with the request：设置参数名和参数值，将会依据你所选的post和get方法发送参数和参数值，当选择get时，参数会被添加到url直接发送，当选择post时，参数将单独发送。当你需要发送一个文件时，需要使用multipart form，参数的创建也需要根据multipart form的规范。表格中还有选项encode?：可以指定某一参数是否进行编码，如果你不确定，那么最好都打上勾，当你的参数值中包含$、&amp;、+、逗号、/、冒号、=、问号、@等时，通常需要进行编码 Send files with the request： （1）file path：发送的文件名称，如果不设置，jmeter不会发送文件，当填写文件名时，jmeter会自动以multipart form形式发送。当请求为POST、PUT、PATCH请求时，仅有一个文件，那么parameter name将会被忽略，直接将文件作为请求的整个包体进行发送，这样的使用方式可以允许用户发送任何请求内容。 （2）parameter name：请求参数名“name”的值 （3）MIME Type：MIME类型，如text/plain，如果是POST或PUT请求且“name”值被忽略，或请求仅由参数值构成，那么该字段设置的值将作为请求头content-type的值 Proxy server： （1）server Name or ip：执行请求的代理服务器或ip地址 （2）port：代理服务器端口 （3）username：代理服务器的用户名 （4）password：代理服务器的密码 Optional tasks： （1）retrieve All Embedded Resources from HTML Files：设置jmeter是否需要从html文件中解析引用的所有图片、java applets、js文件、css等 （2）Use concurrent pool：使用并发池的连接去获取嵌入的资源 （3）size：concurrent pool的连接数大小 （4）use as monitor：配合监视器结果视图（Monitor results）使用 （5）save response as MD5 hash：如果选择了此项设置，响应将不会被取样器直接存储，jmeter会对响应进行md5哈希后再行存储，这主要针对大数据量的测试（这块是直接从官网翻译的，不明白为什么是针对大数据量的测试） （6）embedded URLs must match：选择时，可以使用正则表达式匹配指定url的资源才被下载，如你需要下载url为http://example.com/的嵌入资源，那么这里可以设置正则表达式为：http://example\\.com/.*。 （7）source ip address：设置后，请求或响应均会使用这个属性设置的地址，如有多个ip地址时，则可直接指定 需要注意的是，当使用Redirect Automatically时，cookies仅会发送给初始的url，这可能会导致意想不到的行为，例如：访问www.example.com时重定向到www.example.co.uk，这时服务器可能会返回两个URL的cookies，但jmeter可能只看到最后一个主机地址的cookie，如果在下一个请求还是测试www.example.com而非www.example.co.uk，则可能会发送不正确的cookie。同样请求头的内容也是被发到初始的请求，不会发送给重定向后的URL，这种情况只会在手动创建的测试计划中比较经常出现，如果是通过http代理录制下来的则不会有类似问题。 HTTP请求中可以对parameters和post body进行切换，一旦你需要切换回parameters的tab页时，需要清空post body的内容。在post body模式下，每行将会自动添加CRLF回车换行符，除了最后一行。 响应报文大小的计算设置，通过设置sampleresult.getbytes.body_real_size=true可以获取返回的响应中的body部分的字节数，设置sampleresult.getbytes.headers_size=true则获取整个报文的字节数，包含报文头和报文体。 2.2 JDBC请求Jdbc请求取样器可以向数据库发送一个jdbc请求，在使用前，需要先创建一个JDBC Connection Configuration配置元件 Variable name：绑定的连接池名称，此处填写的是JDBC Connection Configuration配置元件所定义的数据库连接名称 Query Type：Select Statement、Update Statement、Callable Statement、Prepared Select Statement、Prepared Update Statement、Commit、Rollback、AutoCommit(false)、AutoCommit(true)，，以下仅列出主要的执行代码版本，try、catch、finally部分不体现： 123456789101112131415161718192021222324252627282930313233343536373839404142（1）Query Type为Select Statement时，对应执行代码为：stmt = conn.createStatement();ResultSet rs = null;rs = stmt.executeQuery(sql);return getStringFromResultSet(rs).getBytes(ENCODING);（2）Query Type为Callable Statement时，对应执行代码为：CallableStatement cstmt = getCallableStatement(conn);int out[]=setArguments(cstmt);boolean hasResultSet = cstmt.execute();String sb = resultSetsToString(cstmt,hasResultSet, out);return sb.getBytes(ENCODING);（3）Query Type为Update Statement时，对应执行代码为：stmt = conn.createStatement();stmt.executeUpdate(sql);int updateCount = stmt.getUpdateCount();String results = updateCount + &quot; updates&quot;;return results.getBytes(ENCODING);（4）Query Type为Prepared Select Statement时，对应执行代码为：PreparedStatement pstmt = getPreparedStatement(conn);setArguments(pstmt);ResultSet rs = null;rs = pstmt.executeQuery();return getStringFromResultSet(rs).getBytes(ENCODING);（5）Query Type为Prepared Update Statement时，对应执行代码为：PreparedStatement pstmt = getPreparedStatement(conn);setArguments(pstmt);pstmt.executeUpdate();String sb = resultSetsToString(pstmt,false,null);return sb.getBytes(ENCODING);（6）Query Type为Rollback时，对应执行代码为：conn.rollback();return ROLLBACK.getBytes(ENCODING);（7）Query Type为Commit时，对应执行代码为：conn.commit();return COMMIT.getBytes(ENCODING);（8）Query Type为AutoCommit(false)时，对应执行代码为：conn.setAutoCommit(false);return AUTOCOMMIT_FALSE.getBytes(ENCODING);（9）Query Type为AutoCommit(true)时，对应执行代码为：conn.setAutoCommit(true);return AUTOCOMMIT_TRUE.getBytes(ENCODING);（10）其它情况直接抛异常：throw new UnsupportedOperationException(&quot;Unexpected query type: &quot;+_queryType); Query：填写sql查询语句，不需要输入最后的分号，这里需要注意一下，xxx Statement和Prepared xxx Statement用法上的区别。xxx Statement需要填写的sql是一句完整可执行的sql，而Prepared xxx Statement允许用户在sql中使用?，然后再Parameter values和Parameter types中填写参数和类型，最终执行时替代sql中的?，形成一句完整的sql语句 Parameter values和Parameter types：成对出现，且sql语句中有多少个?，这里就必须有多少对参数键值对，假设sql语句为select * from cp_tranaction_info t where t.tx_id=?，那么可以设置Parameter values为${tid}，Parameter types为VARCHAR Variable names：有多个字段返回时，可以使用逗号隔开，用于存放select操作返回的查询结果 Result variable name：这里的用法比较复杂，不铺开介绍 使用察看结果树视图，检查上面sql返回的执行结果，如下图所示： 可按如下取值： TX_ID_# = 4，STATUS_# = 4 TX_ID_1= 001001-2010041201892134，STATUS _1=C TX_ID_4= 001001-2010041301892419，STATUS _1=C 需要注意的是：如果使用SELECT item from table where name=’${VAR}’作为查询语句时，name为varchar类型，则需要自行加上’’。 2.3 WebService请求Webservice请求是我们最为经常使用的取样器，与Loadrunner中的webservice协议一样，均是为了测试webservice服务而使用的测试元件。可以看到该测试元件目前被打上deprecated待废弃标志，jmeter提议压测webservice服务的脚本也使用http请求进行发送即可，具体的例子在第六章说明。 Wsdl url：在此处填写正确的wsdl地址，如上图所示，再点击“载入wsdl”按钮，jmeter会自动帮你填充协议、服务器名称或ip、端口号、路径、SOAPAction等信息 Web methods可以不用设置，因为真正发起请求时，还是主要看发送的soap/xml-rpc data中设置的服务 Soap/xml-rpc data：此处的填写则需要利用soapui里生成的soap报文，然后直接复制到这个区域过来，如何使用，可以参考我另一份文档《接口测试工具-SoapUI-第二版.pdf》，格式如下： 123456789&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:fac=&quot;http://facade.service.common.couponcore.alipay.com&quot;&gt; &lt;soapenv:Header/&gt; &lt;soapenv:Body&gt; &lt;fac:couponPayAbort&gt; &lt;fac:in0&gt;$&#123;tx_id_1&#125;&lt;/fac:in0&gt; &lt;fac:in1&gt;23242&lt;/fac:in1&gt; &lt;/fac:couponPayAbort&gt; &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt; 文件名：如果这块设置了文件名，则发送请求时，会直接读取文件内容发送，忽略Soap/xml-rpc data中设置的报文 内存缓存：当使用一个外部文件作为请求报文时，设置这个选项可以仅处理一次文件并缓存结果，当文件较大时，会比较消耗内存。如果你正在使用CSV Data Set Config，不能选择这个选项，因为如果选中了这个选项，jmeter不会循环到下一个值，所有的请求均只会使用CSV Data Set Config文件中设置的第一个值 读取soap响应：当你需要对结果进行后置处理或断言等处理时，需要勾选这个选项，以确保jmeter会读取返回的结果报文并进行后续处理 2.4 java请求（todo） 三、逻辑控制器3.1 ForEach控制器一个ForEach控制器遍历一组相关变量的值，如有下列元素： inputVar_1=test1 inputVar_2=test2 inputVar_3=test3 inputVar_4=test4 注意：“_”分隔符是可选的 可在ForEach控制器中设置变量名前缀为：inputVar，则控制器会循环执行4次。 在ForEach控制器下方添加子节点，如上图的HTTP2，即可传递returnVar的值，并循环执行4次。 3.2 Runtime控制器Runtime控制器控制其子结点被允许运行的时间，如下图设置表示HTTP1请求将持续运行5s后再进行后续的操作，如果子节点为空，则该控制器不起作用。 3.3 Switch控制器Switch控制器会根据Switch Value设置的值来运行其指定的子节点，它可以有以下两种设置方式，可以设置为你要运行的子结点的名称，如下图：HTTP 4。 也可以设置为数字，从0开始计数，0表示HTTP 3第一个子节点，1表示HTTP 4第二个子节点。 3.4 While控制器While控制器会执行其子节点直到判断条件为false。Condition可以填写：${result}，当result的值为true时，才会执行这个controller下面的samplers 3.5 交替控制器选择交替控制器时，jmter将会交替选择控制器子节点里的请求进行处理，下面举两个例子说明这个控制器的功能。 例子1：线程组设置2个线程循环5次，那么最后执行的结果为：News Page-&gt;Log Page-&gt;FAQ Page-&gt; Log Page-&gt;Gump Page-&gt; Log Page-&gt;News Page-&gt;Log Page-&gt;FAQ Page 例子2：线程组设置1个线程循环4次，那么最后执行的结果为：Home Page-&gt;Interleaved-&gt;Bug Page-&gt;Interleaved-&gt;CSV Page-&gt;Interleaved-&gt;FAQ Page-&gt;Interleaved 3.6 吞吐量控制器这个控制器的命名不准确，因为它不是用来控制吞吐量的。吞吐量控制器允许用户控制执行频率，jmeter提供了两种模式：执行百分比和执行总次数。 执行百分比：通过测试计划的总次数，使控制器执行特定的迭代次数所占的百分比，如下图，填写0-100的数字，表示执行的百分比。 执行总次数：当控制器执行了指定的执行总次数后即停止执行此控制器，如下图，吞吐量后的文本框里表示控制器将执行的次数。 Per User选项的用处： 勾选：会按照每个线程单独计算吞吐量，如线程组设置了5个线程，循环次数为2的情况，吞吐量为1时，吞吐量的子节点每个线程执行一次，总共会执行5次。 不勾选：按照全局的执行数次进行计数，如线程组设置了5个线程，循环次数为2的情况，吞吐量为1时，吞吐量的子节点仅会执行一次。 3.7 如果（if）控制器如果控制器允许用户控制其子节点所表示的测试步骤是否执行，下图“条件”可以使用函数（默认是Javascript语句）或变量，只要运行结果为true或false即可。使用上有些区别，举个例子，原先我们可以使用条件为：${__jexl(${VAR} == 23)}，这将被评估为true或false，结果将被传递到JavaScript，然后返回true或false。如果选中“Interpret Condition as Variable Expression?”，直接会对变量表达式进行评估是否为true，而不需要使用Javascript进行解析。此外，变量表达式可以返回任何值，而JavaScript的条件必须返回true或false，否则将记录错误。 当选择“Evaluate for all children?”时，该条件会对每个子节点进行判断，不选则默认只执行第一个子节点。 Javascript作为条件的例子： （1）${COUNT} &lt; 10 （2）”${returnVar}”==”http://www.baidu.com&quot; （3）’${returnVar}’==’http://www.baidu.com’ （4）${JMeterThread.last_sample_ok}（检查最后的取样器执行是否成功） 变量表达式作为条件的例子： （1）${__jexl(${COUNT} &lt; 10)} （2）${RESULT} 3.8 模块控制器当有多个Thread Group都要用到登录的transaction，每一个都重新录制很麻烦，而且以后要修改就要同时改好几个，可以使用模块控制器来实现登录模块脚本的重用，使用步骤如下： （1）录制一段登录测试步骤，放于一个逻辑控制器中 （2）在你需要使用登录的thread group中添加模块控制器 （3）在modele to run的下拉框中选择登录所在的逻辑控制器 3.9 include控制器如果我们需要写一个登录模块的测试，且这个测试会经常被用到，我们可以先针对登录做一个jmx文件，然后在另一个jmx文件里面，我们可以直接使用include控制器包含进来。 这里文件名，也可以只输入文件名，但必须设置文件名前缀，配置文件的地址位于JMeter安装目录：D:\\Program Files\\apache-jmeter-2.9\\bin\\ jmeter.properties，如下设置： 3.10 循环控制器如果你添加一个loop controller，那么这个控制器下的子节点会根据你指定的次数重复执行，假设你指定了循环次数为2，且线程组的循环次数为2，那么循环控制器下的子节点会重复执行2*2=4次。如下图所示的test plan，最终的执行情况为：home Page-&gt;New Page-&gt; New Page-&gt; home Page-&gt;New Page-&gt; New Page，New Page为loop Controller下的子节点，重复执行了4次。 有一种情况，线程组设置循环次数为2，而循环控制器设置的循环次数为“永远”，这种情况，循环控制器会一直循环下去，除非人为中断。 3.11 简单控制器简单控制器可以让你组织你的取样器和其它逻辑控制器，不像其它的逻辑控制器，简单控制器只能存储但不提供功能。 3.12 仅一次控制器登录后，要做一些操作，比如添加，修改，删除，但是登录只需要一次就够了，不需要每次操作都登陆一次。 3.13 随机控制器随机控制器与交替控制器功能类似，不一样的地方主要在于：随机控制器在每次执行中会选择子节点里任意一个请求进行执行。一个页面上有很多链接，模拟用户随机点击页面上的链接。 3.14 随机顺序控制器随机顺序控制器：会以随机的顺序执行子节点里所有的请求。 四、定时器4.1 Constant Throughput Timer这个定时器引入了可变的暂停时长，以保持总的吞吐量（每分钟发出的请求数）尽可能接近一个指定的数字，当然如果服务器无法处理如此数量的请求或是有其它耗时的定时器或测试元件，则有可能达不到指定的数字。 注意：虽然定时器命名为常量吞吐量定时器，但吞吐量的值是不需要恒定的。这里可以定义成变量或函数调用，并且在测试过程中，该值是可以用不同的方式进行改变。 （1）使用计数器变量 （2）使用Javascript或者BeanShell函数提供一个不断变化的值 （3）使用远程BeanShell服务器改变Jmeter的一个属性 通过最佳实践证明，吞吐量的值在一个测试过程中不应被经常改变，它将会花费一定的时间让新的值生效。 下图中Target throughput(in samples per minute)填写的是目标吞吐量（即我们通常所说的tpm） Calculate Throughput base on提供了5个选项： （1）this thread only：每条线程都会试图去保持目标吞吐量，整体的吞吐量将与活动线程数目成正比 （2）all active threads：目标吞吐量被所有线程组下所有活动的线程均分，每个线程根据所需要时间进行延迟运行，如目标tpm为10，有2个线程组，每个线程组分别有2个线程，那么，线程均在差不多的时间启动，每次启动的间隔时间为60s/（10/2/2）=24s （3）all active threads in current thread group：目标吞吐量被所有线程组下所有活动的线程均分，每个线程根据所需要时间进行延迟运行，均基于每个线程各自最后一次的运行时间所定 （4）all active threads (shared)：每个线程根据所需要时间进行延迟运行，基于任意一个线程最后一次的运行时间所定，每个请求无论是哪个线程发起，都与上一次执行时间相差6s （5）all active threads in current thread group (shared)：每个线程根据所需要时间进行延迟运行，基于同一个线程组任意一个线程最后一次的运行时间所定，每个请求无论是哪个线程发起，同一个线程组之间的不同线程执行时间相隔为6s 这个功能应该会经常用到，与LR中的目标场景设置较为接近，大家在测试中有类似场景要求时，可以考虑使用Constant Throughput Timer做个性化场景设置。 4.2 Synchronizing TimerSynchronizing定时器的目标是阻塞线程，直到指定数量的线程数到达此定时器，然后再一起释放掉，从而模拟瞬间大量负载不断地同时发起请求的场景，与LR中的集合点类似。 4.3 固定定时器如果你需要让每个线程在请求之间按相同的指定时间停顿，那么可以使用这个定时器，这个功能与LR的思考时间类似。 4.4 高斯随机定时器如果你需要让每个线程在请求之间按随机的时间停顿，那么可以使用这个定时器，下面表示暂停时间会分布在100到400之间，计算公式参考：Math.abs((this.random.nextGaussian() * 300) + 100)。 五、前置处理器前置处理器用来修改它所作用范围内的取样器发送出去的报文。 5.1 用户变量允许用户指定具体到各个线程的用户变量的值。用户变量也可以在测试计划中被指定，但没有具体到各个线程，这个处理器允许你指定任何用户变量的值，对于每一个线程，变量将会被按下图所示的系列分配值，如果线程数大于下图所示的用户数，则变量将会被从头开始重新使用。例如，这个处理器可以用来给每个线程分配不同的用户id，用户变量可以被任意的jmeter组件中直接引用。 通过点击面板底部的“添加变量”按钮，在名称所对应的文本框中填入变量名，当需要添加多个用户时，点击“添加用户”按钮，即会新增一列值供用户填写，如果有多个用户变量需要设置，则可以多次点击“添加变量”。 在这里设置的用户变量，如下图name，可在同一个线程组里的任意测试组件中使用此变量，使用的函数语法为：${name}。 这里的用法是相对较少参数时可用，如果需要大量参数的话，需要考虑使用CSV Data Set Config。 5.2 JDBC PreProcessorJDBC预处理器使你在运行JDBC请求之前先执行一些sql语句，这个功能通常用在JDBC请求前增删改一些必须的数据到数据库中且可独立于线程组之外，也就是在线程开始执行前，数据库初始化的操作已经完成了。这里对应的Variable Name为coupon，其为JDBC Connection Configuration的配置，可参考4.9配置元件-JDBC Connection Configuration一节 Sql-query语句用法： Sql-update语句用法： 注意到有个Query Type，可选：Select Statement、Update Statement、Callable Statement、Prepared Select Statement、Prepared Update Statement、Commit、Rollback、AutoCommit(false)、AutoCommit(true)，此处的设置可参考4.2.2节的jdbc请求部分的内容。 5.3 HTTP URL 重写修饰符（todo） 六、后置处理器6.1 正则表达式提取器允许用户从服务器的响应中通过使用perl的正则表达式提取值。作为一个后置处理器，该元素会作用在指定范围的取样器，应用正则表达式，提取所需要的值，生成模板字符串，并将结果存储到给定的变量名中。 在此简单地向大家介绍一下常用的perl正则表达式的基础： 12345678910111213141516171819.：匹配任何单个字符。例如Perl正则表达式r.t匹配这些字符串：rat、rut、rt，但是不匹配root$：匹配行结束符。例如Perl正则表达式weasel$能够匹配字符串&quot;He&#x27;saweasel&quot;的末尾，但是不能匹配字符串&quot;Theyareabunchofweasels.&quot;^：匹配一行的开始。例如Perl正则表达式^Whenin能够匹配字符串&quot;Wheninthecourseofhumanevents&quot;的开始，但是不能匹配&quot;WhatandWheninthe&quot;*：匹配0或多个正好在它之前的那个字符。例如Perl正则表达式.*意味着能够匹配任意数量的任何字符\\：这是引用符，用来将这里列出的这些元字符当作普通的字符来进行匹配。例如Perl正则表达式\\$被用来匹配美元符号，而不是行尾，类似的，Perl正则表达式\\.用来匹配点字符，而不是任何字符的通配符[]、[c1-c2]、[^c1-c2]：匹配括号中的任何一个字符。例如Perl正则表达式r[aou]t匹配rat、rot和rut，但是不匹配ret。可以在括号中使用连字符-来指定字符的区间，例如Perl正则表达式[0-9]可以匹配任何数字字符；还可以制定多个区间，例如Perl正则表达式[A-Za-z]可以匹配任何大小写字母。另一个重要的用法是“排除”，要想匹配除了指定区间之外的字符——也就是所谓的补集——在左边的括号和第一个字符之间使用^字符，例如Perl正则表达式[^269A-Z]将匹配除了2、6、9和所有大写字母之外的任何字符|：将两个匹配条件进行逻辑“或”（Or）运算。例如Perl正则表达式(him|her)匹配&quot;itbelongstohim&quot;和&quot;itbelongstoher&quot;，但是不能匹配&quot;itbelongstothem.&quot;。注意：这个元字符不是所有的软件都支持的+：匹配1或多个正好在它之前的那个字符。例如Perl正则表达式9+匹配9、99、999、98、93dsf、9.....等。注意：这个元字符不是所有的软件都支持的?：匹配0或1个正好在它之前的那个字符。注意：这个元字符不是所有的软件都支持的&#123;i&#125;、&#123;i,&#125;、&#123;i,j&#125;：匹配指定数目的字符，这些字符是在它之前的表达式定义的。例如Perl正则表达式A[0-9]\\&#123;3\\&#125;能够匹配字符&quot;A&quot;后面跟着正好3个数字字符的串，例如A123、A348等，但是不匹配A1234。Perl正则表达式[0-9]\\&#123;4,\\&#125;匹配连续的任意4个或4个以上数字字符。Perl正则表达式[0-9]\\&#123;4,6\\&#125;匹配连续的任意4个、5个或者6个数字字符。注意： 这个元字符不是所有的软件都支持的\\d：任意数字 [0-9] \\D：除数字外的任意字符 [^0-9] \\w：任意单词字符 [_0-9a-zA-Z] \\W：任意非单词字符 [^_0-9a-zA-Z] \\s：空白 [ \\r\\t\\n\\f] \\S：非空白 [^ \\r\\t\\n\\f] 更多的内容可参考：http://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F（维基百科）http://jakarta.apache.org/oro/api/org/apache/oro/text/regex/package-summary.html 一般情况下，jmeter的正则表达式语法与perl5的语法相同，但它们之间有一个重要的区别，在perl中你必须使用“//”作为分组符来指定正则表达式，如：~/正则表达式/，此种表达方式Jmeter不支持，它会直接作为字符进行解析，在Jmeter中使用“（）”作为分组符。 Apply to选项的含义： （1）Main sample only：仅作用于父节点取样器 （2）Sub-sample only：仅作用于子节点的取样器 （3）Main sample and Sub-sample：作用于父节点的取样器及对应子节点的取样器 （4）jmeter variable：作用于指定命名的取样器（todo） Response Field to check选项的含义： （1）Body：主体，响应的主体内容，一个网页页面的内容，除了信息头以外的内容 （2）Body（unescaped）：主体，响应的主体内容且替换了所有的htmp转义符，注意html转义符处理时不考虑上下文，因此可能有不正确的转换，不太建议使用 （3）Body as a Document：从不同类型的文件中提取文本，注意这个选项比较影响性能 （4）Headers：信息头，非HTTP的请求可能不存在信息头，仅对HTTP请求有作用 （5）URL （6）Response code：如200、403等 （7）Response Message：如OK等 下图所示这部分的值填写，也都有其不同的含义： （1）Reference Name：引用名称，Jmeter变量的名称，存储提取的结果，每个存储组需要使用共结果时，应使用：[refname]_g#，其中[refname]是你输入的名字，#是组号，0是整个匹配结果，而1是指第一组匹配值 （2）Regular Expression：正则表达式，使用正则表达式解析响应结果，须包含 “（）”去提取字符串中的部分值，请不要使用“||”，除非你本身需要匹配这个字符 （3）Template：模板，用来从匹配的结果中创建一个字符串，这是通过正则表达式匹配出来的一组值，语法为：$1$指代第一组，$2$指代第二组，$0$指代整个匹配结果 （4）Match No.：匹配数字，指明哪一个匹配结果值将被使用，正则表达式一般会有多个匹配结果。使用：0，表示Jmeter任选一个匹配值，使用：正整数N，表示Jmeter选择第N个值进行匹配，使用负数表示选取所有的值，一般与ForEach控制器配合使用 （5）Default Value：缺省值，如果正则表达式没有匹配到数据，引用变量将会返回一个默认值，在调试中此功能很有用，如果没有设置默认值，那么很难分辨出正则表达式是否有匹配到数据或使用是否正确，当然你也可以根据你的测试需求，在调试完成后去掉默认值的设置。 以下介绍几个从网上找来的例子： 1234567891011121314151617181920212223242526272829303132333435（1）找到所有小数的数字，比如10.2引用名称：aa正则表达式：([0-9]+\\.[0-9]+)模板：$0$区配数字: -1调用：$&#123;aa_1&#125;:取出第一个满足要求的数字$&#123;aa_2&#125;:取出第二个满足要求的数字（2）找到所有小数点后的数字引用名称：aa正则表达式：([0-9]+)\\.([0-9]+)，必须用括号分组模板：$2$（第二组）区配数字: -1 取出所有符合要求的调用：$&#123;aa_1&#125;:取出第一个满足要求的数字$&#123;aa_2&#125;:取出第二个满足要求的数字（3）找到第一个有小数的数字引用名称：aa正则表达式：([0-9]+)\\.([0-9]+)，必须用括号分组模板：不写可以，也可以$2$$1$区配数字: 1（第一个）调用：$&#123;aa_g1&#125;:取出满足要求的第一组数字$&#123;aa_g2&#125;:取出满足要求的第二组数字（4）找到所有小数的数字引用名称：aa正则表达式：([0-9]+)\\.([0-9]+)，必须用括号分组模板：不写可以，也可以$2$$1$区配数字: -1 取出所有符合要求的调用：$&#123;aa_1_g1&#125;:取出第一个满足要求的第一组数字$&#123;aa_1_g2&#125;:取出第一个满足要求的第二组数字$&#123;aa_2_g1&#125;:取出第一个满足要求的第一组数字$&#123;aa_2_g2&#125;:取出第一个满足要求的第二组数字原文引用自：http://www.cnblogs.com/quange/archive/2010/06/11/1756260.html 6.2 Xpath Extractor这个测试元件允许用户从结构化的响应-XML或(X)HTML中提取值。 Apply to选项参考上一节正则表达式的介绍，本节不再展开。 XML parsing Options选项： （1）Use Tidy (tolerant parser)，选中时会使用tidy将html响应解析为xhtml，当响应为html报文时需要选中此选项，而响应为xml或xhtml时（如rss）则取消选择此选项，关于tidy方面的了解详见：http://jtidy.sf.net/ Ø Quiet：Sets the Tidy Quiet flag Ø Report errors：If a Tidy error occurs, then set the Assertion accordingly Ø Show warnings：Sets the Tidy showWarnings option （2）Use Namespaces：选中此选项，表示xml解析器将使用命名空间解析， （3）Validate XML：根据schema检查xml文档 （4）Ignore Whitespace：Ignore Element Whitespace. （5）Fetch external DTDs：获取外部DTDs（Document Type Definition） Return entire XPath fragment instead of text content?选项：选中时，将返回xpath片断而非单纯的元素值，如//title返回“Apache JMeter”，而不返回“Apache JMeter” 上图所示值的填写： （1）Reference Name：Jmeter变量名，用来存储结果值 （2）XPath query：XPath语言的元素查询，可以返回多个匹配 12345/html/head/title：从响应报文中读取title元素值/book/page[2]：从book中取page的第二个值//form[@name=&#x27;countryForm&#x27;]//select[@name=&#x27;country&#x27;]/option[text()=&#x27;Czech Republic&#x27;])/@value查找的元素位于名为 &#x27;countryForm&#x27;的表单内，元素名为&#x27;country&#x27;选项中，且其文本内容为&#x27;Czech Republic&#x27;的值此位置串的获取可使用soapui、firefox上的firebugs、ie/chrome上的开发人员工具 （3）Default Value：没有匹配时的默认返回值，当节点没有值且“Return entire XPath fragment instead of text content?”选项没有勾选时也会返回默认值 6.3 Result status Action Handler这个后置处理器允许用户在相关的请求（取样器）失败时，停止线程或停止测试等多种方式。 在取样器错误后要执行的动作有： （1）Continue：继续，忽略错误继续执行测试 （2）Start Next Thread Loop：不执行发生错误的后续请求，重新启动下个迭代的请求 （3）Stop Thread：停止线程，退出当前正在执行的线程 （4）Stop Test：在当前请求执行完成后停止测试执行 （5）Stop Test Now：直接停止整个测试执行，可能打断正在执行的请求","categories":[],"tags":[{"name":"jmeter功能剖析","slug":"jmeter功能剖析","permalink":"http://example.com/tags/jmeter%E5%8A%9F%E8%83%BD%E5%89%96%E6%9E%90/"}],"keywords":[]},{"title":"Rest介绍与Django REST Framework环境搭建","slug":"Rest介绍与Django-REST-Framework环境搭建","date":"2021-09-13T07:52:42.000Z","updated":"2021-09-13T10:20:20.276Z","comments":true,"path":"2021/09/13/Rest介绍与Django-REST-Framework环境搭建/","link":"","permalink":"http://example.com/2021/09/13/Rest%E4%BB%8B%E7%BB%8D%E4%B8%8EDjango-REST-Framework%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"一、rest概述简介• REST 是英文 Representational State Transfer(表现层状态转化)，Rest 是 web 服务的一种架构风格; • 使用 HTTP,URI、XML、JSON、HTML 等广泛流行的标准和协议;轻量级,跨平台、跨语言的架构设计; • 它是一种设计风格,不是一种标准,是一种思想。 rest原则• 网络上的所有事物都可以被抽象为资源(resource)。 • 每一个资源都有唯一的资源标识(resource identifier)，对资源的操作不会改变这些标识 • 所有的操作都是无状态的。 设计思想REST 简化开发，其架构遵循 CRUD 原则，该原则告诉我们对于资源(包括网络资源)只需要四种行为：创建，获取，更新和删除就可以完成相关的操作和处理。我们可以通过统一资源标识符（Universal Resource Identifier，URI）来识别和定位资源，并且针对这些资源而 执行的操作是通过 HTTP 规范定义的。其核心操作只有 GET,POST,PUT,DELETE。也就是：URL 定位资源，用 HTTP 动词（GET,POST,DELETE,DETC）描述操作。 因此设计 web 接口的时候，REST 主要是用于定义接口名，接口名一般是用名次写，不用动词，那怎么表达“获取” 或者“删除”或者“更新”这样的操作呢——用请求类型（GET,PUT,POST,DELETE）来区分。 案例比如我们设计一个用户管理系统的接口，如果不使用 Restful 风格，接口会定义如下： 1234http://127.0.0.1/user/query/1 #根据用户 id 查询用户数据 GET 请求 http://127.0.0.1/user/adduser #新增用户 Post 请求 http://127.0.0.1/user/update #修改用户信息 PUT 请求 http://127.0.0.1/user/delete #删除用户信息 DELETE 请求 从上面的定义接口来看貌似没有什么问题，但是仔细揣测就会发现有一些瑕疵：比如查询方法定义接口使用了 query动词，而 GET 请求本身的含义也就是从服务器获取资源，带有查询的含义，如果接口里面定义又加上这样的动词显得重复，同理其他几个接口也是一样的。 而使用 Rest 接口定义如下： 1234http://127.0.0.1/user/1 #GET 根据用户 id 查询用户数据 http://127.0.0.1/user #POST 新增用户 http://127.0.0.1/user #PUT 修改用户信息 http://127.0.0.1/user #DELETE 删除用户信息 从上面定义的接口我们可以看出，接口名称主要指向 user 资源，具体的资源操作（增删改查）由 HTTP 的请求类型来定义。这样接口名称显得统一整洁，就不用定义不同的接口名称。 遵循这样一种风格的 Reset 接口就叫做Restful。 Rest 优势由于 REST 强制所有的操作都必须是无状态的，这就没有上下文的约束，如果做分布式，集群都不需要考虑上下文和会话保持的问题。极大的提高系统的可伸缩性。 前后端分离。前端拿到数据只负责展示和渲染，不对数据做任何处理。后端处理数据并以 JSON 格式传输出去，定义这样一套统一的接口，在 web，ios，android 三端都可以用相同的接口。 二、Django REST Framework简介Django REST Framework，是一套基于 Django 的 REST 风格的框架。 官方主页：http://www.django-rest-framework.org 特点• 功能强大、灵活，可以帮助你快速开发 Web API。 • 支持认证策略，包括 OAuth1 和 OAuth2。 • 支持 ORM(对象关系映射)和非 ORM 数据源的序列化。 • 丰富的文档以及良好的社区支持。 安装：123pip install djangorestframework pip install markdownpip install django-filter 创建 Api项目创建 当 Django REST Framework 安装好之后，创建一个新的项目 django_restful，如下命令所示我是创建在 D 盘根目录。在项目下创建 api 应用 123C:\\Users\\admin&gt;d: #创建一个新的项目 D:\\&gt;django-admin startproject django_restful 进入项目 django_restful 创建 api 应用,创建完成之后可以看到项目文件夹下面多了一个 api 文件夹. 12D:\\&gt;cd django_restful D:\\django_restful&gt;python manage.py startapp api 进入到 D:\\django_rest\\django_restful 目录，打开 settings.py 在项目下创建 api 和 rest_framework。 12345678910INSTALLED_APPS = [ &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;rest_framework&#x27;, &#x27;api&#x27;, ] rest_framework 权限配置 默认的权限策略可以设置在全局范围内，通过 DEFAULT_PERMISSION_CLASSES 设置。在该文件末尾添加如下内容： 12345REST_FRAMEWORK = &#123; &#x27;DEFAULT_PERMISSION_CLASSES&#x27;: ( &#x27;rest_framework.permissions.IsAuthenticated&#x27;, ) &#125; 数据库迁移然后通过命令 migrate 命令进行数据库迁移。 1D:\\django_restful&gt;python manage.py migrate 执行之后看到如下提示说明迁移成功 1234567891011121314151617Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying sessions.0001_initial... OK 创建超级管理员使用 createsuperuser 命令来创建超级管理员账户，密码至少 8 位数字和字母组合。 123456D:\\django_rest&gt;python manage.py createsuperuser Username (leave blank to use &#x27;admin&#x27;): 账户Email address: 邮箱Password: Password (again): Superuser created successfully. 启动 Server启动 django，然后验证登录我们创建的超级管理员账户。 12345678D:\\django_rest&gt;python manage.py runserver Performing system checks... System check identified no issues (0 silenced). July 20, 2020 - 16:01:39 Django version 2.0.7, using settings &#x27;django_rest.settings&#x27; Starting development server at http://127.0.0.1:8000/ Quit the server with CTRL-BREAK. 启动成功之后，输入地址:http://127.0.0.1:8000/ 我们可以看到如下页面： 登录超级管理员账户我们再输入地址：http://127.0.0.1:8000/admin 即可进入到登录超级管理员账户界面： 登录我们创建的账户，可以看到如下界面： 下面部分内容参考如下： https://www.django.cn/course/show-20.html 感兴趣同学可去查阅 三、数据序列化Serializers 用于定义 API 的表现形式，如返回哪些字段、返回怎样的格式等。这里序列化 Django 自带的 User 和 Group。创建数据序列化，在 api 应用下创建 serializers.py 文件。 serializers.py脚本： 12345678910from django.contrib.auth.models import User,Groupfrom rest_framework import serializersclass UserSerializer(serializers.HyperlinkedModelSerializer):class Meta: model=User fields=(&#x27;url&#x27;,&#x27;username&#x27;,&#x27;email&#x27;,&#x27;groups&#x27;)class GroupSerializer(serializers.HyperlinkedModelSerializer): class Meta: model=Group fields=(&#x27;url&#x27;,&#x27;name&#x27;) 四、创建视图视图用于如何向用户展示数据，展示哪些数据。比如用户查询 User 信息或查询 Group 信息，那么程序内部要定义好。 怎么去查询。在 Django REST framework 中，ViewSets 用于定义视图的展现形式，例如返回哪些内容，需要做哪些权限处理 打开 api 应用下的 views.py 文件，编写如下代码: views.py脚本： 123456789101112from django.shortcuts import renderfrom django.contrib.auth.models import User,Groupfrom rest_framework import viewsetsfrom api.serializers import UserSerializer,GroupSerializer# Create your views here.class UserViewSet(viewsets.ModelViewSet): queryset = User.objects.all() serializer_class = UserSerializerclass GroupViewSet(viewsets.ModelViewSet): queryset = Group.objects.all() serializer_class = GroupSerializer 五、URL 路由配置打开…/django_restful/urls.py 文件，添加 api 的路由配置。 脚本文件： 1234567891011121314from django.contrib import adminfrom django.urls import pathfrom django.conf.urls import includefrom rest_framework import routersfrom api import viewsrouter = routers.DefaultRouter()router.register(r&#x27;users&#x27;, views.UserViewSet)router.register(r&#x27;groups&#x27;, views.GroupViewSet)urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;&#x27;, include(router.urls)), path(&#x27;api-auth/&#x27;, include(&#x27;rest_framework.urls&#x27;, namespace=&#x27;rest_framework&#x27;)),] 六、打开 API 主页启动服务，然后在浏览器打开：http://127.0.0.1:8000/ 即可看到 API 主页，如下所示： 七、创建数据点击主页右上角的 Log in 登录超级管理员账户，然后分别创建 Group 和 User 数据。 Vary: Accept 标头可告诉代理服务器缓存两种版本的资源：压缩和非压缩，这有助于避免一些公共代理不能正确地检测 Content-Encoding 标头的问题 八、wagger 接口文档生成接口开发完成了，那么接下来需要编写接口文档。传统的接口文档编写都是使用 Word 或者其他一些接口文档管理平台，这种形式接口文档维护更新比较麻烦，每次接口有变动时得手动修改文档。因此，针对这种情况，这里推荐使用 Swagger 来管理接口文档。 1．Swagger 简介Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统(源代码)作为服务器以同样的速度来更新。每当接口有变动时，对应的接口文档也会自动更新。 Tips：http://httpbin.org/#/ 也是利用 Swagger 生成接口文档。 Swagger 能成为最受欢迎的 REST APIs 文档生成工具之一，有以下几个原因： • Swagger可以生成一个具有互动性的 API 控制台，开发者可以用来快速学习和尝试 API。 • Swagger 可以生成客户端 SDK 代码用于各种不同的平台上的实现。 • Swagger 文件可以在许多不同的平台上从代码注释中自动生成。 • Swagger 有一个强大的社区，里面有许多强悍的贡献者。 2．Django 接入 Swagger首先安装 django-rest-swagger 1pip install django-rest-swagger 进入到 setting.py 文件，添加 django-rest-swagger 应用 进入到 setting.py 文件，添加 django-rest-swagger 应用 脚本： 123456789101112# Application definitionINSTALLED_APPS = [ &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;rest_framework&#x27;, &#x27;api&#x27;, &#x27;rest_framework_swagger&#x27;, ] 进入到 views.py 将之前定义的 UserViewSet 和 GroupViewSet 补充注释： 脚本： 1234567891011121314151617181920212223242526272829303132333435363738from django.contrib.auth.models import User,Groupfrom rest_framework import viewsetsfrom api.serializers import UserSerializer,GroupSerializer# Create your views here.class UserViewSet(viewsets.ModelViewSet): &quot;&quot;&quot; retrieve: Return a user instance. list: Return all users, ordered by most recently joined. create: Create a new user. delete: Remove an existing user. partial_update: Update one or more fields on an existing user. update: Update a user. &quot;&quot;&quot; queryset = User.objects.all() serializer_class = UserSerializerclass GroupViewSet(viewsets.ModelViewSet): &quot;&quot;&quot; retrieve: Return a group instance. list: Return all groups, ordered by most recently joined. create: Create a new group. delete: Remove an existing group. partial_update: Update one or more fields on an existing group. update: Update a group. &quot;&quot;&quot; queryset = Group.objects.all() serializer_class = GroupSerializer 在 urls.py 添加 get_schema_view 辅助函数 脚本： 123456789from rest_framework.schemas import get_schema_view from rest_framework_swagger.renderers import SwaggerUIRenderer,OpenAPIRenderer schema_view=get_schema_view(title=&#x27;API&#x27;,renderer_classes=[OpenAPIRenderer,SwaggerUIRenderer]) urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;&#x27;,include(router.urls)), path(&#x27;api-auth/&#x27;,include(&#x27;rest_framework.urls&#x27;,namespace=&#x27;rest_framework&#x27;)), path(&#x27;docs/&#x27;,schema_view,name=&#x27;docs&#x27;) ] 启动服务，然后打开地址：http://127.0.0.1:8000/docs/ 即可看到如下界面 然后一打开就报错这个： 解决方法 再次启动： 启动服务，然后打开地址：http://127.0.0.1:8000/docs/ 即可看到如下界面","categories":[],"tags":[{"name":"restful django","slug":"restful-django","permalink":"http://example.com/tags/restful-django/"}],"keywords":[]},{"title":"学习常用","slug":"学习常用","date":"2021-09-10T08:43:14.000Z","updated":"2021-09-10T09:36:26.046Z","comments":true,"path":"2021/09/10/学习常用/","link":"","permalink":"http://example.com/2021/09/10/%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8/","excerpt":"","text":"一、常用的函数模块1.生成报告 12345678910111213141516import unittestfrom HTMLTestRunner import HTMLTestRunnerimport timetest_dir=&#x27;./&#x27;discovery=unittest.defaultTestLoader.discover(test_dir,pattern=&quot;test*.py&quot;)if __name__ == &#x27;__main__&#x27;: report_dir=&#x27;./&#x27; now=time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;) report_name=report_dir+&#x27;/&#x27;+now+&#x27;result.html&#x27; with open(report_name,&#x27;wb&#x27;) as f: runner=HTMLTestRunner(stream=f,title=&quot;Test Report&quot;,description=&quot;test weather &quot;) runner.run(discovery) f.close() 2.发送报告 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import osfrom selenium import webdriverimport unittestfrom BSTestRunner import BSTestRunnerimport timeimport smtplibfrom email.mime.text import MIMETextfrom email.header import Header# import yagmaildef insert_img(driver,filename): func_path = os.path.dirname(__file__) base_dir = os.path.dirname(func_path) base_dir = str(base_dir) base_dir = base_dir.replace(&#x27;\\\\&#x27;, &#x27;/&#x27;) base = base_dir.split(&#x27;/Website&#x27;)[0] filepath = base + &#x27;/Website/test_report/screenshot/&#x27; + filename driver.get_screenshot_as_file(filepath)# def send_tupian():# mail=yagmail.SMTP(user=&#x27;2474274316@qq.com&#x27;,host=&#x27;smtp.qq.com&#x27;)# contents=[&#x27;第一段&#x27;,r&#x27;C:/Users/hccz/PycharmProjects/pythonProject1/Website//test_report/screenshot/&#x27;]# mail.send(&#x27;2474274316@qq.com&#x27;,contents)def send_mail(latest_report): f=open(latest_report,&#x27;rb&#x27;) mail_content=f.read() f.close() smtpserver=&#x27;smtp.163.com&#x27; user = &#x27;hj18594962283@163.com&#x27; password = &#x27;XJQZVXBYVRSERDSS&#x27; # 授权码 sender = &#x27;hj18594962283@163.com&#x27; receives = &#x27;2474274316@qq.com&#x27; subject = &#x27;整合&#x27; msg = MIMEText(mail_content, &#x27;html&#x27;, &#x27;utf-8&#x27;) msg[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;) msg[&#x27;From&#x27;] = sender msg[&#x27;To&#x27;] = &#x27;,&#x27;.join(receives) smtp = smtplib.SMTP_SSL(smtpserver, 465) smtp.helo(smtpserver) smtp.ehlo(smtpserver) smtp.login(user, password) print(&quot;Start send Email...&quot;) smtp.sendmail(sender, receives, msg.as_string()) smtp.quit() print(&quot;Send Email end!&quot;)def latest_report(report_dir): lists = os.listdir(report_dir) lists.sort(key=lambda fn: os.path.getatime(report_dir + &#x27;\\\\&#x27; + fn)) print((&quot;new report is :&quot; + lists[-1])) file = os.path.join(report_dir, lists[-1]) print(file) return fileif __name__ == &#x27;__main__&#x27;: # driver = webdriver.Firefox() # driver.get(&quot;http://localhost/news/&quot;) # inser_img(driver, &quot;hj.png&quot;) # driver.quit() test_dir=&#x27;./&#x27; report_dir=&#x27;./&#x27; discover = unittest.defaultTestLoader.discover(test_dir, pattern=&quot;test*.py&quot;) now = time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;) report_name = report_dir + &#x27;/&#x27; + now + &#x27;result.html&#x27; with open(report_name, &#x27;wb&#x27;) as f: runner =BSTestRunner(stream=f, title=&quot;Test Report&quot;, description=&quot;bb&quot;) runner.run(discover) f.close() latest_report=latest_report(report_dir) send_mail(latest_report) 3.BSTESTRUNNER.PY文件和HTMLTESTRUNNER.PY文件 二、常见的文件格式1.yaml文件 格式如下： 1234567891011platformName: AndroidplatformVersion: 7.1.2deviceName: 127.0.0.1:62025app: D:\\kaoyan.apknoReset: FalseappPackage: com.tal.kaoyanappActivity: com.tal.kaoyan.ui.activity.SplashActivityip: 127.0.0.1port: 4723unicodeKeyboard: trueresetKeyboard: true 2.Jason文件","categories":[],"tags":[{"name":"学习常用","slug":"学习常用","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8/"}],"keywords":[]},{"title":"requests库","slug":"requests库","date":"2021-09-09T10:06:15.000Z","updated":"2021-09-09T11:20:15.417Z","comments":true,"path":"2021/09/09/requests库/","link":"","permalink":"http://example.com/2021/09/09/requests%E5%BA%93/","excerpt":"","text":"概述httpbin.org 网站： 测试HTTP请求和响应的各种信息，比如cookie,ip,headers和登陆验证等，且支持get、post、delete、patch、put等多种方法，它用Python + Flask 编写，是一个开源项目。 安装requests库：打开cmd,输入下面语句 1pip install requests 结合pycharm使用，在pycharm中查看该模块是否装成功，File——&gt;settings——&gt;Project (Python Interpreter) 一、基础使用1.发送请求（基于requests库） 发送get型请求：requests.get(base_url+’/get’) 发送post型请求：requests.post(base_url+’/post’) 发送put型请求：requests.put(base_url+’/put’) 发送delete型请求：requests.delete(base_url+’/delete’) 2.传递URL参数 传递url参数：requests.get(base_url+’/get’,params=param_data) 3.传递body参数 传递body参数：requests.post(base_url+’/post’,data=form_data) 4.请求头定制 请求头定制：requests.post(base_url+’/post’,data=form_data,headers=header) 5.获取响应内容 获取响应内容：requests.post(base_url+’/post’,data=form_data,headers=header) 6、获取cookie 获取cookie：r.cookies（获取cookie所有的键值） 7.设置cookie 设置cookie： 12url = &#x27;http://httpbin.org/cookies&#x27;r = requests.get(url, cookies=cookie) 8.超时的问题","categories":[],"tags":[{"name":"requests库","slug":"requests库","permalink":"http://example.com/tags/requests%E5%BA%93/"}],"keywords":[]},{"title":"jmeter 接口测试","slug":"jmeter-接口测试","date":"2021-09-09T03:39:51.000Z","updated":"2021-09-09T06:33:45.950Z","comments":true,"path":"2021/09/09/jmeter-接口测试/","link":"","permalink":"http://example.com/2021/09/09/jmeter-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/","excerpt":"","text":"jmeter脚本编写的步骤： 添加线程组 添加HTTP请求 在HTTP请求中写入接入 url、路径、请求方式和参数 添加查看结果树 调用接口、查看返回值 本次用来测试的接口地址的api：httpbin.org 一、实施1-2步骤：添加线程组、http请求 二、配置http请求的相关参数在 http 请求中写入接入 url、路径、请求方式和参数，当前选择请求的方式为GET方式。 三、调用接口，查看返回值 添加查看结果树 调用接口，得到返回值 四、请求方式改为post方式来进行请求改为post进行测试，得到的响应数据 五、HTTP 请求默认值通过上面两个请求我们发现，Web 服务器中的协议和服务器名称或 IP 这两个值都是一样，每次重复输入其实比较麻烦，因此我们可以使用 HTTP 请求默认值来管理这些公共的配置数据。 添加步骤： 线程组——添加——配置元件——HTTP 请求默认值 然后进行如下配置，并把该元件放置到请求前面 经过请求默认值的配置后，后续我们增加新的请求，如果这两项值是一样的话，那么则无需再重复填入该值。 六、断言设置Jmeter 可以针对每一个请求响应进行断言。 设置步骤: 选中一个请求，如 http-get,然后右键选择： 添加——断言——相应断言 各个匹配模式含义如下 包括：响应内容包括需要匹配的内容即代表响应成功，支持正则表达式 匹配：响应内容要完全匹配需要匹配的内容即代表响应成功，大小写不敏感，支持正则表达式。 Equals：响应内容要完全等于需要匹配的内容才代表成功，大小写敏感，需要匹配的内容是字符串正则表达式 Substring：返回结果包含指定结果的字串，但是 subString 不支持正则字符串 如下图所示匹配返回的字符串是否包含：http://httpbin.org/get 如果断言成功，则查看结果树为绿色标志，如果断言失败则为红色显示，如下图所示： 七、参数设置Jmeter 支持通过 Query String Parameters 或者 Request body 请求体来传递参数。 Query String Parameters 如果希望在请求 URL 中添加参数，则可以在 Http 请求界面的 Parameters 选项里面添加参数。该参数会通过 Query String Parameters 方式传递给服务器，也就是在 URL 中传递参数。 如下图如所示设置参数： Request body 在 Post 请求中参数一般在 body 中传递，Jmeter 也支持在 body 中传递参数。如传递 Json 格式的参数，在 BodyData 编辑框输入如下参数： {“username”:”Test1234”} 另外还需要指定参数的格式，因此需要添加 HTTP 信息头 添加步骤： 选定请求——添加——配置元件——HTTP 信息头管理器，然后在管理器里面添加参数类型Content-Type ：application/json 如下图所示： 八、变量在请求过程中，有时我们需要在请求中设置一些变量来测试不同的场景。 Jmeter 支持以下类型变量： 用户自定义变量 函数生成变量 数据文件变量 1.用户自定义变量 设置步骤: 选中请求——添加——前置处理器——用户参数 设置变量名称为 user，值为 Test1234 在请求时引用变量如下所示: 变量引用格式为：${user} 2.函数生成变量 Jmeter 有许多内置的函数，可以生成随机数。 创建步骤: 点击菜单栏工具——函数助手对话框——下拉选择__Random()函数 函数配置如下： 3.CSV 数据文件变量 CSV 数据文件变量是指从外部 csv 文件读取数据出来作为变量。 设置步骤: 选择请求——添加——配置元件——CSV 数据文件设置 创建 csv 文件: 注意文件编码为 UTF-8 文件内容如下： 1Test1234,Test1234 dd.csv CSV 数据文件设置如下： 在 Post 请求中引用变量数据如下： 得到的请求数据 4.CSV参数化 针对之前的 POST 接口进行如下参数遍历测试： 接口如下： http://httpbin.org/post 发送参数：user1.csv 123user1,user1user2,user2user3,user3 在之前的 csv 数据文件设置需要需改配置如下： 表示把所有数据读取一遍，且不重复。 读取的数据： 九、用例分离用例设计之前我们的用例数据都是配置在 Jmeter Http 请求中，每次需要增加，修改用例都需要打开 jmeter 重新编辑，当 用例越来越多的时候，用例维护起来就越来越麻烦，有没有好的方法来解决这种情况呢？ 其实我们可以将用例的数据存放在 csv 文件中，然后通过 csv 文件配置来读取用例中的数据，执行测试。用例数据如图所示： 用例名称变量含义： 1．${caseSeq}:用例编号 2．${apiType}:api 类型 3．${apiSeq} ：api 版本号 4．${apiName}：api 名称 5．${priority}:优先级 6．${url}:api 路径 7．${methods}:请求方法 8．${parameter}: 请求参数 9．${expectValue}:期望值，用于断言 Jmeter设置步骤：1. 新建一个线程组，命名为：数据驱动 2.创建一个 http 请求默认值，设置如下： 3.添加一个循环控制器步骤为：线程组——添加——逻辑控制器——循环控制器。 循环控制器的作用可以控制整个用例循环执行的次数。默认值是 1 根据用例数量可以修改为 4 4.在循环控制器节点下创建 CSV 文件设置，具体配置内容如下——注意csv文件为上面的用例设计这步 5.创建一个 if 控制器步骤为：循环控制器——添加——逻辑控制器——if 控制器 if 控制器的作用为根据不同条件执行不同的用例，例如这里根据不同的接口请求类型，分别创建了 GET 和 POST 两个控制器。 GET 设置的条件语句如下： 条件语句为：**”${methods}”==”GET”其中${methods}表示引用 csv 中的methods中的值。** 参数： Interpret Condition as Variable Expression?：如果这个选项被选中，将不会使用 js 解析;条件表达式的值必须是true(忽略大小写)，这里我们取消勾选状态。 Evaluate for all children：如果选中这一项，在每个子结点执行前都会计算表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#### 6. **创建 GET 请求类型的用例如下:**![](https://pic.imgdb.cn/item/6139a56544eaada739942826.png)#### 7. **POST请求设置：POST 条件语句设置为：&quot;$&#123;methods&#125;&quot;==&quot;POST&quot;** ![](https://pic.imgdb.cn/item/6139a50b44eaada73993993d.jpg)![](https://pic.imgdb.cn/item/6139a59844eaada739947ab9.jpg)用例名称格式：$&#123;caseSeq&#125;_ $&#123;apiSeq&#125;_$&#123;apiName&#125; 断言设置如下：$&#123;expectValue&#125;引用 csv 中对应的值。![](https://pic.imgdb.cn/item/6139a5e444eaada73994ecf2.jpg)## 十、**测试报告** 批量执行完接口测试之后，我们需要查看测试报告，在之前单个接口调试我们是通过查看结果树查看结果，但是当大 批量执行接口测试之后依旧这样查看那么肯定会很低效 那么该如何设置呢？ **聚合报告** 聚合报告是一个比较精简的报告元件，可以查看每个接口的性能情况与执行结果。 设置步骤：选中线程组——添 加——监听器——聚合报告。报告各个参数含义如下： • Samples -- 本次场景中一共完成了多少个请求 • Average -- 平均响应时间(单位：ms) • Median -- 响应时间的中值(单位：ms) • 90% Line -- 所有请求中 90%的响应时间。 • Min -- 最小响应时间(单位：ms) • Max -- 最大响应时间(单位：ms) • Error -- 出错率 • Troughput -- 吞吐量 • Received--响应数据大小 • KB/sec -- 以流量做衡量的吞吐量 **HTML 报告** 有时候我们需要将测试报告以 HTML 附件形式发送给各个项目成员，那么需要生成 HTML 报告。 JMeter3.0 以后 引入了 Dashboard Report，用于生成 HTML 页面格式图形化报告的扩展模块。 生成步骤： 打开 cmd 进入 jmeter 目录 bin 目录 执行命令: jmeter -n -t httpbin_test.jmx -l httpbin.jtl -e -o C:\\Users\\Administrator\\Desktop\\Report 命令的参数： -n ：以非 GUI 形式运行 Jmeter -t ：jmeter 脚本路径 -l ：result.jtl 运行结果保存路径（.jtl）此文件必须不存在。 -e ：在脚本运行结束后生成 html 报告 -o ：用于存放 html 报告的目录，不加该参数默认生成到 参考/拓展资料 https://blog.csdn.net/zhizunyu2009/article/details/79011413 https://blog.csdn.net/gld824125233/article/details/52842914 https://blog.csdn.net/defonds/article/details/53517247 https://blog.csdn.net/wuyou10206/article/details/77539791 https://blog.csdn.net/huangjuyan/article/details/52993758 https://www.cnblogs.com/imyalost/p/10239317.html","categories":[],"tags":[{"name":"jmeter 接口测试","slug":"jmeter-接口测试","permalink":"http://example.com/tags/jmeter-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"}],"keywords":[]},{"title":"软件测试活动","slug":"软件测试活动","date":"2021-09-08T11:43:08.000Z","updated":"2021-09-08T11:47:59.145Z","comments":true,"path":"2021/09/08/软件测试活动/","link":"","permalink":"http://example.com/2021/09/08/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B4%BB%E5%8A%A8/","excerpt":"","text":"一、测试需求1. 测试需求的定义测试需求主要解决“测试什么”，即指明被测对象中什么需要测试。 需求测试通常是以软件开发需求为基础的分析，通过对需求的细分化和分解，形成可测试的内容。 测试需求因覆盖全部已定义的业务流程，以及功能和非功能方面的需求。 2. 需求的特征制定的测试需求项必须是可核实的。即，它们必须有一个可观察、可评测的结果，无法核实的需求不是测试需求； 测试需求应指明满足需求的正常的前置条件，同时也要指明不满足需求时的出错条件； 3. 为什么要做测试需求A. 软件测试需求是开发测试用例的依据； B. 有助于保证测试的质量与进度； C. 测试需求是衡量测试覆盖率的重要指标； 4. 不做需求分析的后果A. 浪费时间和资源实现了用户不需要的需求； B. 遗漏了需求文档中没提到，但很重要的需求，导致客户满意度降低。 C. 需求分析不到位，错误的估计了测试的工作量，导致延误发布周期，可能会降低发布质量。 5. 需求阶段主要做什么？有需求文档：检查需求文档描述的正确性，整理出需求的疑问点，明确点，让所有人一致理解正确的需求。 没有需求文档：那就要发挥测试人员的主管能动性了,这个问题面试的时候会问得到。 没有需求文档时候应该怎么办？ 当项目比较紧张的时候，很多时候需求文档这个重要的步骤就会被省略或者延后，从流程上来说是绝对不规范的。 对于一些没有形成系统测试规范的公司，并且国内测试现状也大概如此，缺胳膊少腿的现象是很正常的，我们测试人员只能灵活应对。 A. 没有需求文档，找别的文档。 需求文档可能由于时间原因暂时无法获取，那就尽量的去获取其他的文档，比如开发的一些设计文档—概要设计、功能设计、详细设计等等。如果开发连这些文档都没有，那么可以去网上查询同类产品的一些规格说明书。这些材料虽然不是自己产品的需求说明，但是因为是同类产品，功能方面也总会有8、9分类似。 B. 模块定位和划分 如果开发有详细的设计文档，那么就按照开发的设计，将产品按照功能模块迅速简捷的先进行模块划分。如果没有开发文档，那就要跟开发沟通，让他们简单介绍一下产品的功能模块并自己试用后对产品进行模块划分。模块划分后，组内分工合作，进行探索性测试同时不断完善测试计划和测试需求，因为前期 概要的了解产品绝对不可能一次到位的对各个模块划分准确的。 6. 需求采集过程 测试需求采集的定义 需求采集的过程是将软件开发需求中的那些具有可测试性的需求或特性提取出来，形成原始测试需求； 可测试性是指这些提取的需求或特性必须存在一个可以明确预知的结果，可以用某种方法对这个明确的结果进行判断、验证，验证是否符合文档中的要求； 测试需求测试的提取方法 a. 通过列表的形式对软件开发需求进行梳理，形成原始测试需求列表，列表的内容包括需求标识、原始测试需求描述； b. 将每一条软件需求对应的开发文档及章节号作为软件需求标识； c. 使用软件需求的简述作为原始测试需求描述；","categories":[],"tags":[{"name":"测试活动","slug":"测试活动","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95%E6%B4%BB%E5%8A%A8/"}],"keywords":[]},{"title":"Postman接口测试工具","slug":"Postman接口测试工具","date":"2021-09-08T06:38:48.000Z","updated":"2021-09-08T10:11:40.853Z","comments":true,"path":"2021/09/08/Postman接口测试工具/","link":"","permalink":"http://example.com/2021/09/08/Postman%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/","excerpt":"","text":"一、postman的概述一般简单的接口测试我们可以直接在浏览器里面进行调试，但是涉及到一些权限设置的就无法操作了，因此我们需 要接口测试的相关工具；Postman 是一个接口测试和http请求的工具 1.postman的下载、安装 软件下载地址：https://dl.pstmn.io/download/latest/win64 当然这软件不能支持设置中文，如果对想看中文的，可以下载这款国产高仿的接口测试软件：apipost 软件官网：https://www.apipost.cn/# 软件手册：https://doc.apipost.cn/4a77c87f97fb686b 2.postman 的优缺点 1.支持各种的请求类型: get、post、put、patch、delete 等 2.支持在线存储数据，通过账号就可以进行迁移数据 3.很方便的支持请求 header 和请求参数的设置 4.支持不同的认证机制，如 Basic Auth，Digest Auth，OAuth 1.0，OAuth 2.0 等 5.响应数据是自动按照语法格式高亮的，包括 HTML，JSON 和 XML 3.postman的界面介绍 A.界面组成 B.控制台 postman 控制台：先打开 console，再点击 send 发送请求 devtools 控制台：view –&gt;developer 下 快捷键（ctrl+shift+I） C.基本的使用 new，新建按钮，可以创建：请求、集合、环境变量、文档、Mock 服务器、监视器、模版、API network Request：创建一个基本的请求 Collection：就是请求的集合，里面可放多个请求，这些请求可以组成一组相关的测试场景 Environment：环境变量，用变量替代 URL 中的参数值 Monitor：监视器，定时运行接口，并收集、检查性能和相应结果（局域网不能使用，只支持公网的 ip 请求；免费版使用次数有限制） API Documemtation：创建接口文档 4.使用postman发送一个请求 启动软件后在引导界面点击 Request，给 Request 命名，然后创建文件夹并把该Request 归属到该文件夹。 在地址栏输入 postman-echo.com/get 然后点击 Send 按钮，可以看到返回值。如下图所示： 二、postman工作原理如下图所示，当您在 Postman 中输入请求并单击 Send 按钮时，服务器将接收您的请求并返回 Postman 在接口中显示的响应。 Request 编辑 在主界面左侧可以查看、保存、编辑 Request。 三、postman发送多种请求1. 发送 get 请求 HTTP GET 请求方法用于从服务器检索数据。 数据由唯一的 URI(统一资源标识符)标识。 GET 请求可以使用“Query String Parameters”将参数传递给服务器。 例如，在下面的请求中： 案例：查询快递 100 的接口，下面准备接口地址 1https://www.kuaidi100.com/query?type=yuantong&amp;postid=123456 说明： ​ Type、postid 表示发送的参数 ​ ？问号后面连接参数 ​ &amp;表示连接多个参数 编辑参数： 解释： Type 设置的快递公司名称的拼音 Postid:表示快递的单号 2. 发送 post 请求 HTTP POST 请求方法旨在将数据传输到服务器，返回的数据取决于服务器的实现。POST 请求可以使用 Query String Parameters 以及 body 将参数传递给服务器 案例 1： 1https://postman-echo.com/post?param=java 返回值： 123456789101112131415161718192021&#123;&quot;args&quot;: &#123; &quot;param&quot;: &quot;java&quot; &#125;,&quot;data&quot;: &#123;&#125;, &quot;files&quot;: &#123;&#125;, &quot;form&quot;: &#123;&#125;, &quot;headers&quot;: &#123; &quot;x-forwarded-proto&quot;: &quot;https&quot;, &quot;x-forwarded-port&quot;: &quot;443&quot;, &quot;host&quot;: &quot;postman-echo.com&quot;, &quot;x-amzn-trace-id&quot;: &quot;Root=1-5f297e6e-ff1108001ac45200f71e6e00&quot;, &quot;content-length&quot;: &quot;0&quot;, &quot;cache-control&quot;: &quot;no-cache&quot;, &quot;postman-token&quot;: &quot;69f685b5-96ab-4ca2-83b5-26f4e1c50203&quot;, &quot;user-agent&quot;: &quot;PostmanRuntime/7.4.0&quot;, &quot;accept&quot;: &quot;*/*&quot;, &quot;cookie&quot;: &quot;sails.sid=s%3AwSs2NC8SufYRF_X8JSeoRRYm2S8zld8-.0lM9TgljEowpovt7s9T4jobFlIbPoF5e6gaYBSiw758&quot;, &quot;accept-encoding&quot;: &quot;gzip, deflate&quot; &#125;, &quot;json&quot;: null, &quot;url&quot;: &quot;https://postman-echo.com/post?param=java&quot;&#125; 案例 2： 123发送一个 Request，其中 body 为 application/x-www-form-urlencoded 类型，参数分别为 param1=wulibobo 和 param2=888 请 求 URL 如下： https://postman-echo.com/post Postman Body 数据类型说明： 1234• form-data multipart/form-data 是 Web 表单用于传输数据的默认编码。这模拟了在 网站上填写表单并提 交它。表单数据编辑器允许我们为数据设置键-值对。我们也可以为文 件设置一个键，文件本身作为值进行 设置。 • x-www-form-urlencoded 该编码与 URL 参数中使用的编码相同。我们只需输入键- 值对，Postman 会 正确编码键和值。请注意，我们无法通过此编码模式上传文件。表单 数据和 urlencoded 之间可能存在一些差异，因此请务必首先检查 API 的编码实现，确定 是否可以使用这种方式发送请求。 • raw 请求可以包含任何内容。除了替换环境变量之外，Postman 不触碰在编辑器中输入 的字符串。无论你 在编辑区输入什么内容，都会随请求一起发送到服务器。编辑器允许我 们设置格式类型以及使用原始主体 发送的正确请求头。我们也可以手动设 Content-Type标题，这将覆盖 Postman 定义的设置。 • binary 二进制数据可让我们发送 Postman 中无法输入的内容，例如图像，音频或视频 文件。 3. 发送 put 请求 HTTP PUT 请求主要是从客户端向服务器传送的数据取代指定的文档的内容。 PUT 请求可以使用 Query String Parameters 以及 body 请求体将参数传递给服务器。 案例：发送 put 请求，并传递字符串参数“wulibobo” 4. 发送 delete 请求 HTTP DELETE 方法用于删除服务器上的资源，DELETE 请求可以使用 Query String Parameters 以及 body 请求体将 参数传递给服务器。 准备接口参数： 1https://postman-echo.com/delete 5. 请求头 Request Header（请求头）用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、Referer、User-Agent 等。在 Postman 中可以在请求下方的 Headers 栏目来 设置，如下如图所示： 准备接口参数： 1https://postman-echo.com/post?param=java&amp;param=C# 6. 响应头 Response Header(响应头)其中包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等， 在 Postman 主界面下方 Headers 或者 Postman Console 界面都可以查看 Response Header 信息。 四、授权设置很多时候，出于安全考虑我们的接口并不希望对外公开。这个时候就需要使用授权(Authorization)机制 授权过程 验证您是否具有访问服务器所需数据的权限。 当您发送请求时，您通常必须包含参数，以确保请求具有访问和返 回所需数据的权限。 Postman 提供授权类型，可以轻松地在 Postman 本地应用程序中处理身份验证协议。 Postman 支持的授权协议类型如下： • No Auth• Bearer Token • Basic auth • Digest Auth • OAuth 1.0 • OAuth 2.0 • Hawk Authentication • AWS Signature • NTLM Authentication [Beta] 这里主要介绍以上加粗的授权协议。 1. 如何打开授权界面 下方演示如何打开授权界面 2. Basic auth 授权 基本身份验证是一种比较简单的授权类型，需要经过验证的用户名和密码才能访问数据资源。这就需要我们输入用 户名和对应的密码。 案例：请求 URL 如下，授权账号为： 123• 用户名: postman • 密码: password • 授权协议为：Basic auth 准备的 URL：https://postman-**echo**.**com**/basic-auth 注意： • 如果不输入用户名密码，直接使用 GET 请求，则会返回提示：Unauthorized • 输入用户名密码，选择 Basic auth 授权类型，则返回如下结果： 3. Digest Auth 授权 Digest auth 是一个简单的认证机制，最初是为 HTTP 协议开发的，因此也常叫做HTTP 摘要。其身份验证机制非 常简单，它采用哈希加密方法，以避免用明文传输用户的口令。摘要认证就是要核实參与通信的两方都知道双方共享的一个口令。当 server 想要查证用户的身份，它产生一个摘要盘问（digest challenge），并发送给用户。典型的摘要盘问例如 以下: 12Digest realm=&quot;iptel.org&quot;, qop=&quot;auth,auth-int&quot;, nonce=&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093&quot;, opaque=&quot;&quot;, algorithm=MD5 这里包含了一组参数，也要发送给用户。用户使用这些參数，来产生正确的摘要回答，并发送给 server。各个參数意义如下： 123realm（领域）：领域參数是强制的，在全部的盘问中都必须有。它是目的是鉴别 SIP 消 息中的机密。在 SIP 实际应用中，它通常设置为 SIP 代理 server 所负责的域名。 nonce（现时）：这是由 server 规定的数据字符串，在 server 每次产生一个摘要盘问时， 这个參数都是不一样的 （与前面所产生的不会雷同）。“现时”一般是由一些数据通过 md5 杂凑运算构造的。 这种数据通常包含时间标 识和 server 的机密短语。这确保每一个“现 时”都有一个有限的生命期（也就是过了一些时间后会失效，并且以后再也不会使用），并 且是独一无二的 （即不论什么其他的 server 都不能产生一个同样的“现时”）。 algorithm（算法）：这是用来计算的算法。当前仅仅支持 MD5 算法。 qop（保护的质量）。这个參数规定 server 支持哪种保护方案。client 能够从列表中选择 一个。值 auth 表示仅仅 进行身份查验， auth-int 表示进行查验外，另一些完整性保护。须要看更具体的描写叙述，请參阅 RFC2617。 参考链接：https://blog.csdn.net/guobailu/article/details/82775459 案例： 准备 URL： https://postman-**echo**.**com**/digest-auth 配置： 123Digest username=&quot;postman&quot;, realm=&quot;Users&quot;, nonce=&quot;ni1LiL0O37PRRhofWdCLmwFsnEtH1lew&quot;,uri=&quot;/digest-auth&quot;, response=&quot;254679099562cf07df9b6f5d8d15db44&quot;, opaque=&quot;&quot; 一切都正确，结果如下： 4. Hawk Auth Hawk Auth 是一个 HTTP 认证方案，使用 MAC(Message Authentication Code，消息认证码算法)算法，它提供 了对请求进行部分加密验证的认证 HTTP 请求的方法。 hawk 方案要求提供一个共享对称密匙在服务器与客户端之 间，通常这个共享的凭证在初始 TLS（安全传输层协议）保护阶段建立的，或者是从客户端和服务器都可用的其他一些共享机密信息中获得的。 1) 准备参数 请求的 URL：****https://postman-echo.com/auth/hawk 秘钥信息： Hawk Auth ID: dh37fgj492je Hawk Auth Key: werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn Algorithm: sha256 按步骤操作及结果如下： 5. OAuth 1.0 OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片， 视频，联系人列表），而无需将用户名和密码提供给第三方应用。 扩展资料： https://blog.huoding.com/2010/10/10/8 1) 准备参数 请求 URL 如下：请求方式为 GET，Add authorization data to 设置 Request Headers 为：https://postman-**echo**.**com**/oauth1 配置参数： Consumer Key: RKCGzna7bv9YD57c Consumer Secret: D+EdQ-gs$-%@2Nu7 2) 步骤截图及结果 异常结果： 如果 Consumer Secret 错误则返回如下结果： 五、Cookie 设置1. 什么是 cookie cookie 是存储在浏览器中的小片段信息，每次请求后都将其发送回服务器，以便在请求之间存储有用的信息。比如很多网站登录界面都有保留账号密码，以便下次登录。 Cookie 是由服务端生成，存储在响应头中，返回给客户端，客户端会将 cookie 存 储下来，在客户端发送请求时， user-agent 会自动获取本地存储的 cookie，将 cookie 信息存储在请求头中，并发送给服务端。 postman 也可以设置、获取、删除 Cookie。 2. 设置 cookie 在 Send 按钮下方点击 Cookies 文字菜单，弹出如下界面，然后可以设置 Cookie。 1) 准备参数： 请求 URL：https://www.baidu.com 请求方式：GET 请求 设置 cookie 为：username:hujun 2) 操作步骤： 点击下方 cookie——&gt;添加 cookie——&gt;添加参数进去 点击控制台——&gt;点击发送 查看结果： 4. 删除 cookie 点击 Cookies 文字菜单,然后可以根据需求去清除对应的 Cookie。 六、变量1.变量存在的意义 在开发不同阶段可能存在不同的环境,比如测试环境和生产环境。 测试环境 API 如下： 123https://dev.postman.com/get https://dev.postman.com/post https://dev.postman.com/put 生产环境 API 如下： 123https://postman-echo.com/gethttps://postman-echo.com/post https://postman-echo.com/put 在这么情况下，按照常规思路要么你需要维护两套环境的 API，要么每次都手动一个个去修改 URL，不管哪种选择 都比较麻烦且低效，那么有没有比较的好的方法来解决这个问题呢？ 通过比较我们可以发现，以上两组 API 主要是除了 host 不同之外其他都一样，其实把 Host 用变量替换，这样就可以灵活切换环境。 2.postman的变量类型 postman提供了变量设置，有4种变量类型。 本地变量(LocalVariable ) 全局变量(Global Variable) 环境变量(Environment Variable) 数据变量(Data Variable) 3．Postman 的变量详解 1) 环境变量(Environment Variable) 环境变量指在不同环境，同一个变量值随着环境不同而变化，比如我们上面举例场景就 可以使用环境变量，当在测试环境时，host 值为: dev.postman.com ,当切换到生产环境 时，host 值变为：postman-echo.com 。 环境变量设置： 在 postman 界面点击右上角眼睛图标，即可开始设置环境变量和全 局变量。环境变量设置过程如下图所示： 我们可以设置两种环境 dev 和 release, dev 是开发测试环境； release 是正式的生产环境。 host 环境变量， 根据不同的环境值不一样 同样的步骤，再来添加生产环境 变量引用格式为,如下图所示： 列如：生产环境 完整参考：https://jingyan.baidu.com/article/948f59247349c0980ff5f9c3.html 2) 本地变量(LocalVariable ) 本地变量主要是针对单个 URL 请求设置的变量，作用域只是局限在请求范围内。如请求 URL 如下，设置两个本地变量（user,passwd）作为参数。请求方式为 POST 准备参数：https://postman-**echo**.**com**/post 上面通过环境变量知道，设置变量的格式为： 变量设置好之后需要赋值，在 Pre-request-Script 里面编写如下代码： 12pm.variables.set(&quot;user&quot;,&quot;hujun&quot;);pm.variables.set(&quot;passwd&quot;,&quot;123456&quot;); 点击 send 执行之后的返回值如下，可以看到我们定义的变量已经发送。 3) 全局变量(Global Variable) 全局变量是指在所有的环境里面，变量值都是一样的，全局变量的作用域是所有请求。全局变量设置有两种方式： 1. 点击界面里设置 点击眼睛图标后，在 Global 选项菜单点击 Edit 菜单即可设置全局变量，如下图所示。 全局变量的引用格式和环境 变量一样， 注意：当环境变量和全局变量名称一样时，切换到某个环境时，环境变量会覆盖全局变量。 2.在脚本里设置 使用如下脚本可以设置全局变量：variable_key 表示变量名称， variable_value 表示变量值。 1pm.globals.set(&quot;variable_key&quot;, &quot;variable_value&quot;); 4) 实践案例： 在实际接口测试过程中，接口经常会有关联。比如需要取上一个接口的某个返回值，然后作为参数传递到下一个接 口作为参数。 假设我们要获取 A 接口返回的 userid 值作为 B 接口的请求参数。 A 接口请求 URL 如下： https://postman-echo.com/post • 请求方式为 Post • 请求参数：userid(这里自己定义，接口会返回对应的 id 值) 根据返回值我们需要从返回值中提取 userid 值。在 Test 标签栏下编写如下脚本获取 userid 值 B 接口请求 URL 如下：请求方式为 GET 1postman-echo.com/get?userid=&#123;&#123;userid&#125;&#125; 先执行 A 接口的，然后在执行 B 接口，此时 B 接口通过全局变量 userid 可以获得A 接口的返回值。 七、断言1.定义 一般来说执行完测试，我们需要对测试结果来进行校验，判断结果是是否符合我们的预期，也就是断言。在接口测试中一般会根据响应状态码或者响应返回的数据来进行断言。 Postman 提供一个测试沙箱（Postman Sandbox） 测试沙箱是一个 JavaScript 执行环境，可以通过 JS 脚本来编 写 pre-request Script 和 test Script。 pre-request Script（预置脚本）可以用来修改一些默认参数,在请求发送之前执行。 test Script（测试脚本）当接收到响应之后，再执行测试脚本。 2.断言的案例 (1) 准备的 URL: postman-echo.com/post (2) 断言的规则 响应状态码：200 响应内容：返回的 user 参数值与定义的一致 响应时间：小于 0.5s (3) 准备的脚本 在 pre-request Script 定义变量 user pm.variables.set(“user”,’hujun’); 在test栏下面编写脚本 12345678910111213141516//判断响应状态码pm.test(&quot;Status code is 200&quot;, function () &#123; pm.response.to.have.status(200); &#125;); //获取发送的参数值 username=pm.variables.get(&quot;user&quot;);console.log(username); //校验响应内容是否和请求的一致 pm.test(&quot;Check username&quot;, function () &#123;var jsonData = pm.response.json();pm.expect(jsonData.json[&#x27;user&#x27;]).to.eql(username);&#125;); //检测响应时间是否小于 0.5s pm.test(&quot;Response time is less than 500ms&quot;, function () &#123; pm.expect(pm.response.responseTime).to.be.below(500);&#125;); 结果如下： Postman 测试脚本的官方文档： https://learning.postman.com/docs/writing-scripts/intro-to-scripts/","categories":[],"tags":[{"name":"Postman接口测试工具","slug":"Postman接口测试工具","permalink":"http://example.com/tags/Postman%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"}],"keywords":[]},{"title":"接口测试基础","slug":"接口测试基础","date":"2021-09-08T02:37:49.000Z","updated":"2021-09-08T06:37:36.357Z","comments":true,"path":"2021/09/08/接口测试基础/","link":"","permalink":"http://example.com/2021/09/08/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一、接口测试的概述1.接口定义 API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 2.接口测试定义 接口测试是对系统或组件之间的接口进行测试，主要是校验数据的交换，传递和控制管理过程，以及相互逻辑依赖关系。其中接口协议分为 HTTP,WebService,Dubbo,Thrift,Socket 等类型。 3.接口测试目的 接口测试实施在多系统的平台架构下，有着极为高效的成本收益比（当然，单元测试收益更高，但实施单元测试的 成本投入更大，技术要求更高）。 接口测试天生为高复杂性的平台带来高效的缺陷检测和质量监督能力，平台复杂，系统越庞大，接口测试的效果越 明显。 接口测试优势主要体现在如下三个方面： 1、节省了测试成本 根据数据模型推算，底层的一个程序 BUG 可能引发 UI 层的 8 个左右 BUG，而且底层的 BUG 更容易引起全网的死 机；接口测试能够提供系统复杂度上升情况下的低成本高效率的解决方案。 2、接口测试门槛相对较低 接口测试不同于单元测试，接口测试是站在用户的角度对系统接口进行全面高效持续的检测。 3、效益更高 将接口测试实现为自动化和持续集成，当系统复杂度和体积越大，接口测试的成本就越低，相对应的，效益产出就 越高。 4.接口测试流程 需求分析——用例设计——脚本开发——用例执行——结果分析 http协议相关基础理论 二、JSON数据格式1.简介 JSON（JavaScript Object Notation，即 JavaScript 对象表示法）是一种轻量级的数据交换格式。它独立于语言 和平台，JSON 解析器和 JSON 库支持不同的编程语言。JSON 具有自我描述性，很容易理解。目前大多数接口返 回的数据格式为 JSON,因此进行接口测试必须掌握 JSON。 2.JSON的语法特点 12341.数据在键/值对中2.数据由逗号隔开3.&#123;花括号&#125;保存对象4.[方括号]保存数组 JSON 数据的书写格式是：key:value 键值对。比如： 1&quot;name&quot;:&quot;张三&quot; 解释：name 是 key，张三 是 value JSON 值可以是： a. 数字（整数或浮点数） b. 字符串（在双引号中） c. 逻辑值（true 或 false） d. 数组（在方括号中） e. 对象（在花括号中） 案例代码： 12345678910111213/*1.json 的值是数字*/ &quot;age&quot;:18/*2.json 的值为字符串*/ &quot;name&quot;:&quot;Tom&quot; /*3.json 的值为逻辑值*/ &quot;result&quot;:true/*4.json 的值为数组*/ &quot;city&quot;:[&quot;长沙&quot;,&quot;上海&quot;,&quot;北京&quot;]/*5.json 的值为对象 JSON 对象在花括号中书写： 对象可以包含多个键/值对： * */&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125; 注意:在接口测试过程中，一般都是返回 JSON 对象类型。 比如在数组中含多个对象： 1234567&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;, &#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125; ]&#125; 在上面的例子中，对象 “employees” 是包含三个对象的数组。每个对象代表一条关于某人（有姓和名）的记录。 3.JSON数据解析 Python3 中可以使用 json模块来对 JSON 数据进行编解码，它包含了两个方法： 12json.dumps(): 将 python 数据转化为 Json 数据json.loads(): 将 json 数据类型转为 Python 数据类型 JSON 库官方文档 https://docs.python.org/3/library/json.htm 案例一：将PYTHON数据转化JSON数据 准备代码： 1234567891011import json #1 准备字典 data=&#123;&#x27;id&#x27;:1,&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;password&#x27;:&#x27;66666&#x27;&#125; #2 检测类型 --dict print(type(data))#3 通过 json.dumps()方法来转换 json_str=json.dumps(data) #4.检测类型为 str print(type(json_str))#5.输出的格式就是一个 json 格式 print(json_str) 输出效果： 案例二：将JSON数据转为PYTHON数据类型 1234567891011import json #1 准备 json 数据--字符串 json_str=&#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;zhangsan&quot;,&quot;password&quot;:&quot;66666&quot;&#125;&#x27; #2 把字符串转 dict data=json.loads(json_str) #3 字符串 print(type(json_str))#4.dictprint(type(data)) print(data) print(data[&#x27;id&#x27;]) print(data[&#x27;name&#x27;]) 运行结果： 4.JSON文件处理 案例一：使用PYTHON从JSON中读取数据 ​ 准备条件 ​ 1.JSON文件 ​ 2.PYTHON代码 ​ 代码： JASON代码： 1234567&#123;&quot;employees&quot;: [ &#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;, &#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; &#125;]&#125; PYTHON代码： 1234import json with open(&#x27;data.json&#x27;, &#x27;r&#x27;) as f: data = json.load(f)print(data) 代码路径截图：放同一个文件夹里面 案例二：使用PYTHON写入数据到JSON文件中 12345678import json #1.准备一个字符串 data=&#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;zhangsan&quot;,&quot;password&quot;:&quot;66666&quot;&#125;&#x27; #2.写入 json 文件 with open(&#x27;data.json&#x27;, &#x27;w&#x27;) as f: json.dump(data, f) #3.可以查看 json 文件或者读取出来 with open(&#x27;data.json&#x27;, &#x27;r&#x27;) as f: data = json.load(f) print(data) 在pycharm中： JASON代码： PYTHON代码： 代码路径截图：放同一个文件夹里面","categories":[],"tags":[{"name":"接口测试基础","slug":"接口测试基础","permalink":"http://example.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"keywords":[]},{"title":"案例整合","slug":"案例整合","date":"2021-09-06T03:41:27.000Z","updated":"2021-09-07T01:30:02.394Z","comments":true,"path":"2021/09/06/案例整合/","link":"","permalink":"http://example.com/2021/09/06/%E6%A1%88%E4%BE%8B%E6%95%B4%E5%90%88/","excerpt":"","text":"一、pageobject+unittest在前面我们都是基于线性模型来编写测试脚本，而且元素定位方式和属性值都是写死的。 1.场景案例前面我们所学，测试考研帮App登录场景，按照线性模型来构造出脚本如下： 考研帮登录测试场景脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from appium import webdriverimport yamlfrom selenium.common.exceptions import NoSuchElementExceptionimport loggingimport logging.configCON_LOG=&#x27;./log/log.conf&#x27;logging.config.fileConfig(CON_LOG)logging=logging.getLogger()stream=open(&#x27;./yaml/desired_caps.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(stream)desired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps)def check_updateBtn(): logging.info(&quot;check_updateBtn&quot;) try: element = driver.find_element_by_id(&#x27;android:id/button2&#x27;) except NoSuchElementException: logging.info(&#x27;update element is not found!&#x27;) else: element.click()def check_skipBtn(): logging.info(&quot;check_skipBtn&quot;) try: element = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;) except NoSuchElementException: logging.info(&#x27;skipBtn element is not found!&#x27;) else: element.click()check_updateBtn()check_skipBtn()logging.info(&#x27;start login...&#x27;)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_login_btn&#x27;).click()logging.info(&#x27;login finished&#x27;) 1）案例分析 上面的脚本看似都比较完善，有了log采集，参数配置、启动时页面元素自动检测。但是也存在一些不足之处： · 公共模块和业务模块混合在一起显得代码冗余等 · 测试场景单一（如果要实现如下测试场景该怎么办？） · 元素定位属性和代码混杂在一起 以上这些都是需要优化的地方。 测试场景 操作步骤 预期结果 多账号登录 不同的用户名密码来进行登录 能够正常登录 异常登录 用户名或者密码错误、或者为空进行登录， 登录失败，同时界面要给出相应的提示 注册 点击注册，然后进行注册信息填写 能够注册成功 2）重构优化思路 · 将一些公共的内容（如：check_updateBtn，check_skipBtn,capability）抽离出来。 · 元素定位方法和元素属性值与业务代码分离 · 登录功能模块封装为一个独立的模块 · 使用unittest进行用例综合管理 3）page object Page Object是Selenium自动化测试项目开发实践的最佳设计模式之一，通过对界面元素的封装减少冗余代码，同时在后期维护中，若元素定位发生变化，只需要调整页面元素封装的代码，提高测试用例的可维护性。 2.代码实现封装App启动配置信息 desired_caps.py 123456789101112131415161718192021222324252627282930313233343536373839import yamlimport logging.configfrom appium import webdriver#把app启动封装到一个类里面CON_LOG = &#x27;../log/log.conf&#x27;logging.config.fileConfig(CON_LOG)logging = logging.getLogger()def appium_desired(): stream = open(&#x27;../yaml/desired_caps.yaml&#x27;, &#x27;r&#x27;) data = yaml.load(stream) desired_caps=&#123;&#125; desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;] desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;] desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;] desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;] desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;] desired_caps[&#x27;unicodeKeyboard&#x27;]=data[&#x27;unicodeKeyboard&#x27;] desired_caps[&#x27;resetKeyboard&#x27;]=data[&#x27;resetKeyboard&#x27;] desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;] desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;] logging.info(&#x27;start run app...&#x27;) driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps) driver.implicitly_wait(8) return driverif __name__ == &#x27;__main__&#x27;: appium_desired() 记得在原来的yaml配置表desired_caps.yaml补充如下内容： 12unicodeKeyboard: True resetKeyboard: True 封装基类：BaseView.py 初始化——获取driver 写一个获取所有元素的函数 1234567#封装对应基类class BaseView(object): def __init__(self,driver): self.driver=driver def find_element(self,*loc): return self.driver.find_element(*loc) 封装通用公共类 common_fun.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from Base_View import *from desired_caps import *from selenium.common.exceptions import NoSuchElementExceptionimport loggingfrom selenium.webdriver.common.by import Byclass Common(BaseView): cancelBtn=(By.ID,&#x27;android:id/button2&#x27;) skipBtn=(By.ID,&#x27;com.tal.kaoyan:id/tv_skip&#x27;) def check_cancelBtn(self): logging.info(&#x27;==========check_cancelBtn=========&#x27;) try: cancelBtn = self.driver.find_element(*self.cancelBtn) except NoSuchElementException: logging.info(&#x27;no cancelBtn&#x27;) else: cancelBtn.click() def check_skipBtn(self): logging.info(&#x27;=========check skipBtn=============&#x27;) try: skipBtn = self.driver.find_element(*self.skipBtn) except NoSuchElementException: logging.info(&#x27;no skipBtn&#x27;) else: skipBtn.click()if __name__ == &#x27;__main__&#x27;: driver=appium_desired() com=Common(driver) com.check_cancelBtn() com.check_skipBtn()封装登录操作 loginView.pyimport loggingfrom common_fun import *from desired_caps import *from selenium.webdriver.common.by import Byclass LoginView(Common): username_type=(By.ID,&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;) password_type=(By.ID,&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;) loginBtn=(By.ID,&#x27;com.tal.kaoyan:id/login_login_btn&#x27;) def login_action(self,username,password): self.check_cancelBtn() self.check_skipBtn() logging.info(&#x27;===============login===============&#x27;) logging.info(&#x27;input username:%s&#x27;%username) self.driver.find_element(*self.username_type).send_keys(username) logging.info(&#x27;input password:%s&#x27;%password) self.driver.find_element(*self.password_type).send_keys(password) logging.info(&#x27;click loginBtn.&#x27;) self.driver.find_element(*self.loginBtn).click() logging.info(&#x27;login finished &#x27;)if __name__ == &#x27;__main__&#x27;: driver=appium_desired() l=LoginView(driver) l.login_action(&#x27;liubo10010&#x27;,&#x27;liubo10010&#x27;) 3.unittest 用例封装测试场景：使用如下账号进行分别登录测试 用户名 密码 hj18594962283 jxx.hxx21. fghjffdee 33321 1.封装用例启动、结束时的配置： myunit.py 123456789101112131415import unittestfrom appium_Test4.page_object.desired_caps import appium_desiredimport loggingfrom time import sleep#unitTest创建与销毁class StartEnd(unittest.TestCase): def setUp(self): logging.info(&#x27;=====setUp====&#x27;) self.driver=appium_desired() def tearDown(self): logging.info(&#x27;====tearDown====&#x27;) sleep(5) self.driver.close_app() 用例封装 test_login.py 12345678910111213141516171819202122from appium_Test4.unitTest.myunit import StartEndfrom appium_Test4.page_object.loginView import LoginViewimport unittestimport loggingclass TestLogin(StartEnd): def test_login_liubo10010(self): logging.info(&#x27;=========test_login_liubo10010============&#x27;) l=LoginView(self.driver) l.login_action(&#x27;liubo10010&#x27;,&#x27;liubo10010&#x27;) def test_login_error(self): logging.info(&#x27;=======test_login_error=========&#x27;) l=LoginView(self.driver) l.login_action(&#x27;666&#x27;,&#x27;222&#x27;)if __name__ == &#x27;__main__&#x27;: unittest.main() 项目代码结构： 二、自动化测试框架综合案例1.框架功能 业务功能的封装 测试用例封装 测试包管理 截图处理 断言处理 日志获取 测试报告生成 配置参数 2.测试案例测试环境 · Appium-desktop 1.5.0 · 考研帮App Android版3.1.0 · 夜神模拟器 Android 7.1.2 · Win 10 64位 覆盖用例 1.登录场景 用户名 密码 hj18594962283 jxx.hxx21. fghjffdee 33321 3.代码实现1）driver 配置封装 kyb_caps.yaml 配置表 1234567891011platformName: AndroidplatformVersion: 7.1.2deviceName: 127.0.0.1:62025appname: kaoyan3.1.0.apknoReset: FalseunicodeKeyboard: TrueresetKeyboard: TrueappPackage: com.tal.kaoyanappActivity: com.tal.kaoyan.ui.activity.SplashActivityip: 127.0.0.1port: 4723 desired_caps.py 1234567891011121314151617181920212223242526272829303132333435363738from appium import webdriverimport yamlimport loggingimport logging.configimport osCON_LOG=&#x27;../config/log.conf&#x27;logging.config.fileConfig(CON_LOG)logging=logging.getLogger()def appium_desired(): with open(&#x27;../config/kyb_caps.yaml&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as file: data=yaml.load(file) desired_caps=&#123;&#125; desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;] desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;] desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;] base_dir = os.path.dirname(os.path.dirname(__file__)) app_path = os.path.join(base_dir, &#x27;app&#x27;, data[&#x27;appname&#x27;]) desired_caps[&#x27;app&#x27;]=app_path desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;] desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;] desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;] desired_caps[&#x27;unicodeKeyboard&#x27;]=data[&#x27;unicodeKeyboard&#x27;] desired_caps[&#x27;resetKeyboard&#x27;]=data[&#x27;resetKeyboard&#x27;] logging.info(&#x27;start app...&#x27;) driver=webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;,desired_caps) driver.implicitly_wait(8) return driverif __name__ == &#x27;__main__&#x27;: appium_desired() 相对路径符号含义 “.”表示当前目录 “..” 表示当前目录的上一级目录。 “./”表示当前目录下的某个文件或文件夹，视后面跟着的名字而定 “../”表示当前目录上一级目录的文件或文件夹，视后面跟着的名字而定。 2）基类封装 baseView.py 123456789class BaseView(object): def __init__(self,driver): self.driver=driver def find_element(self,*loc): return self.driver.find_element(*loc) def find_elements(self,*loc): return self.driver.find_elements(*loc) 3）common公共模块封装 公共方法封装 : common_fun.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from baseView.baseView import BaseViewfrom common.desired_caps import appium_desiredfrom selenium.common.exceptions import NoSuchElementExceptionimport loggingfrom selenium.webdriver.common.by import Byimport time,osimport csvclass Common(BaseView): cancelBtn=(By.ID,&#x27;android:id/button2&#x27;) skipBtn=(By.ID,&#x27;com.tal.kaoyan:id/tv_skip&#x27;) wemedia_cacel=(By.ID,&#x27;com.tal.kaoyan:id/view_wemedia_cacel&#x27;) def check_cancelBtn(self): logging.info(&#x27;==========check_cancelBtn=========&#x27;) try: cancelBtn = self.driver.find_element(*self.cancelBtn) except NoSuchElementException: logging.info(&#x27;no cancelBtn&#x27;) else: cancelBtn.click() def check_skipBtn(self): logging.info(&#x27;=========check skipBtn=============&#x27;) try: skipBtn = self.driver.find_element(*self.skipBtn) except NoSuchElementException: logging.info(&#x27;no skipBtn&#x27;) else: skipBtn.click() def getTime(self): self.now=time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;) return self.now def getScreenShot(self,module): time=self.getTime() image_file=os.path.dirname(os.path.dirname(__file__))+&#x27;/screenshots/%s_%s.png&#x27; %(module,time) logging.info(&#x27;get %s screenshot&#x27; %module) self.driver.get_screenshot_as_file(image_file) def check_market_ad(self): logging.info(&#x27;====check_market_ad====&#x27;) try: element=self.driver.find_element(*self.wemedia_cacel) except NoSuchElementException: pass else: logging.info(&#x27;close market ad&#x27;) element.click() def get_csv_data(self,csv_file,line): logging.info(&#x27;=====get_csv_data======&#x27;) with open(csv_file,&#x27;r&#x27;,encoding=&#x27;utf-8-sig&#x27;) as file: reader=csv.reader(file) for index,row in enumerate(reader,1): if index==line: return rowif __name__ == &#x27;__main__&#x27;: driver = appium_desired() c=Common(driver) c.check_cancelBtn() # # c.check_skipBtn() # c.swipeLef() # c.swipeLef() # c.getScreenShot(&quot;startApp&quot;) 4）业务模块封装 1.登录页面业务逻辑模块 ioginView.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import loggingfrom common.common_fun import Common,NoSuchElementExceptionfrom common.desired_caps import appium_desiredfrom selenium.webdriver.common.by import Byclass LoginView(Common): username_type=(By.ID,&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;) password_type=(By.ID,&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;) loginBtn=(By.ID,&#x27;com.tal.kaoyan:id/login_login_btn&#x27;) tip_commit=(By.ID,&#x27;com.tal.kaoyan:id/tip_commit&#x27;) button_mysefl=(By.ID,&#x27;com.tal.kaoyan:id/mainactivity_button_mysefl&#x27;) username=(By.ID,&#x27;com.tal.kaoyan:id/activity_usercenter_username&#x27;) RightButton=(By.ID,&#x27;com.tal.kaoyan:id/myapptitle_RightButton_textview&#x27;) logoutBtn=(By.ID,&#x27;com.tal.kaoyan:id/setting_logout_text&#x27;) def login_action(self,username,password): self.check_cancelBtn() self.check_skipBtn() logging.info(&#x27;============login_action==============&#x27;) logging.info(&#x27;username is:%s&#x27; %username) self.driver.find_element(*self.username_type).send_keys(username) logging.info(&#x27;password is:%s&#x27;%password) self.driver.find_element(*self.password_type).send_keys(password) logging.info(&#x27;click loginBtn&#x27;) self.driver.find_element(*self.loginBtn).click() logging.info(&#x27;login finished!&#x27;) def check_account_alert(self): logging.info(&#x27;=====check_account_alert====&#x27;) try: element=self.driver.find_element(*self.tip_commit) except NoSuchElementException: pass else: logging.info(&#x27;close tip_commit&#x27;) element.click() def check_loginStatus(self): logging.info(&#x27;====check_loginStatus======&#x27;) self.check_market_ad() self.check_account_alert() try: self.driver.find_element(*self.button_mysefl).click() self.driver.find_element(*self.username) except NoSuchElementException: logging.error(&#x27;login Fail!&#x27;) self.getScreenShot(&#x27;login fail&#x27;) return False else: logging.info(&#x27;login success!&#x27;) self.logout_action() return True def logout_action(self): logging.info(&#x27;=====logout_action======&#x27;) self.driver.find_element(*self.RightButton).click() self.driver.find_element(*self.logoutBtn).click() self.driver.find_element(*self.tip_commit).click()if __name__ == &#x27;__main__&#x27;: driver=appium_desired() l=LoginView(driver) l.login_action(&#x27;liubo10010&#x27;,&#x27;liubo10010&#x27;) l.check_loginStatus() 2.data 数据封装 使用背景 在实际项目过程中，我们的数据可能是存储在一个数据文件中，如txt,excel、csv文件类型。我们可以封装一些方法来读取文件中的数据来实现数据驱动。 案例： 将测试账号存储在account.csv文件，内容如下： 用户名 密码 hj18594962283 jxx.hxx21. fghjffdee 33321 enumerate()简介enumerate()是python的内置函数 · enumerate在字典上是枚举、列举的意思 · 对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值 · enumerate多用于在for循环中得到计数。 enumerate()使用如果对一个列表，既要遍历索引又要遍历元素时，首先可以这样写： 123456789list = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;,&quot;数据&quot;] for i in range(len(list)): print(i,list[i])&gt;&gt;&gt;0 这1 是2 一个3 测试4 数据 上述方法有些累赘，利用enumerate()会更加直接和优美： 12345678list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;,&quot;数据&quot;] for index, item in enumerate(list1): print(index,item)&gt;&gt;&gt;0 这1 是2 一个3 测试 数据读取方法封装123456789101112import csv def get_csv_data(csv_file,line): with open(csv_file, &#x27;r&#x27;, encoding=&#x27;utf-8-sig&#x27;) as file: reader=csv.reader(file) for index, row in enumerate(reader,1): if index == line: return row csv_file=&#x27;../data/account.csv&#x27; data=get_csv_data(csv_file,3) print(data) utf-8与utf-8-sig两种编码格式的区别UTF-8以字节为编码单元，它的字节顺序在所有系统中都是一样的，没有字节序的问题，也因此它实际上并不需要BOM(“ByteOrder Mark”)。但是UTF-8 with BOM即utf-8-sig需要提供BOM。 3.config文件配置 日志文件配置 log.config 1234567891011121314151617181920212223242526272829303132333435[loggers]keys=root,infoLogger[logger_root]level=DEBUGhandlers=consoleHandler,fileHandler[logger_infoLogger]handlers=consoleHandler,fileHandlerqualname=infoLoggerpropagate=0[handlers]keys=consoleHandler,fileHandler[handler_consoleHandler]class=StreamHandlerlevel=INFOformatter=form02args=(sys.stderr,)[handler_fileHandler]class=FileHandlerlevel=INFOformatter=form01args=(&#x27;../logs/runlog.log&#x27;, &#x27;a&#x27;)[formatters]keys=form01,form02[formatter_form01]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s[formatter_form02]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s 4. 测试用例封装 测试用例执行开始结束操作封装 myunit.py 1234567891011121314import unittestfrom common.desired_caps import appium_desiredimport loggingfrom time import sleepclass StartEnd(unittest.TestCase): def setUp(self): logging.info(&#x27;=====setUp====&#x27;) self.driver=appium_desired() def tearDown(self): logging.info(&#x27;====tearDown====&#x27;) sleep(5) self.driver.close_app() 2.登录用例：test_login.py 12345678910111213141516171819202122232425262728from common.myunit import StartEndfrom businessView.loginView import LoginViewimport unittestimport loggingclass TestLogin(StartEnd): csv_file=&#x27;../data/account.csv&#x27; def test_login_liubo10010(self): logging.info(&#x27;======test_login_liubo10010=====&#x27;) l=LoginView(self.driver) data=l.get_csv_data(self.csv_file,2) l.login_action(data[0],data[1]) self.assertTrue(l.check_loginStatus()) @unittest.skip(&#x27;test_login_error&#x27;) def test_login_error(self): logging.info(&#x27;======test_login_error=====&#x27;) l = LoginView(self.driver) data = l.get_csv_data(self.csv_file, 3) l.login_action(data[0], data[1]) self.assertTrue(l.check_loginStatus(),msg=&#x27;login fail!&#x27;)if __name__ == &#x27;__main__&#x27;: unittest.main() 5. 执行测试用例&amp;报告生成run.py 12345678910111213141516171819import unittestfrom BSTestRunner import BSTestRunnerimport time,loggingimport syspath=&#x27;D:\\\\kyb_testProject\\\\&#x27;sys.path.append(path)test_dir=&#x27;../test_case&#x27;report_dir=&#x27;../reports&#x27;discover=unittest.defaultTestLoader.discover(test_dir,pattern=&#x27;test_login.py&#x27;)now=time.strftime(&#x27;%Y-%m-%d %H_%M_%S&#x27;)report_name=report_dir+&#x27;/&#x27;+now+&#x27; test_report.html&#x27;with open(report_name,&#x27;wb&#x27;) as f: runner=BSTestRunner(stream=f,title=&#x27;Kyb Test Report&#x27;,description=&#x27;kyb Android app test report&#x27;) logging.info(&#x27;start run test case...&#x27;) runner.run(discover)","categories":[],"tags":[{"name":"pageobject+unittest 自动化测试框架综合","slug":"pageobject-unittest-自动化测试框架综合","permalink":"http://example.com/tags/pageobject-unittest-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%BB%BC%E5%90%88/"}],"keywords":[]},{"title":"python","slug":"python","date":"2021-09-04T10:13:15.000Z","updated":"2021-09-07T08:57:32.802Z","comments":true,"path":"2021/09/04/python/","link":"","permalink":"http://example.com/2021/09/04/python/","excerpt":"","text":"一、Python 的介绍python 定义及其作用 def: 是一种面向对象、解释型计算机程序设计语言 特点： 代码量小 维护成本低 编程效率高 作用： Python 最常用的应该就是写爬虫了吧，比较简单的应用就是爬取 web 网站的资源（图片，文字、链接等） 有些资深股民都是用 Python 抓取财经网站数据、并进行处理，然后输出可视化图表来帮助做决策。 人工智能机器学习方面应用，python 有很多库很方便做人工智能，比如 numpy, scipy 做数值计算的，sklearn 做机器学习的，pybrain 做神经网络的。 软件测试领域：自动化测试（Web 端(python+selenium)和移动客户端 python+appium） 二、python解释器的安装主要针对python3 进行学习，是对python2 的优化 1.下载和安装 python下载 python安装 安装注意： 在第一步的时候，一定要勾选上： Add python to PATH 其余都是下一步 直接安装下载的安装包即可（建议安装在 C 盘根目录） 2.验证安装是否成功 \\1. 进入 cmd 窗口 \\2. 输入 python \\3. 显示以下界面，表示 python 安装成功 1234C:\\Windows\\System32&gt;pythonPython 3.6.6 (v3.6.6:4cf1f54eb7, Jun 27 2018, 03:37:03) [MSC v.1900 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 三、python的输入和输出不要直接用电脑自带的记事本写代码，因为会造成中文乱码！！！ 推荐下载一个 nodepad++、或者 editplus 这类高级记事本来写 输出：Python 没有过分强调语句结尾的“;” ​ 可以写或者不写 输入：print()函数 输出字符串拼接直接使用逗号隔开 录入的类型为字符串类型 四、python的数据类型与运算符1. Python几个常见的数据类型 Python 不会像 JAVA 一样，刻意去强调数据类型 字符串——str 整数——int 浮点数——float 格式： num=13 解释： 变量 num 就是一个整数类型 2. Python 数据类型的检测 Python 的检测使用 type 函数 3.python 的运算符 python 常见的运算符 1.算术运算符：+、-、*、/ 、% 2.逻辑运算符：and 、or、not 3.赋值运算符：+=、-=、*=、/=、%=、**=(幂赋值) 4.比较运算符 &gt;= &lt;= != == 五、Python 的容器一：列表、元组1.列表list： 列表（list）可以存储多个不同类型的数据 列表可以通过下标(从 0 开始)来访问 列表的长度不是固定的 列表的功能： 1）使用 len()函数可以获得 list 的个数 2）使用 append()函数往列表里面追加数据 2.元组tuple： 元祖也是一个容器，可以用来存储数据，不过区别在于： 元祖的长度一旦声明不可以更改、元祖的存储值用的小括号 六、Pycharm工具的使用1.介绍 PyCharm 是一种 Python IDE，带有一整套可以帮助用户在使用 Python 语言开发时提高其效率的工具，比如调试、语法高亮、Project 管理、代码跳转、智能提示、自动完成、单 元测试、版本控制。此外，该 IDE 提供了一些高级功能，以用于支持 Django 框架下的专业 Web 开发。 2.下载、安装 pycharm下载、安装步骤链接 3.使用注意： 如何创建项目： 选择上方的”file” 然后选择”new project” 然后输入项目名和选择代码路径 设置字体： 选择上方的”file” 选择”setting” 输入”font”，设置 size 代码写好了，怎么运行？ 在代码编辑区域-右键 选择”Run” 七、Python 的选择结构1.第一种：1个条件，1个结果 if… 2.第二种：1个条件，2个结果 if…else… 3.第三种：多个条件，多个结果 if…elseif…else 4.if 里面套if 八、Python的循环结构1.什么是循环 分析：输出 100 句 hello,意味着要写 100 个 print 语句，但是我们会发现这是一件重复的 事情——一直在输出 hello。遇到这样重复的问题，我们可以通过循环来写一句 print(“hello”) 实现 100 句输出。 列如下面的代码： 1234n=1; while n&lt;=100: print(n,&quot;Hello&quot;) n+=1 2.循环的四要素 要了解循环，必须了解循环的几要素： 循环从哪里开始：循环的初始化变量 循环到哪里终止：循环的判断条件 循环一直在做什么：循环体语句 循环一次，计数记录更新：控制循环语句 列如：输出 100 句 hello 循环的初始化变量： n=1 循环的判断条件： while n&lt;=100: 循环体语句： print(“hello”) 控制循环语句： n+=1 3.while循环： 1循环的初始化变量： While 循环的判断条件： 循环体语句 控制循环语句 案例：循环输出 1-50 能被 2 整除并且能被 3 整除的数字： 1234n=1;while n&lt;=50: if n%2==0: print(n) 4.for循环： Python 的 for 循环可以用 rang()函数来确定数的范围： 列如：循环 1–50 12for x in range(1,51): print(x) 解释： range(1,51):表示这个数字从 1–50 x 和 in 表示从 range 函数取一个赋值给 x，然后打印 x 案例：求 1–100 的偶数和 12345sum=0 for x in range(1,51): if x%2 ==0: sum+=x print(sum) 5.循环的练习 打印一个直角三角形： 12345sum=0 for x in range(1,4): for y in range(0,x): print(&quot;*&quot;,end=&quot;&quot;) print() 解释：end=””组织它换行 打印一个倒菱形： 123456for i in range(4): for k in range(i, 7 - i): print(&quot; * &quot;, end=&quot;&quot;) print() for j in range(0, i + 1): print(&quot; &quot;, end=&quot;&quot;) 九、python的容器二：字典字典是另一种可变容器模型，且可存储任意类型对象。 字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号(**{})**中 ,格式如下所示： 1dict = &#123;&#x27;Alice&#x27;: &#x27;2341&#x27;, &#x27;Beth&#x27;: &#x27;9102&#x27;, &#x27;Cecil&#x27;: &#x27;3258&#x27;&#125; 1.访问字典里的值 把相应的键放入熟悉的方括号，通过访问 key 来找 value.如下实例: 123dict = &#123;&#x27;Name&#x27;: &#x27;W3CSchool&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;:&#x27;First&#x27;&#125;print (&quot;dict[&#x27;Name&#x27;]: &quot;, dict[&#x27;Name&#x27;])print (&quot;dict[&#x27;Age&#x27;]) dict[&#x27;Age&#x27;]) 2.修改字典 向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例: 1234dict = &#123;&#x27;Name&#x27;: &#x27;W3CSchool&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125; dict[&#x27;Age&#x27;] = 8; # 更新 Age dict[&#x27;School&#x27;] = &quot;python 教程&quot; # 添加信息 print (&quot;dict[&#x27;Age&#x27;]: &quot;, dict[&#x27;Age&#x27;])print (&quot;dict[&#x27;School&#x27;]: &quot;, dict[&#x27;School&#x27;]) 3.删除字典元素 能删单一的元素也能清空字典，清空只需一项操作。 显示删除一个字典用 del 命令，如下实例： 123456dict = &#123;&#x27;Name&#x27;: &#x27;W3CSchool&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;del dict[&#x27;Name&#x27;] # 删除键 &#x27;Name&#x27; dict.clear() # 删除字典del dict # 删除字典 print (&quot;dict[&#x27;Age&#x27;]: &quot;, dict[&#x27;Age&#x27;])print (&quot;dict[&#x27;School&#x27;]: &quot;, dict[&#x27;School&#x27;]) 4.字典键（key）的特性 1.不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住 12dict = &#123;&#x27;Name&#x27;: &#x27;zhangsan&#x27;, &#x27;Age&#x27;: 7, &#x27;Name&#x27;: &#x27;小菜鸟&#x27;&#125;print (&quot;dict[&#x27;Name&#x27;]: &quot;, dict[&#x27;Name&#x27;]) 5.字典内置函数&amp;方法 序号 函数及描述 实例 输出结果 1 len(dict) 计算字典元素个 数，即键的总数。 &gt;&gt;&gt; dict ={‘Name:’zhangsan’,’Age’:’7’,’Class’:’first’} &gt;&gt;&gt; len(dict) 3 2 str(dict)输出字典以可打印的字符串表示。 &gt;&gt;&gt; dict ={‘Name:’zhangsan’,’Age’:’7’,’Class’:’first’} &gt;&gt;&gt; str(dict) “{‘Name’: ‘zhangsan’, ‘Class’: ‘First’, ‘Age’: 7}” 3 type(variable)返回输入的变量类型，如果变量是字典就返回字典类型。 &gt;&gt;&gt; dict ={‘Name:’zhangsan’,’Age’:’7’,’Class’:’first’} &gt;&gt;&gt; type(dict) &lt;class ‘dict’&gt; 十、Python 的迭代器与生成器1.迭代器 迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。。 迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 **next()**。 字符串，列表或元组对象都可用于创建迭代器： 12345678#创建一个 list list=[1,2,3,4] #创建迭代器对象 it=iter(list) #开始迭代第 1 个元素 1print(next(it)) #开始迭代第 2 个元素 2print(next(it)) 迭代器对象可以使用常规 for 语句进行遍历： 1234list=[1,2,3,4] it = iter(list) # 创建迭代器对象 for x in it: print (x, end=&quot; &quot;) 也可以使用 next() 函数： 1234567list=[1,2,3,4] it = iter(list) # 创建迭代器对象while True: try: print (next(it)) except StopIteration: sys.exit() 解释： while True:这是一个死循环 try…except StopIteration:捕捉异常 2.生成器 在 Python 中，使用了 yield 的函数被称为生成器（generator）。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 在调用生成器运行的过程中，每次遇到 yield时函数会暂停并保存当前所有的 运行信息，返回 yield 的值。并在下一次执行next()方法时从当前位置继续运行。 以下实例使用 yield 实现斐波那契数列： 1234567891011121314import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1 f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=&quot; &quot;) except StopIteration: sys.exit() 十一、python的内置函数1.取绝对值 abs(x) 求绝对值 1、参数可以是整型，也可以是复数 2、若参数是复数，则返回复数的模 2.数据类型转换函数 float([x]) 将一个字符串或数转换为浮点数。如果无参数将返回 0.0 int([x[, base]]) 将一个字符转换为 int 类型，base 表示进制 long([x[, base]]) 将一个字符转换为 long 类型 完整参考 十二、Python 的自定义函数函数能提高应用的模块性，和代码的重复利用率。Python 提供了许多内建函数，比如print()等。也可以创建用户自定义函数。 1.函数的定义 函数定义的简单规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()，任何传入 参数和自变量必须放在圆括号中间 函数内容以冒号起始，并且缩进 若有返回值，Return[expression] 结束函数；不带 return 表达式相当于返回 None 函数通常使用三个单引号 ‘’’…’’’ 来注释说明函数；函数体内容不可为空，可用 pass 来表示空语句；以下几个为简单的函数示例： 1234567891011&#x27;&#x27;&#x27; some basic functions &#x27;&#x27;&#x27;def func1(): # 函数无传入参数 print(&quot;func1&quot;) # 无 return 值 func1() # 函数调用 def func2(): return(&quot;func2&quot;) # return 字符串 &quot;func2&quot; print(func2())def func3(a,b): # 需传两个参数 print(&quot;a+b = %d&quot; %(a+b)) # print 表达式，无return func3(3,4) def func4(a,b): # 需传两个参数 return (a+b) # return a+b 的值 print(func4(4,3)) 2.函数的调用 定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。 这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python 提示符执行。 上面的例子中 func1() 就是无参数函数的调用； func3(3,4) 为有参数函数的调用 十三、Python的面向对象：类与对象1.面向对象的关键因素 类(class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。 数据成员： 类的不同属性数据。 对象： 对象是类的实例 方法： 类中定义的函数，实现相关的功能。 2.面向对象编程 简称 OOP（Object Oriented Programming），是一种程序设计思想。OOP 把对象 作为程序的基本单元，一个对象包含了数据和操作数据的函数（方法）。 面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class 是一种抽象概念，比如我们定义的 Student 类，是指学生这个概念，而实例（Instance）则是一个个体的 Student 对象。 Python 是一门面向对象的语言，在 Python 中创建一个类和对象是很容易的 3.定义类 1class Student(object): 类体 Class 是类的定义的关键词，class 后面紧接着是类名，即 Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的。通常如果没有明确的继承类，就使用 object 类，括号内一般为空默认就是继承 Obejct 类。这是所有类最终都会继承的类，也就是基类。 4.属性初始化 由于类可以起到模板的作用，因此，可以在创建实例对象的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，如：在创建 Student 实例的时候，就把 name，city 等属性绑上去： 12345class Student(): def __init__(self,name,city): self.name=name self.city=city print(&quot;My name is %s and come from %s&quot; % (name, city)) __init__方法的第一个参数永远是 self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到 self，因为 self 就指向创建的实例本身。有了__init__方法， 在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但 self 不需要传，Python 解释器自己会把实例变量传进去。 5.定义方法 类的方法除了第一个参数是 self 外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用。 12345class Student(): def __init__(self,name,city): self.name=name self.city=city print(&quot;My name is %s and come from %s&quot; % (name, city)) def talk(self): print(&quot;Hello&quot;) 6.生成实例对象 1234stu1=Student(&#x27;Jack&#x27;,&#x27;Beijing&#x27;)stu1.talk() stu2=Student(&#x27;Harry&#x27;,&#x27;Shanghai&#x27;)stu2.talk() 十四、python 的模块应用1.为何要使用模块？ 随着项目功能和需求增多，代码量也会增大，把全部代码放在一个文件会显得冗余，因此需要使用模块进行分区管理。 2.python 的模块是什么？ Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和 Python 语句。 3.使用模块的好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。如：随机数模块，时间模块。 4.import语句 导入时间模块显示当前系统时间 123#模块 显示当前时间 import time print(time.ctime())#调用获取当前时间的方法 导入随机数模块显示随机整数 123import randomnum=random.randint()print(num) 5.from…import 语句 Python 的from 语句让你从模块中导入一个指定的部分到当前命名空间中。 12345from time import sleepfrom Student import Student stu1=Student(&#x27;jack&#x27;,&#x27;Beijing&#x27;) stu1.talk() stu2=Student(&#x27;Harry&#x27;,&#x27;Shanghai&#x27;) stu2.talk() 6.跨目录调用模块 案例：调用 School 目录下的 Student 模块 1234from School.Student import Student stu1=Student(&#x27;jack&#x27;,&#x27;Beijing&#x27;)stu1.talk() stu2=Student(&#x27;Harry&#x27;,&#x27;Shanghai&#x27;)stu2.talk() 7.import 搜索路径 当你导入一个模块，Python 解析器对模块位置的搜索顺序是： 1、当前目录 2、如果不在当前目录，Python 则搜索 PYTHONPATH 下的每个目录。 3、如果都找不到，Python 会察看安装默认路径。 十五、python的异常1.什么是异常？ 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。 一般情况 下，在 Python 无法正常处理程序时就会发生一个异常。 异常是 Python 对象，表示一个 错误。 当 Python 脚本发生异常时我们需要捕获处理它，否则程序会终止执行。 2.常见的异常类型？ 异常名称 描述 FileNotFoundError 找不到指定文件的异常 NameError 未声明/初始化对象 (没有属性) BaseException 所有异常的基类 3.异常的处理语句使用？ try…except… try…except…finally raise FileNotFoundError 1234try: fileName=input(&quot;Please input fileName:&quot;) open(&quot;%s.txt&quot; %fileName) except FileNotFoundError: print(&quot;%s file not found &quot; %fileName) NameError 1234try: print(stu) except NameError: print(&quot;stu not define !&quot;) BaseException 1234try: print(stu) except BaseException:print(&quot;stu not define !&quot;) try…except…as… 12345try: #stu=&#x27;Jack&#x27; print(stu) except BaseException as msg: print(msg) try… except… else 使用 1234567try: stu=&#x27;Jack&#x27; print(stu) except BaseException as msg: print(msg) else: print(&quot;stu is defined！&quot;) try..except…finally 输出 1234567try: #stu=&#x27;Jack&#x27; print(stu) except BaseException as msg: print(msg) finally: print(&quot;The end !&quot;) raise抛出异常 前面 try 语句是执行过程中捕获代码块的异常，而 raise 是通过事先定义一个条件，一 旦符合异常条件就抛出异常。 12345678def division(x,y) if y==0: raise ZeroDivisionError(&quot;Zero is not allow!&quot;) return x/y try: division(8,0) except BaseException as msg: print(msg) 注意：raise 只能用于 Python 标准异常类！ 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达 EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于 Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告 十六、Python 的文件处理1.打开文件 使用 Python 内置的方法 open（）可以打开文件 1file object = open(file_name [, access_mode][,buffering]) file_name：file_name 变量是一个包含了你要访问的文件名称的字符串值。 access_mode：access_mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 buffering:如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1,访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 1f=open(&#x27;stu_info.txt&#x27;,&#x27;r&#x27;) f=open(&#x27;E:\\\\test\\\\stu_info.txt&#x27;,&#x27;r&#x27;) 常用文件打开模式 模式 描述 r 以只读方式打开文件。 rb 以二进制格式打开一个文件用于只读。 w 打开一个文件只用于写入。 a 打开一个文件用于追加。新的内容将会被写入到已有内容之后。如果该文件 2.文件的读取 123line=f.read() line1=f.readline() line2=f.readlines() read() 每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。 readline() 每次只读取一行 readlines()一次性读取文件所有行 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理。 3.关闭文件 1f.close（） 读取 txt 文件 案例：读取 stu_info.txt 文件内容，并将所有文件中学生名称显示出来 12345f=open(&#x27;stu_info.txt&#x27;,&#x27;r&#x27;)lines=f.readlines()print(lines) for line in lines: print(line.split(&#x27;,&#x27;)[0]) split()方法语法： 1str.split(str=&quot;&quot;, num=string.count(str)). 参数 str – 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。 num – 分割次数 4. 读写 csv 文件 csv 即为逗号分隔值（Comma-Separated Values，CSV），有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。 csv 文件读取 案例：读取 Stu_info.csv 文件里所有学生信息。 123import csv csv_file=csv.reader(open(&#x27;Stu_info.csv&#x27;,&#x27;r&#x27;)) for stu in csv_file: print(stu) csv 文件写入 对 Stu_info.csv 文件追加写入两个学生信息 1234stu=[&#x27;Marry&#x27;,28,&#x27;Changsha&#x27;] stu1=[&#x27;Rom&#x27;,23,&#x27;Chengdu&#x27;] out=open(&#x27;Stu_info.csv&#x27;,&#x27;a&#x27;,newline=&#x27;&#x27;) csv_write=csv.writer(out,dialect=&#x27;excel&#x27;) csv_write.writerow(stu)csv_write.writerow(stu1)print(&quot;Write File Over!&quot;) 十七、python的xml的处理1. 什么是 xml 文件？ xml 即可扩展标记语言，它可以用来标记数据、定义数据类型，是一种允许用户对自己 的标记语言进行定义的源语言。 从结构上，很像 HTML 超文本标记语言。但他们被设计的目的是不同的，具体如下： XML 被设计用来传输和存储数据。 HTML 被设计用来显示数据。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;note&gt; &lt;to id=&#x27;001&#x27;&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 2. Xml 的特征？ 它是有标签对组成， 标签可以有属性： 标签对可以嵌入数据：abc 标签可以嵌入子标签（具有层级关系） 3. Xml 的文件结构 XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。 第一行是 XML 声明。它定义 XML 的版本 (1.0) 和所使用的编码 是根元素,也称为根节点。 是子元素（子节点） XML 文档必须包含根元素。该元素是所有其他元素的父元素 4. DOM 的文档对象模型 文档对象模型（Document Object Model，简称 DOM），DOM 就是针对 HTML 和 XML 提供的一个 API。什么意思？就是说为了能以编程的方法操作这个 HTML 的内容（比 如添加某些元素、修改元素的内容、删除某些元素），我们把这个 HTML 或 xml 看做一个测试系列课程——新睿教学部刘波 对象树（DOM 树），它本身和里面的所有东西比如 这些标签都看做一个 对象，每个对象都叫做一个节点（node）。 5. DOM 有什么用？ 就是为了操作 HTML 或 xml 中的元素，比如说我们要通过 JS 把这个网页的标题改了，直接这样就可以了： 1document.title = &#x27;baidu&#x27;; 6. 创建 XML 文件 创建一个 xml 文件 Class_info.xml 用来存储班级学生（姓名，年龄，城市），老师（姓名， 年龄，城市）、教务账号（学生和老师的账号，密码）等信息。 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;Class&gt; &lt;student&gt; &lt;name &gt;Jack&lt;/name&gt; &lt;age&gt;28&lt;/age&gt; &lt;city&gt;Beijing&lt;/city&gt; &lt;/student&gt; &lt;student&gt; &lt;name &gt;Bob&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;city&gt;Shanghai&lt;/city&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;Harry&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;city&gt;ShenZhen&lt;/city&gt; &lt;/student&gt; &lt;teacher&gt; &lt;name&gt;Marry&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;city&gt;Changsha&lt;/city&gt; &lt;/teacher&gt; &lt;account&gt; &lt;login username=&quot;student&quot; password=&quot;123456&quot;/&gt; &lt;login username=&quot;teacher&quot; password=&quot;888888&quot;/&gt; &lt;/account&gt;&lt;/Class&gt; 7.Xml 文件的读取案例 1) xml 的节点 xml 文件节点一般包含 3 类： 元素节点 文本节点 属性节点 每个节点都拥有包含着关于节点某些信息的属性。这些属性是： nodeName（节点名称） nodeValue（节点值） nodeType（节点类型） 2) 读取元素的节点 案例：查看 Class_info.xml 文件里 Class 节点的属性（结点名称，节点的值、节点类型） 123456789from xml.dom import minidom #加载 xml 文件 dom=minidom.parse(&#x27;Class_info.xml&#x27;) #加载 dom 对象元素 root=dom.documentElement #打印节点信息 print(root.nodeName)print(root.nodeValue) print(root.nodeType) nodeName 节点名称 nodeValue 返回文本节点的值 nodeType 属性返回以数字值返回指定节点的节点类型。 如果节点是元素节点，则nodeType 属性将返回 1。 如果节点是属性节点，则nodeType 属性将返回 2。 3) 读取文本节点的值 案例：分别打印出 Class_info.xml 里的学生和老师的详细信息（姓名，年龄、城市） 1234567891011from xml.dom import minidom #获取标签对的值 #打开文件dom=minidom.parse(&#x27;Class_info.xml&#x27;) #获取文档对象元素 root=dom.documentElement #根据标签名称获取标签对象names=root.getElementsByTagName(&#x27;name&#x27;) ages=root.getElementsByTagName(&#x27;age&#x27;) citys=root.getElementsByTagName(&#x27;city&#x27;) #分别打印显示 xml 文档标签对里面的内容for i in range(4): print(names[i].firstChild.data) print(ages[i].firstChild.data) print(citys[i].firstChild.data) 4) 读取属性节点的值 案例：分别读取打印老师和学生的账号密码 123from xml.dom import minidom dom=minidom.parse(&#x27;Class_info.xml&#x27;) root=dom.documentElement logins=root.getElementsByTagName(&#x27;login&#x27;)#获取 login 标签的 username 属性 for i in range(2): username=logins[i].getAttribute(&#x27;username&#x27;) print(username) password=logins[i].getAttribute(&#x27;password&#x27;) print(password) 5) 读取子节点信息 读取子节点相关属性 nodeName（节点名称） nodeValue（节点值） nodeType（节点类型） 12345678from xml.dom import minidom #加载 xml 文件 dom=minidom.parse(&#x27;Class_info.xml&#x27;)root=dom.documentElement tags=root.getElementsByTagName(&#x27;student&#x27;) print(tags[0].nodeName) print(tags[0].tagName) print(tags[0].nodeType)print(tags[0].nodeValue) 十八、Python 的单线程与多线程 1) 什么是进程？ 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 2) 什么是线程？ 有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。 线程是进程中的一个实体，是被系统独立调度和分派的基本单位，一个进程可以包含多个线程， 但是线程不能包含多个进程。线程自己不拥有系统资源 ，在单个程序中同时运行多个线程完成不同的工作，称为多线程。 3) 线程与进程的区别？ 线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。 提示： LoadRunner 和 Jmeter 等性能测试工具也利用了多线程和多进程来构造多个并发用户来执行性能测试。 1线程与进程图文解释 http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 4) 单线程 单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。 案例：一个学生先用2 秒说话，接着用 3 秒写字，最后结束。 1234567891011from time import ctime,sleep def talk(): print(&quot;Start talk %r&quot; %ctime()) sleep(2)def write(): print(&quot;Start Write! %r&quot; %ctime()) sleep(3) if __name__==&quot;__main__&quot;: talk() write() print(&quot;All end %r&quot; %ctime()) if name==”main“: 表示如果当前模块是被直接运行的，则该语句之后代码块被运 行，如果模块是被导入的，则代码块不被运行 5) 多线程： 多线程（MultiThreading）是指从软件或者硬件上实现多个线程并发执行的技术。 案例：让学生同时进行说和写操作 1234567891011121314151617181920from time import ctime,sleep import threadingdef talk(content,loop): for i in range(loop): print(&quot;Start Talk %s %s&quot; %(content,ctime())) sleep(3)def write(content,loop): for i in range(loop): print(&quot;Start Write %s %s&quot; %(content,ctime())) sleep(5) threads=[] t1=threading.Thread(target=talk,args=(&#x27;Speak: Hello&#x27;,2)) threads.append(t1) t2=threading.Thread(target=write,args=(&#x27;Write: Life is Short You need Python!&#x27;,2)) threads.append(t2) if __name__==&#x27;__main__&#x27;: for t in threads: t.start() for t in threads: t.join() print(&quot;All the End %r&quot; %ctime()) 6) 多进程 与多线程相比，多进程就是 import multiprocessing 然后替换相应的方法 multiprocessing.Process（） 12345678910111213141516from time import sleep,ctimeimport multiprocessing def talk(content,loop): for i in range(loop): print(&quot;Talk: %s %s&quot; %(content,ctime())) sleep(2) def write(content,loop): for i in range(loop): print(&quot;Write: %s %s&quot;%(content,ctime())) sleep(3)process=[] p1=multiprocessing.Process(target=talk,args=(&#x27;hello&#x27;,2)) process.append(p1) p2=multiprocessing.Process(target=write,args=(&#x27;Python&#x27;,2)) process.append(p2) if __name__==&#x27;__main__&#x27;: for p in process: p.start() for p in process: p.join() print(&quot;All process is Run %s&quot; %ctime()) 十九、Python 的爬虫案例 从网页页面上批量下载 jpg 格式图片，并按照数字递增命名保存到指定的文件夹。 Web 地址：http://p.weather.com.cn/2017/06/2720826.shtml#p=1 12345678910111213141516171819202122232425import urllib import urllib.requestimport re #正则表达式 #解析页面 def load_page(url): request=urllib.request.Request(url) #发送网络请求 response=urllib.request.urlopen(request)#根据 url 打开页面 data=response.read() #获取页面响应数据 return data #下载图片 def get_image(html): regx=r&#x27;http://[\\S]*jpg&#x27; #定义正则表达式，匹配页面图片元素 pattern=re.compile(regx) #编译表达式构造匹配模式 get_image=re.findall(pattern,repr(html)) #进行正则匹配并返回结果 num = 1 #遍历获取的图片 for img in get_image: image=load_page(img) #将图片存入到指定文件夹 with open(&#x27;E:\\\\Photo\\\\%s.jpg&#x27; %num,&#x27;wb&#x27;) as fb: fb.write(image) print(&quot;正在下载第 %s 张图片&quot; %num) num = num + 1 print(&quot;下载完成！&quot;) url=&#x27;http://p.weather.com.cn/2017/06/2720826.shtml#p=1&#x27;html=load_page(url)get_image(html) 正则表达式相关知识： https://deerchao.net/tutorials/regex/regex.htm","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}],"keywords":[]},{"title":"Appium的数据配置与日志收集","slug":"Appium的数据配置与日志收集","date":"2021-09-03T10:18:34.000Z","updated":"2021-09-03T11:18:28.787Z","comments":true,"path":"2021/09/03/Appium的数据配置与日志收集/","link":"","permalink":"http://example.com/2021/09/03/Appium%E7%9A%84%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/","excerpt":"","text":"一、yaml概述1） yaml 简介 YAML 是一种简洁的非标记语言。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。 YAML特别适合在脚本语言中使用，列一下现有的语言实现：Ruby，Java，Perl，Python，PHP，JavaScript等。 YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。比如同一段数据Josn和Yaml的表示分别如下： jason 1&#123; name: &#x27;Tom Smith&#x27;,age: 37,spouse: &#123; name: &#x27;Jane Smith&#x27;, age: 25 &#125;,children: [ &#123; name: &#x27;Jimmy Smith&#x27;, age: 15 &#125;,&#123; name: &#x27;Jenny Smith&#x27;, age: 12 &#125; ] &#125; yaml 12345678910name: Tom Smithage: 37spouse: name: Jane Smith age: 25children: name: Jimmy Smith age: 15 name: Jenny Smith age: 12 2）语法特点【注意】 · 大小写敏感 · 使用缩进表示层级关系 · 缩进时不允许使用Tab键，只允许使用空格。 · 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 3）yaml下载安装 官网 · 下载安装：cmd 输入pip install pyyaml或者pip3 install pyyaml · 安装完成后在python引入yaml检测是否安装成功。 123456C:\\Windows\\System32&gt;pythonPython 3.6.6 (v3.6.6:4cf1f54eb7, Jun 27 2018, 03:37:03) [MSC v.1900 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import yaml&gt;&gt;&gt; 二、yaml数据支持类型1.支持数据类型 1. **纯量(scalars)**：单个的、不可再分的值 2. 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 3. 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 2.纯量 数据最小的单位，不可以再分割。类似于Python中单个变量 1flag 3.list数组 与Python的list结构类似，数组元素使用“-”开头，也可以根据缩进进行数组嵌套。 123456- Jack- Harry- Sunny# 也可以写成一行[Jack,Harry,Sunny] 对应到python的list写法如下： 1[&#x27;Jack&#x27;,&#x27;Harry&#x27;,&#x27;Sunny&#x27;] 4.对象 12345platformName: AndroidplatformVersion: 7.1.2# Yaml 也允许另一种写法，将所有键值对写成一个行内对象。&#123;platformName: Android,platformVersion: 7.1.2&#125; 注意：冒号后面一定要有空格！对应到python字典的写法如下： 1&#123;&#x27;platformName&#x27;: &#x27;Android&#x27;, &#x27;platformVersion&#x27;: &#x27;6.0.1&#x27;&#125; 数据嵌套 yaml数据嵌套表示可以将上面的各类数据根据实际场景进行组合嵌套。 数据场景： Tom Smith 37岁，他有一个妻子叫 Jane Smith，35岁。 另外他有2个孩子，一个叫Jimmy Smith，15岁；另外一个叫Jenny Smith ，12岁。 yaml语法表示如下： familyInfo.yaml 12345678910name: Tom Smithage: 37spouse: name: Jane Smith age: 35children: - name: Jimmy Smith age: 15 - name: Jenny Smith age: 12 转化为Python的写法为： 1&#123;&#x27;name&#x27;:&#x27;Tom Smith&#x27;,&#x27;age&#x27;:37,&#x27;spouse&#x27;:&#123;&#x27;name&#x27;:&#x27;Jane Smith&#x27;,&#x27;age&#x27;:25&#125;,&#x27;childern&#x27;:[&#123;&#x27;name&#x27;:&#x27;Jimmy Smith&#x27;,&#x27;age&#x27;:15&#125;,&#123;&#x27;name&#x27;:&#x27;Jenny Smith&#x27;,&#x27;age&#x27;:12&#125;]&#125; 三、yaml数据操作1.数据读取1）测试场景 · 读取配置中的所有信息 · 读取yaml数据表中Tom Smith的姓名、年龄、信息 · 单独读取配偶的姓名和年龄信息 · 分别读取两个孩子的姓名、年龄信息 2）load方法 load(stream, Loader=Loader) 解析文件流中的第一个YAML文档并生成相应的Python对象。 3）代码实现 12345678910111213141516171819mport yamlfile=open(&#x27;runtest.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(file)print(data)print(data[&#x27;name&#x27;])print(data[&#x27;age&#x27;])print(data[&#x27;spouse&#x27;])print(data[&#x27;spouse&#x27;][&#x27;name&#x27;])print(data[&#x27;spouse&#x27;][&#x27;age&#x27;])print(data[&#x27;children&#x27;])print(data[&#x27;children&#x27;][0][&#x27;name&#x27;])print(data[&#x27;children&#x27;][0][&#x27;age&#x27;])print(data[&#x27;children&#x27;][1][&#x27;name&#x27;])print(data[&#x27;children&#x27;][1][&#x27;age&#x27;]) 2.数据修改如果想改变某个数据，可以使用如下方法： 12345import yamlfile=open(&#x27;runTest.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(file)data[&#x27;name&#x27;]=&#x27;Test123&#x27;print(data[&#x27;name&#x27;]) 注意：此处只是变量类型的数据变更，不会真正修改到yaml配置表中的数据。 3.数据转化方法：dump()可以将Python对象序列化成YAML流。如果stream为None，则返回生成的字符串。 1）测试场景 将下面python数据类型转化为yaml数据类型 2）代码实践 1234567891011import yamlcity=[&#x27;changsha&#x27;,&#x27;wuhan&#x27;,&#x27;beijing&#x27;]person=&#123;&#x27;tom&#x27;:&#x27;18&#x27;&#125;#python dataprint(city)print(person)#yaml dataprint(yaml.dump(city))print(yaml.dump(person)) 运行结果： 1234567[&#x27;changsha&#x27;, &#x27;wuhan&#x27;, &#x27;beijing&#x27;]&#123;&#x27;tom&#x27;: &#x27;18&#x27;&#125;- changsha- wuhan- beijingtom: &#x27;18&#x27; 4.Capability配置数据分离1）测试场景 将capability的各项参数值与代码进行分离。 2）场景分析 我们可以把之前capability中各项写死的配置信息来抽离出来，存放在一个yaml配置文件中，使用 对象数据类型来存储数据；然后调用load()方法读取数据，从而实现数据和代码的分离。 3）代码实践 参数配置表：desired_caps.yaml 123456789platformName: AndroidplatformVersion: 7.1.2deviceName: 127.0.0.1:62025app: D\\kaoyan3.1.0.apknoReset: FalseappPackage: com.tal.kaoyanappActivity: com.tal.kaoyan.ui.activity.SplashActivityip: 127.0.0.1port: 4723 Python脚本 12345678910111213141516171819from appium import webdriverimport yamlfile=open(&#x27;desired_caps.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(file)desired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps) 报错分析 1yaml.scanner.ScannerError: mapping values are not allowed here 该报错说明map对象数据类型写法错误，一般为“：”后面没有留空格。如： platformName:Android 四、日志概述1）日志作用 不管是在项目开发还是测试过程中，项目运行一旦出现问题日志信息就非常重要了。日志是定位问题的重要手段，就像侦探人员要根据现场留下的线索来推断案情。 2）日志级别 脚本运行会有很多的情况，比如调试信息、报错异常信息等。日志要根据这些不同的情况来继续分级管理，不然对于排查问题的筛选会有比较大的干扰。 。日志一般定位的级别如下： 级别 何时使用 DEBUG 调试信息，也是最详细的日志信息。 INFO 证明事情按预期工作。 WARNING 表明发生了一些意外，或者不久的将来会发生问题（如‘磁盘满了’）。软件还是在正常工作。 ERROR 由于更严重的问题，软件已不能执行一些功能了。 CRITICAL 严重错误，表明软件已不能继续运行了。 首先我们日志需要按照info、debug、error等级别来进行区分的。当然这个级别可以自己去设置。在一般的情况下我们普通的输出我们直接用info类型，调试的时候用debug类型，如果预计有错误时那么我们就需要用error类型的日志，一般情况去info级别最为合适。 3）日志格式 日志格式化是为了提高日志的可阅读性，比如：时间+模块+行数+日志具体信息 的内容格式。如果日志信息杂乱无章的全部输出来，这样也不利于定位问题。 4）日志位置 一个项目中会有很多的日志采集点，而日志采集点必须结合业务属性来设置。比如在登录代码执行前可以插入“准备登录..”日志信息,如果登录完成之后，再设置登录的提示日志就会给人造成误解，无法判断到底是登录之前的问题还是登录之后的问题，因此日志采集点的位置很重要。 五、logging 模块1）简介 Python的logging模块提供了通用的日志系统，这个模块提供不同的日志级别，并可以采用不同的方式记录日志，比如文件，HTTP GET/POST，SMTP，Socket等，甚至可以自己实现方式记录日志。 12#导入logging模块import logging 2）logging构成 logging模块包括logger，Handler，Filter，Formatter四个部分。 · Logger 记录器，用于设置日志采集。 · Handler 处理器，将日志记录发送至合适的路径。 · Filter 过滤器，提供了更好的粒度控制，它可以决定输出哪些日志记录。 · Formatter 格式化器，指明了最终输出中日志的格式。 3）logger 记录器 Logger是一个树形层级结构，在使用接口debug，info，warn，error，critical；使用之前必须创建Logger实例，即创建一个记录器，如果没有显式的进行创建，则默认创建一个root logger，并应用默认的日志级别(WARN)，Handler和Formatter。 方法： basicConfig(参数) 为日志记录系统做基本配置。 部分参数 filename 指定日志文件名称 filemode 指定打开文件的模式，如果指定了filename（如果文件模式未指定，则默认为’a） 文件读写模式 1234567891011w 以写方式打开，W 文件若存在，首先要清空，然后（重新）创建a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)r+ 以读写模式打开w+ 以读写模式打开 (参见 w )a+ 以读写模式打开 (参见 a ) format 为处理程序使用指定的格式字符串 datefmt 使用指定的日期/时间格式。样式如果指定了格式字符串，则使用它来指定 格式字符串的类型. level 将根记录器级别设置为指定级别 12345678import logginglogging.basicConfig(level=logging.DEBUG)logging.basicConfig(level=logging.INFO)logging.debug(&#x27;debug info&#x27;)logging.info(&#x27;hello tom！&#x27;)logging.warning(&#x27;warning info&#x27;)logging.error(&#x27;error info&#x27;)logging.critical(&#x27;critical info&#x27;) 4）haddler 处理器 Handler 处理器，将日志记录发送至合适的路径,Handler处理器类型有很多种，比较常用的有三个： 1.streamhandler 将日志记录输出发送到诸如sys.stdout，sys.stderr或任何类似文件流的对象。 2.filehandler 将日志记录输出发送到磁盘文件。 它继承了StreamHandler的输出功能。 3.nullhandler 5）formatter 使用Formatter对象设置日志信息最后的规则、结构和内容，默认的时间格式为%Y-%m-%d %H:%M:%S。 *格式* *描述* %(levelno)s 打印日志级别的数值 %(levelname)s 打印日志级别名称 %(pathname)s 打印当前执行程序的路径 %(filename)s 打印当前执行程序名称 %(funcName)s 打印日志的当前函数 %(lineno)d 打印日志的当前行号 %(asctime)s 打印日志的时间 %(thread)d 打印线程id %(threadName)s 打印线程名称 %(process)d 打印进程ID %(message)s 打印日志信息 使用方法： 12345678import logginglogging.basicConfig(filename=&#x27;runlog.log&#x27;,level=logging.DEBUG,format=&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;)logging.debug(&#x27;debug info&#x27;)logging.info(&#x27;hello tom！&#x27;)logging.warning(&#x27;warning info&#x27;)logging.error(&#x27;error info&#x27;)logging.critical(&#x27;critical info&#x27;) 输出结果： 2021-09-02 11:50:20,094 ��־.py[line:5] DEBUG debug info2021-09-02 11:50:41,359 ��־.py[line:5] DEBUG debug info2021-09-02 11:50:41,360 ��־.py[line:6] INFO hello tom��2021-09-02 11:50:41,360 ��־.py[line:7] WARNING warning info2021-09-02 11:50:41,360 ��־.py[line:8] ERROR error info2021-09-02 11:50:41,360 ��־.py[line:9] CRITICAL critical info 六、logging实践操作1）测试场景 将前面所学的启动考研帮App的脚本增加log采集功能，设置指定的日志格式输出，并将日志保存到指定文件。 2）代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from appium import webdriverimport yamlfrom selenium.common.exceptions import NoSuchElementExceptionimport loggingfile=open(&#x27;desired_caps.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(file)logging.basicConfig(level=logging.INFO,filename=&#x27;runlog.log&#x27;, format=&#x27;%(asctime)s %(filename)s[line:%(lineno)d]%(levelname)s%(message)s&#x27;)desired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]logging.info(&#x27;start app...&#x27;)driver=webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;,desired_caps)def check_cancelBtn(): logging.info(&#x27;check cancelBtn&#x27;) try: cancelBtn = driver.find_element_by_id(&#x27;android:id/button2&#x27;) except NoSuchElementException: logging.info(&#x27;no cancelBtn&#x27;) else: cancelBtn.click()def check_skipBtn(): logging.info(&#x27;check skipBtn&#x27;) try: skipBtn = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;) except NoSuchElementException: logging.info(&#x27;no skipBtn&#x27;) else: skipBtn.click()check_cancelBtn()check_skipBtn() 3）日志格式配置 将log输出格式，输出路径等参数抽离出来作为一个配置表，如下所示： log.conf 1234567891011121314151617181920212223242526272829303132333435[loggers]keys=root,infoLogger[logger_root]level=DEBUGhandlers=consoleHandler,fileHandler[logger_infoLogger]handlers=consoleHandler,fileHandlerqualname=infoLoggerpropagate=0[handlers]keys=consoleHandler,fileHandler[handler_consoleHandler]class=StreamHandlerlevel=INFOformatter=form02args=(sys.stdout,)[handler_fileHandler]class=FileHandlerlevel=INFOformatter=form01args=(&#x27;runlog.log&#x27;, &#x27;a&#x27;)[formatters]keys=form01,form02[formatter_form01]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s[formatter_form02]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s 在需要调用的模块增加如下代码： 1234567import loggingimport logging.configCON_LOG=&#x27;log.conf&#x27;logging.config.fileConfig(CON_LOG)logging=logging.getLogger() 方法： 1fileConfig(fname, defaults=None, disable_existing_loggers=True) 该放在作用是从ConfigParser格式的文件中读取日志配置，同时如果当前脚本有配置log参数，则覆盖当前log配置选项。 6）代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from appium import webdriverimport yamlfrom selenium.common.exceptions import NoSuchElementExceptionimport loggingimport logging.configstream=open(&#x27;desired_caps.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(stream)CON_LOG=&#x27;log.conf&#x27;logging.config.fileConfig(CON_LOG)logging=logging.getLogger()desired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps)def check_updateBtn(): logging.info(&quot;check_pdateBtn&quot;) try: element = driver.find_element_by_id(&#x27;android:id/button2&#x27;) except NoSuchElementException: logging.info(&#x27;update element is not found!&#x27;) else: element.click()def check_skipBtn(): logging.info(&quot;check_skipBtn&quot;) try: element = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;) except NoSuchElementException: logging.info(&#x27;skipBtn element is not found!&#x27;) else: element.click()check_updateBtn()check_skipBtn()","categories":[],"tags":[{"name":"appium的数据配置与日志手机","slug":"appium的数据配置与日志手机","permalink":"http://example.com/tags/appium%E7%9A%84%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA/"}],"keywords":[]},{"title":"Appium基础操作","slug":"Appium基础操作","date":"2021-09-02T09:39:25.000Z","updated":"2021-09-04T05:06:44.218Z","comments":true,"path":"2021/09/02/Appium基础操作/","link":"","permalink":"http://example.com/2021/09/02/Appium%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","excerpt":"","text":"一、name 定位根据name进行定位，对于android来说，就是text属性 但是由于text稳定性不是很好，所以appium 1.5开始废弃了该方法。 123from Capability import *driver.find_element_by_name(&#x27;请输入用户名&#x27;).send_keys(&#x27;&#x27;)driver.find_element_by_name(&#x27;登录&#x27;).click() 二、classname 定位classname定位是根据元素类型来进行定位，在元素class中，一般有id不使用classname定位。 1234from Capability import *driver.find_element_by_class_name(&#x27;android.widget.EditText&#x27;).send_keys(&#x27;hj18594962283&#x27;)driver.find_element_by_class_name(&#x27;android.widget.EditText&#x27;).send_keys(&#x27;jxx.hxx21.&#x27;)driver.find_element_by_class_name(&#x27;android.widget.Button&#x27;).click() 三、相对定位相对定位是先找到该元素的有对应属性的父元素节点，然后基于父元素进行元素定位。 案例 通过打开考研帮注册界面 123456from Capability import driverdriver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_register_text&#x27;).click()root_element=driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_parentlayout&#x27;)root_element.find_element_by_class_name(&#x27;android.widget.ImageView&#x27;).click() 四、xpath定位xpath定位是一种路径定位方式，主要是依赖于元素绝对路径或者相关属性来定位，但是绝对路径xpath执行效率比较低（特别是元素路径比较深的时候），一般使用比较少。通常使用xpath相对路径和属性定位。 表达式 描述 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 nodename 选取此节点的所有子节点。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 使用xpath定位元素来进行登录操作。 1234from Capability import driverdriver.find_element_by_xpath(&#x27;//android.widget.EditText[@text=&quot;请输入用户名&quot;]&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_xpath(&#x27;//*[@class=&quot;android.widget.EditText&quot; and @index=&quot;3&quot;]&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_xpath(&#x27;//android.widget.Button&#x27;).click() 五、LIST 定位List定位首先是使用find_elements_by_XX获取一组相同的class属性的元素，然后使用数组下标来区分标记不同元素进行相关操作。 通过考研帮注册，选择指定头像 1234567891011from Capability import driverdriver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_register_text&#x27;).click()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_userheader&#x27;).click()images=driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/item_image&#x27;)images[2].click()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/save&#x27;).click() 经过实践执行测试用户注册功能时，发现无法完成注册功能，可能与APP有关 执行的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from Capability import driverimport random#进入注册界面选择并设置头像driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_register_text&#x27;).click()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_userheader&#x27;).click()images=driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/item_image&#x27;)images[2].click()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/save&#x27;).click()#注册信息填写username=&#x27;Test&#x27;+&#x27;FLY&#x27;+str(random.randint(1000,9000))print(&#x27;username: %s&#x27; %username)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_username_edittext&#x27;).send_keys(username)password=&#x27;appium&#x27;+str(random.randint(1000,9000))print(&#x27;password: %s&#x27; %password)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_password_edittext&#x27;).send_keys(password)email=&#x27;pwd&#x27;+str(random.randint(1000,9000))+&#x27;@163.com&#x27;print(&#x27;email: %s&#x27; %email)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_email_edittext&#x27;).send_keys(email)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_register_btn&#x27;).click()#院校选择driver.find_element_by_id(&#x27;com.tal.kaoyan:id/perfectinfomation_edit_school_name&#x27;).click()#选择省份driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/more_forum_title&#x27;)[1].click()#选择具体院校--同济大学driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/university_search_item_name&#x27;)[1].click()#专业选择driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_perfectinfomation_major&#x27;).click()#选择经济学类-统计学-经济统计学driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/major_subject_title&#x27;)[1].click()driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/major_group_title&#x27;)[2].click()driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/major_search_item_name&#x27;)[1].click()#点击“进入考研帮”按钮driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_perfectinfomation_goBtn&#x27;).click() 六、UIAutomator定位简介UIAutomator元素定位是 Android 系统原生支持的定位方式，虽然与 xpath 类似，但比它更加好用，且支持元素全部属性定位.定位原理是通过android 自带的android uiautomator的类库去查找元素。使用如下：find_element_by_android_uiautomator() 可以运用UiAutomator元素定位。 定位方法 · id定位 · text定位 · class name定位 id定位是根据元素的resource-id属性来进行定位，使用 UiSelector().resourceId()方法即可。 1234567from Capability import driverdriver.find_element_by_android_uiautomator(&#x27;newUiSelector().resourceId(&quot;com.tal.kaoyan:id/login_email_edittext&quot;)&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_android_uiautomator(&#x27;newUiSelector().resourceId(&quot;com.tal.kaoyan:id/login_password_edittext&quot;)&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_android_uiautomator&#x27;new UiSelector().resourceId(&quot;com.tal.kaoyan:id/login_login_btn&quot;)&#x27;).click() 七、元素等待作用设置元素等待可以更加灵活的制定等待定位元素的时间，从而增强脚本的健壮性，提高执行效率。 元素等待类型分为强制等待、隐式等待、显示等待 强制等待 设置固定的等待时间，使用sleep()方法即可实现 123from time import sleep#强制等待2秒sleep(2) 隐式等待 隐式等待是针对全部元素设置的等待时间 1driver.implicitly_wait(40) 显式等待 显示等待是针对某个元素来设置的等待时间 方法WebDriverWait格式参数如下： 12345678910from selenium.webdriver.support.ui import WebDriverWaitWebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)driver : WebDrivertimeout : 最长超时时间，默认以秒为单位poll_frequency : 休眠时间的间隔时间，默认为0.5秒ignored_exceptions : 超时后的异常信息，默认情况下抛NoSuchElementException异常。WebDriverWait()一般和until()或until_not()方法配合使用，另外，lambda提供了一个运行时动态创建函数的方法。from selenium.webdriver.support.ui import WebDriverWaitWebDriverWait(driver,10).until(lambda x:x.find_element_by_id(&quot;elementID&quot;)) 八、截图方法方法一 save_screenshot() 该方法直接保存当前屏幕截图到当前脚本所在文件位置。 1driver.save_screenshot(&#x27;login.png&#x27;) 方法二 截图保留到指定文件路径 1driver.get_screenshot_as_file(&#x27;./images/login.png&#x27;) “./“是在运行的py的目录下，images是存在该目录里，如果没有这个文件夹，需要手动建立 考研帮登录后截图测试脚本 1234567891011from Capability import driverdriver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).clear()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.save_screenshot(&#x27;login.png&#x27;)driver.get_screenshot_as_file(&#x27;./images/login.png&#x27;)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_login_btn&#x27;).click() 九、滑动效果在Appium中模拟用户滑动操作需要使用swipe方法，该方法定义如下： 12345678910111213def swipe(self, start_x, start_y, end_x, end_y, duration=None): &quot;&quot;&quot;Swipe from one point to another point, for an optional duration. :Args: - start_x - x-coordinate at which to start - start_y - y-coordinate at which to start - end_x - x-coordinate at which to stop - end_y - y-coordinate at which to stop - duration - (optional) time to take the swipe, in ms. :Usage: driver.swipe(100, 100, 100, 400) 注释———-swipe()方法的参数说明： start_x：起始横坐标 start_y：起始纵坐标 end_x：结束时横坐标 end_y：结束时纵坐标 duration：滑动持续时间，单位毫秒，默认None（一般设置500-1000毫秒比较合适） 实现平面上各个方向位置滑动 通过调用get_size()、swipeLeft()函数来实现滑动效果 1234567891011121314151617#获取屏幕尺寸def get_size(): x=driver.get_window_size()[&#x27;width&#x27;] y=driver.get_window_size()[&#x27;height&#x27;] return x,y#显示屏幕尺寸（width,height）l=get_size()print(l)#向左滑动def swipeLeft(): l=get_size() x1=int(l[0]*0.9) y1=int(l[1]*0.5) x2=int(l[0]*0.1) driver.swipe(x1,y1,x2,y1,1000) Capability.py 123456789101112131415161718192021222324252627282930313233343536373839404142from appium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptiondesired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=&#x27;Android&#x27;desired_caps[&#x27;deviceName&#x27;]=&#x27;127.0.0.1:62025&#x27;desired_caps[&#x27;platforVersion&#x27;]=&#x27;7.1.2&#x27;desired_caps[&#x27;app&#x27;]=r&#x27;d:\\kaoyan.apk&#x27;desired_caps[&#x27;appPackage&#x27;]=&#x27;com.tal.kaoyan&#x27;desired_caps[&#x27;appActivity&#x27;]=&#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;desired_caps[&#x27;noReset&#x27;]=&#x27;False&#x27;driver=webdriver.Remote(&#x27;http://localhost:4723/wd/hub&#x27;,desired_caps)driver.implicitly_wait(2)def check_cancelBtn(): print(&#x27;check cancelBtn&#x27;) try: cancelBtn = driver.find_element_by_id(&#x27;android:id/button2&#x27;) except NoSuchElementException: print(&#x27;no cancelBtn&#x27;) else: cancelBtn.click()def check_skipBtn(): print(&#x27;check skipBtn&#x27;) try: skipBtn=driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;) except NoSuchElementException: print(&#x27;no skipBtn&#x27;) else: skipBtn.click()check_cancelBtn()check_skipBtn()","categories":[],"tags":[{"name":"appuim 基础","slug":"appuim-基础","permalink":"http://example.com/tags/appuim-%E5%9F%BA%E7%A1%80/"}],"keywords":[]},{"title":"monkey日志管理","slug":"monkey日志管理","date":"2021-09-01T11:43:05.000Z","updated":"2021-09-01T11:51:10.789Z","comments":true,"path":"2021/09/01/monkey日志管理/","link":"","permalink":"http://example.com/2021/09/01/monkey%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/","excerpt":"","text":"自定义脚本的稳定性测试常规Monkey测试执行的是随机的事件流，但如果只是想让Monkey测试某个特定场景这时候就需要用到自定义脚本了，Monkey支持执行用户自定义脚本的测试，用户只需要按照Monkey脚本的规范编写好脚本，存放到手机上，启动Monkey通过-f 参数调用脚本即可 需求分析获取元素坐标点位置Monkey脚本只能通过****坐标****的方式来定位点击和移动事件的屏幕位置，这里就需要提前获取坐标信息。获取坐标信息的方法很多，最简单的方法就是打开手机中的开发人员选项，打开“显示指针位置”。随后，在屏幕上的每次操作，在导航栏上都会显示坐标信息。 monkey脚本APILaunchActivity(pkg_name, cl_name)：启动应用的Activity。参数：包名和启动的Activity。 Tap(x, y, tapDuration)： 模拟一次手指单击事件。参数：x,y为控件坐标，tapDuration为点击的持续时间，此参数可省略。 UserWait(sleepTime)： 休眠一段时间 DispatchPress(keyName)： 按键。参数： keycode。 RotateScreen(rotationDegree, persist)： 旋转屏幕。 参数：rotationDegree为旋转角度， e.g. 1代表90度；persist表示旋转之后是否固定，0表示旋转后恢复，非0则表示固定不变。 DispatchString(input)： 输入字符串。 DispatchFlip(true/false)： 打开或者关闭软键盘。 PressAndHold(x, y, pressDuration)： 模拟长按事件。 Drag(xStart, yStart, xEnd, yEnd, stepCount)： 用于模拟一个拖拽操作。 PinchZoom(x1Start, y1Start, x1End, y1End, x2Start, y2Start, x2End, y2End, stepCount)： 模拟缩放手势。 LongPress()： 长按2秒。 DeviceWakeUp()： 唤醒屏幕。 PowerLog(power_log_type, test_case_status)： 模拟电池电量信息。 WriteLog()： 将电池信息写入sd卡。 RunCmd(cmd)： 运行shell命令。 DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFlags)： 向指定位置，发送单个手势。 DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFilags)： 发送按键消息。 LaunchInstrumentation(test_name,runner_name)： 运行一个instrumentation测试用例。 DispatchTrackball： 模拟发送轨迹球事件。 ProfileWait： 等待5秒。 StartCaptureFramerate()： 获取帧率。 EndCaptureFramerate(input)： 结束获取帧率。 monkey脚本格式头部 123456type = raw events count = 1 speed = 1.0 //下面为monkey命令 start data &gt;&gt; 具体的monkey脚本内容 编写脚本 kyb.txt 1234567891011121314151617181920212223242526272829#头文件信息type = raw events count = 1speed = 1.0#启动测试start data &gt;&gt;LaunchActivity(com.tal.kaoyan,com.tal.kaoyan.ui.activity.SplashActivity)UserWait(2000)Tap(624,900,1000) #点击取消升级UserWait(2000)Tap(806,64,1000) #点击跳过UserWait(2000)Tap(217,378,1000) #点击用户名输入框DispatchString(账户)UserWait(2000)Tap(197,461,1000) #点击密码输入框DispatchString(密码)UserWait(2000)Tap(343,637,1000) #点击登录按钮 执行脚本 脚本编写完成后，传到手机设备上，然后执行。 123adb push C:\\Users\\admin\\Desktop\\kyb1.txt /sdcardadb shell monkey -f /sdcard/kyb1.txt -v 1 执行结果 123456789101112131415C:\\Users\\admin&gt;adb shell monkey -f /sdcard/kyb.txt -v 1:Monkey: seed=1524592021303 count=1:IncludeCategory: android.intent.category.LAUNCHER:IncludeCategory: android.intent.category.MONKEYReplaying 0 events with speed 1.0:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.tal.kaoyan/.ui.activity.SplashActivity;end // Allowing start of Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.tal.kaoyan/.ui.activity.SplashActivity &#125; in package com.tal.kaoyan:Sending Touch (ACTION_DOWN): 0:(267.0,1233.0) // Allowing start of Intent &#123; act=com.android.systemui.recent.action.TOGGLE_RECENTS cmp=com.android.systemui/.recent.RecentsActivity &#125; in package com.android.systemui:Sending Touch (ACTION_UP): 0:(267.0,1233.0)Events injected: 5:Sending rotation degree=0, persist=false:Dropped: keys=0 pointers=0 trackballs=0 flips=0 rotations=0## Network stats: elapsed time=7201ms (0ms mobile, 0ms wifi, 7201ms not connected)// Monkey finished 注意事项 头文件代码书写注意“=”两边预留空格，否则会出现如下报错 1java.lang.NumberFormatException: Invalid int: &quot;&quot; 参考资料","categories":[],"tags":[{"name":"monkey日志管理","slug":"monkey日志管理","permalink":"http://example.com/tags/monkey%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"}],"keywords":[]},{"title":"monkey","slug":"monkey","date":"2021-08-31T10:13:54.000Z","updated":"2021-09-01T11:41:54.865Z","comments":true,"path":"2021/08/31/monkey/","link":"","permalink":"http://example.com/2021/08/31/monkey/","excerpt":"","text":"monkey 理论monkey定义andriod自动化测试工具，对被测程序进行压力测试，检查和评估被测程序的稳定性。 monkey官方文档 monkey路径Monkey程序是Android系统自带的，其启动脚本是位于Android系统的/system/bin目录的Monkey文件，其jar包是位于Android系统的/system/framework目录的Monkey.jar文件。用户主要是通过adb命令来启动Monkey的，Monkey在运行时，会根据命令行参数的配置，生成伪随机的事件流，并在Android设备上执行对应的测试事件。 monkey 启动步骤 连接模拟器 12adb connect 127.0.0.1:62001#连接adb devices#检查设备连接情况 连接成功后输入命令 1adb shell 进入到指定目录1cd /system/bin 输入monkey 命令看到一串信息提示就是成功，没有报错即可。 强制关闭 monkey adb shell ps 查看全部在运行的进程 查找出com.android.commands.monkey 进程PID adb shell kill pid 杀掉monkey进程 monkey 命令monkey命令格式如下： 1$ adb shell monkey [options] &lt;event-count&gt; · [options] 是指monkey可传入的参数，是可选项（如果不指定options，Monkey将以无反馈模式启动，并把事件任意发送到安装在目标环境中的全部包） · 是指随机发送事件数。如：输入100就是执行100个伪随机事件，为必选项。 monkey 参数参数分类· 常规类参数 · 事件类参数 · 约束类参数 · 调试类参数 1.常规类参数常规类参数包括帮助参数和日志信息参数。 1.帮助类参数 1monkey -h 2.日志级别 1$ adb shell monkey -v &lt;event-count&gt; -v：打印出日志信息，每个-v将增加反馈信息的级别。-v越多日志信息越详细，不过目前最多支持3个-v 2.事件类参数1.执行指定脚本 1234$ adb shell monkey -f &lt;scriptfile&gt; &lt;event-count&gt;eg：$ adb shell monkey -f /mnt/sdcard/test1 2.伪随机数生成种子值 1234$ adb shell monkey -s &lt;seed&gt; &lt;event-count&gt;eg:$ adb shell monkey -s 666 100 3.设置间隔 如果你希望在每一个指令之间加上固定的间隔时间，可以用–throttle（注意，前面是–）命令。 123$ adb shell monkey --throttle &lt;milliseconds&gt;eg:$ adb shell monkey --throttle 3000 5 –throttle：后面接时间，单位为ms（），表示事件之间的固定延迟（即执行每一个指令间隔的时间），若不接该选项，monkey将不会延迟。 4.调整触摸事件百分比 如果你希望调整触摸事件的百分比，记住使用–pct-touch。 123$ adb shell monkey --pct-toucheg:$ adb shell monkey -v -v --pct-touch 100 200 注意：触摸事件不单单是按键，它泛指发生在某一位置的一个down-up事件 5.调整手势事件百分比 123$ adb shell monkey --pct-motioneg:$ adb shell monkey -v -v --pct-motion 100 200 6.调整应用启动事件的百分比 1$ adb shell monkey --pct-appswtich &lt;percent&gt; 7.调整屏幕旋转事件百分比 1$ adb shell monkey --pct-rotation &lt;percent&gt; 约束类参数1.包约束 -p：后面接一个或多个包名（&lt;”allowed-package-name”&gt;），如果应用需要访问其他包里的Activity，那相关的包也需要在此同时指定。如果不指定任何包，monkey将允许系统启动全部包里的Activity。 12345$ adb shell monkey -p &lt;allowed-package-name&gt; &lt;event-count&gt;eg：$ adb shell monkey -p com.tal.kaoyan 500$ adb shell monkey -p com.tal.kaoyan -p com.tencent.mm 500 2.activity类约束 1adb shell monkey -c &lt;main-category&gt; &lt;event-count&gt; 调试类参数1.应用程序崩溃后继续发送时间 1$ adb shell monkey --ignore-crashes &lt;event-count&gt; 2.超时错误继续发送事件 1$ adb shell monkey --ignore-timeouts 3.应用程序权限错误发生后继续发送事件 1$ adb shell monkey --ignore-security-exceptions 测试命令 12345678adb shell monkey -p com.tal.kaoyan--pct-touch 40 --pct-motion 25 --pct-appswitch 10--pct-rotation 5-s 1666 --throttle 400--ignore-crashes--ignore-timeouts-v -v 200","categories":[],"tags":[{"name":"monkey","slug":"monkey","permalink":"http://example.com/tags/monkey/"}],"keywords":[]},{"title":"MonkeyRunner API","slug":"MonkeyRunner-API","date":"2021-08-31T05:58:58.000Z","updated":"2021-08-31T10:08:08.649Z","comments":true,"path":"2021/08/31/MonkeyRunner-API/","link":"","permalink":"http://example.com/2021/08/31/MonkeyRunner-API/","excerpt":"","text":"MonkeyRunner工具主要有三个类： MonkeyRunner MonkeyDevice MonkeyImage ​ 官方API文档 1.MonkeyRunner 类：MonkeyRunner提供连接真机和模拟器、输入、暂停、警告框等方法 alert() 警告框 choice() 选项列表框 help() API帮助文档 input() 输入 sleep() 暂停 waitForConnection() 等待设备连接 常用方法waitForConnection(float timeout,string deviceid)， 12345from com.android.monkeyrunner import MonkeyRunner as mrprint(&quot;connect devices...&quot;)device=mr.waitForConnection()# device=mr.waitForConnection(5,&#x27;127.0.0.1:62001&#x27;) 2.MonkeyDevices类MonkeyDevice类提供了安装和卸载程序包、开启Activity、发送按键和点击事件、运行测试包等方法。 broadcastInternt() 发送广播 drag() 拖动 getProperty() 获取当前设备属性 getSystemProperty() 获取当前设备属性 installPackage() 安装应用 instrument() 执行测试用例 press() 按键 reboot() 重启 removePackage() 删除指定Package shell() 执行命令 startActivity() 启动应用 touch() 点击 常用方法 · installPackage (string path) · removePackage (string package) · startActivity (string uri, string action, string data, string mimetype, iterable categories dictionary extras, component component, flags) · touch (integer x, integer y, integer type) touch参数说明 integer x，x坐标值。integer y，y坐标值。integer type，key event类型（如DOWN、UP、DOWN_AND_UP）。 DOWN为按下事件 UP为弹起事件 DOWN_AND_UP为按下弹起事件。 · drag (tuple start, tuple end, float duration, integer steps) drag参数详细说明如下： tuple start，拖拽起始位置，为tuple类型的(x,y)坐标点。tuple end，拖拽终点位置，为tuple类型的(x,y)坐标点。float duration，拖拽手势持续时间，默认为1.0s。-integer steps，插值点的步数，默认值为10。 实践案例：连接设备，安装考研帮App并启动 代码如下： 1234567891011121314151617181920from com.android.monkeyrunner import MonkeyRunner as mrfrom com.android.monkeyrunner import MonkeyDevice as mdprint(&quot;connect devices...&quot;)device=mr.waitForConnection()print(&quot;install app...&quot;)device.installPackage(r&#x27;C:\\Users\\admin\\Desktop\\kaoyan3.1.0.apk&#x27;)package = &#x27;com.tal.kaoyan&#x27;activity = &#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;runComponent = package + &#x27;/&#x27; + activityprint(&quot;launch App...&quot;)device.startActivity(component=runComponent)代码执行方式monkeyrunner scripfileC:\\Users\\admin&gt;monkeyrunner E:\\monkeyrunner_script\\kyb.py 3.MonkeyImage类MonkeyImage类在测试过程中用来保存各种格式的测试截图，并可以进行图像对比。 convertToBytes() 转换图像格式 getRawPixel() 获取当前坐标像素元组 getRawPixelint() 获取当前坐标像素元组 sameAs() 图像对比 writeToFile() 保存图像文件 getSubimage() 截取子图像 常用方法 · takeSnapshot() 进行屏幕截图 · writeToFile() 保存图像文件到指定的文件路径 用法示例 1234from com.android.monkeyrunner import MonkeyImage as mi print(&quot;takeSnapshot&quot;)screenshot=device.takeSnapshot() screenshot.writeToFile(r&#x27;E:\\monkeyrunner_script\\test.png&#x27;,&#x27;png&#x27;) 综合实践测试场景· 连接设备，自动安装并启动考研帮app · 启动后登录账号，然后截图并保存到指定文件位置。 思路分析· 连接设备 · 安装app · 启动app · 输入用户名密码点击登录按钮 · 截图 脚本实现kyb_login.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344from com.android.monkeyrunner import MonkeyRunner as mrfrom com.android.monkeyrunner import MonkeyDevice as mdfrom com.android.monkeyrunner import MonkeyImage as miprint(&quot;connect devices...&quot;)device=mr.waitForConnection()print(&quot; install app&quot;)device.installPackage(r&#x27;C:\\Users\\admin\\Desktop\\kaoyan3.1.0.apk&#x27;)print(&quot;launch app...&quot;)package=&#x27;com.tal.kaoyan&#x27;activity=&#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;runComponent=package+&#x27;/&#x27;+activitydevice.startActivity(component=runComponent)mr.sleep(3)print(&quot;touch cancel button&quot;)device.touch(618,895,&#x27;DOWN_AND_UP&#x27;)mr.sleep(1)print(&quot;touch skip button&quot;)device.touch(804,67,&#x27;DOWN_AND_UP&#x27;)mr.sleep(1)print(&quot;input username and password&quot;)device.touch(57,373,&#x27;DOWN_AND_UP&#x27;)mr.sleep(2)device.type(账户)device.touch(152,480,&#x27;DOWN_AND_UP&#x27;)mr.sleep(2)device.type(密码)mr.sleep(2)print(&quot;touch login button&quot;)device.touch(331,634,&#x27;DOWN_AND_UP&#x27;)print(&quot;takeSnapshot&quot;)screenshot=device.takeSnapshot()screenshot.writeToFile(r&#x27;D:\\monkeyrunner\\kyb.png&#x27;,&#x27;png&#x27;) 注意事项方法调用错误 1AttributeError: type object &#x27;com.android.monkeyrunner.XXXXX&#x27; has no attribute XXXXXX 检查调用的方法名是否写错，特别是注意区分大小写。 字符编码错误 1SyntaxError: Non-ASCII character in file &#x27;E:\\monkeyrunner_script\\kyb.py&#x27;, but no encoding declared; 需要在代码顶部补充 # -- coding: utf-8 -- 或者去掉代码中的中文字符","categories":[],"tags":[{"name":"Monkeyrunner","slug":"Monkeyrunner","permalink":"http://example.com/tags/Monkeyrunner/"}],"keywords":[]},{"title":"从0开始搭建一个博客站点","slug":"从0开始搭建一个博客站点","date":"2021-08-30T07:41:14.000Z","updated":"2021-08-30T10:37:50.229Z","comments":true,"path":"2021/08/30/从0开始搭建一个博客站点/","link":"","permalink":"http://example.com/2021/08/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/","excerpt":"","text":"1.Hexo的入门 hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。 hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。 参考：官网文档 1.1安装node.js网上安装教程 验证安装是否成功 进入cmd 输入node -v 出现相应的版本号ok 12C:\\Windows\\System32&gt;node -vv14.17.5 1.2安装gitgit安装教程 验证git安装成功与否 进入cmd 输入 git version 出现相应的版本号ok 12C:\\Windows\\System32&gt;git versiongit version 2.33.0.windows.2 1.3安装、配置hexo文件1.进入git bash窗口 2.输入以下命令 1npm install -g hexo-cli 3.出现一堆代码 4.输入以下命令 123hexo init d:/文件夹名 ----表示在d盘创建这个文件夹 cd 文件名 ----进入文件夹 npm install ----安装 1.4关于hexo文件夹里面的内容1.4.1 hexo文件目录安装hexo完毕，d盘目录下你创建的文档下面的内容： 1234567891011├── _config.yml├── .deploy_git├── .github├── public├── themes├── source| └── .gitkeep ├── scraffolds| ├── draft.md ├── page.md └── post.md 1.4.2 hexo目录文件介绍（了解）_confifig.yml 网站的配置信息，您可以在此配置大部分的参数。 package.json 已经默认给你安装的应用程序的信息 scaffffolds 模版文件夹。当您新建文章时，Hexo 会根据 scaffffold 来建立文件，了解即可 source 资源文件夹是存放用户资源的地方。一般你通过命令创建的文章都存储在 _posts 文件夹里面 themes 这个主要存放的hexo的主题文件，类似英雄皮肤，通过更改不同主题来实现不同酷炫的效果。 1.5_confifig.yml配置文件详解（了解）1.5.1网站相关 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 你的名字 language 网站使用的语言 timezone 网站时区时区列表 1.5.2网址相关 参数 描述 url 网址 root 网站根目录 permalink 文章永久链接 格式 permalink_defaults 永久链接中各部分的默认值 1.5.3目录相关 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public archive_dir 标签文件夹 tags category_dir 归档文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 1.5.4日期与格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 1.6hexo相关命令指令参考 1.7建立远程博客访问1.7.1 本地启动hexo启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可： 1hexo server 或者 hexo s 浏览器访问网址：http://localhost:4000/ 至此，你的hexo本地博客已经搭建成功。 1.7.2GithubPages的使用在开始之前创建github官网账号，并创建一个仓库 注意仓库名的格式： 仓库名为：Github账号名称.github.io 1.安装 hexo-deployer-git插件。在命令（Git Bash）运行以下命令 $ npm install hexo-deployer-git --save 2.添加SSH key 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可。 邮箱地址和注册github的邮箱保持一致。 $ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如 C:\\users\\administrator\\.ssh\\id_rsa.pub)，粘贴到 New SSH KEY即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com $ yes 3.修改 _config.yml （在站点目录下）。文件末尾修改为： 123456# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy:type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面的格式type和repo的冒号后面需要空格两下； ​ 上面仓库地址写ssh地址，不写http地址 。 4.推送到GithubPages。在命令行（即Git Bash）依次输入以下命令，返回 INFO Deploy done: git即成功推送： 12$ hexo g $ hexo d 或 1$ hexo g -d 5.等待1分钟左右，浏览器访问网址： https://&lt;Github账号 名称&gt;.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为 https://&lt;Github账号名称&gt;.github.io 。","categories":[],"tags":[{"name":"hexo 搭建","slug":"hexo-搭建","permalink":"http://example.com/tags/hexo-%E6%90%AD%E5%BB%BA/"}],"keywords":[]},{"title":"胡俊学习经历","slug":"胡俊学习经历","date":"2021-08-28T08:38:36.000Z","updated":"2021-09-07T09:25:43.982Z","comments":true,"path":"2021/08/28/胡俊学习经历/","link":"","permalink":"http://example.com/2021/08/28/%E8%83%A1%E4%BF%8A%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86/","excerpt":"","text":"黑盒测试一、测试活动1、需求分析2、测试计划3、用例设计4、用例执行5、测试报告（天猫项目）二、等价类测试法1. 什么是等价类是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。2、划分等价类可以把全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件就可以用少量代表性的测试数据取得较好的测试结果3、划分等价类的方法1）区间；2）数值集合划分；3）输入是布尔量，确定有效和无效等价类；4）按照数值划分；5）按照限制条件或规则划分；6）细分等价类4、设计测试用例（原则）1）为每一个等价类规定一个唯一的编号；2）设计一个新的测试用例,使其尽可能多地覆盖尚未被覆盖地有效等价类,重复这一步，直到所有的有效等价类都被覆盖为止；3） 设计一个新的测试用例,使其仅覆盖一个尚未被覆盖的无效等价类,重复这一步，直到所有的无效等价类都被覆盖为止；（三角形案例）三、边界值分析1.定义边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。2.与等价类的区别边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。3.边界值分析设计1）确定边界情况；2）选取正好等于、刚刚大于、刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据；健壮性测试：有效和无效均要测试；0作为边界值要反复测试强性测试：有效覆盖弱性测试：无效覆盖弱健壮性：有效、无效均覆盖部分三角形问题的边界值分析测试用例","categories":[],"tags":[{"name":"黑盒测试","slug":"黑盒测试","permalink":"http://example.com/tags/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"}],"keywords":[]},{"title":"JMeter 的基础操作","slug":"JMeter-的基础操作","date":"2021-08-27T06:24:41.000Z","updated":"2021-09-07T11:32:30.928Z","comments":true,"path":"2021/08/27/JMeter-的基础操作/","link":"","permalink":"http://example.com/2021/08/27/JMeter-%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","excerpt":"","text":"一、jmeter的介绍1. JMeter 是什么？ JMeter 也称为“Apache JMeter”，它是一个开源的，100%基于 Java 的应用程序，带有图形界面。 它旨在分析和衡量 Web 应用程序和各种服务的性能和负载功能行为。 JMeter 主要用于测试 Web 应用程序或 FTP 应用程序，但目前，它适用于功能测试，JDBC 数据库连接，Web 服务，通用 TCP 连接和 OS 本机进程。 您可以执行各种测试活动，如性能，负载，压力，回归和功能测试，以便针对您的 Web服务器获得准确的性能指标。 JMeter 不是一个浏览器，它不像任何浏览器那样呈现 html 页面，而是在协议级别上运行。 以下是 JMeter 支持的协议列表: 12345Web Services - SOAP / XML-RPCWeb - HTTP,HTTPS sites ‘web 1.0’ web 2.0 (ajax, flex 和 flex-ws-amf) 通过 JDBC 驱动程序的数据库目录 - LDAP通过 JMS 面向消息传递的服务 服务——POP3, IMAP, SMTP 2. JMeter 的特性 **开源应用程序:**JMeter 是一个免费的开源应用程序，可以帮助用户或开发人员使用源代码开发其他应用程序。 **支持各种测试方法:**JMeter 支持各种测试方法，如负载测试，分布式测试和功能测试等。 123Web: HTTP, HTTPS, SOAP 数据库: JDBC, LDAP, JMSMail: POP3 **支持多协议:**JMeter 支持 HTTP，JDBC，LDAP，SOAP，JMS 和 FTP 等协议。 **模拟:**JMeter 可以使用虚拟用户或唯一用户模拟多个用户，以便对正在测试的 Web 应用程序产生大量负载。 **测试结果可视化:**测试结果可以以不同的格式查看，如图形，表格，树型和报告等。 3. JMeter 的工作流程 JMeter 通过模拟一组用户将请求发送到目标服务器。 随后，收集数据以通过各种格式 计算目标服务器的统计和显示性能度量。 如下图所示： 4.JMeter的安装 注意：安装 Jmeter 需要安装配置好对应的 java 环境 JMeter 下载、安装教程参考： https://blog.csdn.net/qq_39706570/article/details/91447382 5. 构建 JMeter 的测试计划 可以将测试计划可视化为用于运行测试的 JMeter 脚本。测试计划由测试元素组成，例 如线程组，逻辑控制器，样本生成控制器，监听器，定时器，断言和配置元素。 每个测试计划中至少应有一个线程组。 我们可以根据要求添加或删除元素。 让我们按照以下简单步骤开始构建测试计划: 1. 启动 JMeter 窗口 双击文件夹里面 bin 目录里面的 Jmeter.bat，出现如下画面 默认的 JMeter 界面包含一个测试计划节点，其中保留了真实的测试计划。 测试计划(Test plan)：节点包含测试计划的名称和用户定义的变量。当您在测试计划的多 个部分中有重复值时，可使用用户定义变量，它提供了灵活性。 提示：汉化一下: 2. 添加、删除测试计划元素 1 为 JMeter 创建测试计划后，下一步是向 JMeter 测试计划添加和删除元素。 2 选择测试计划节点，然后右键单击所选项目。 3 鼠标悬停在“Add”选项上，然后将显示元素列表。 4 鼠标悬停在所需的列表元素上，然后单击选择所需的选项 下图显示了如何在测试计划中添加线程组元素 要删除元素，请选择所需的元素。 右键单击元素，然后选择“Remove”选项。 下图显示了如何删除测试计划中的线程组元素: 3. 加载并且保存测试计划元素 要将元素加载到 JMeter 测试计划树，请选择并右键单击要添加已加载元素的任何树元素。 选择“Merge”选项。 选择保存元素的.jmx 文件。 元素将合并到 JMeter 测试计划树中。 要保存树元素，请右键单击元素。 选择“Save Selection As”选项。将文件保存在所需位置。 4. 配置树元素 可以使用 JMeter 右侧框架上的控件配置测试计划中的元素。 这些控件允许您配置所 选元素的行为。 例如，可以通过以下方式配置线程组: 1 元素的名称。 2 线程数(正在测试的用户数)。 3 加速时间(希望允许线程组从 0 到 3 个用户的时间)。 4 循环计数(应该循环测试的次数)。 5. 保存 JMeter 测试计划 到目前为止，我们已经完成了创建测试计划，添加元素和配置树。现在，您可以通过从 文件菜单中选择“Save” 或“Save Test Plan As”来保存整个测试计划。 6. 运行 Jmeter 测试计划 可以通过单击菜单项中的“Start(Ctrl + r)”来运行测试计划，也可以单击绿色播放按 钮。下图显示了如何运行测试计划。 7. 停止 JMeter 测试计划 可以使用 Stop(Control +’.’)停止测试计划 - 如果可能，它会立即停止线程。您还 可以使用 Shutdown(Control +’，’) - 它请求线程在任何正在进行的任务结束时停止 8. 检查 JMeter 测试计划执行日志 JMeter 将测试运行详细信息，警告和错误存储到 jmeter.log 文件中。您可以通过单击菜单栏正下方部分右侧的惊叹号来访问 JMeter 日志。下图显示了如何访问 JMeter 日志： 二、JMeter 的测试计划(认识组件)1. JMeter 测试计划元素 JMeter 包含各种相互关联但为不同目的而设计的元素。在开始使用 JMeter 之前，最 好先了解一下 JMeter 的一些主要元素，并详细说明。 注意:测试计划包含至少一个线程组。 以下是 JMeter 的主要的几个组件 测试计划(Test Plan) 线程组(Thread Group) 控制器(Controllers) 监听器(Listeners) 计时器(Timers) 配置元素(Configuration Elements) 7.预处理器元素(Pre-Processor Elements) 后处理器元素(Post-Processor Elements) 每个组件与 JMeter 特定模块之间的关系 2. JMeter 测试计划 可以将测试计划可视化为用于运行测试的 JMeter 脚本。 测试计划由测试元素组成，例如线程组，逻辑控制器，样本生成控制器，监听器，定时 器，断言和配置元素。 下图给出了测试计划的目录级别。 运行整个测试计划之前，应保存测试计划。JMeter 文件或测试计划以.JMX 扩展文件的 形式保存。JMX 是一种基于开放测试的格式，它使测试计划能够在文本编辑器中启动。您还可以将测试计划的一部分保存为不同的选择。 例如，如果要使用侦听器保存 HTTP 请求采样器，可以将其保存为测试片段，以便它也 可以在其他测试场景中使用。 3. JMeter 的线程组 线程组顾名思义，线程组表示 JMeter 在测试期间将使用的线程组。 线程组元素是任 何测试计划的起点。 线程组提供的控件允许: 设置线程数。 设置加速期。 设置执行测试的次数。 前面已在“添加/删除测试元素”部分中说明了在测试计划中添加线程组的步骤。下图 显示了线程组的控制面板部分。 线程组控制面板包括: 1.线程组名称。 2.线程数(您正在测试的用户数)。 3.加速时间(您希望允许线程组从 0 到 3 个用户的时间)。 4.循环计数(应该循环测试的次数)。 5.调度程序复选框(“线程组”面板底部的复选框用于启用/禁用额外字段，您可以在其 中输入测试持续时间，启动延迟，运行的开始和结束时间)。 4. JMeter 的控制器 控制器可分为两大类: 采样器 逻辑控制器 1) 采样器 采样器是允许 JMeter 将特定类型的请求发送到服务器的组件。它模拟用户对目标服务 器的页面的请求。 采样器是必须将组件添加到测试计划中的，因为它只能让 JMeter 知道需要将哪种类型 的请求发送到服务器。 请求可以是 HTTP，HTTP(s)，FTP，TCP，SMTP，SOAP 等。 下面给出了 JMeter 采样器服务的请求列表: 1 FTP 请求 2 HTTP 请求(也可用于 SOAP 或 REST Web 服务) 3 JDBC 请求 4 Java 对象请求 5 JMS 请求 6 JUnit 测试请求 7 操作系统进程请求 8 TCP 请求 JMeter 采样器只能通过下图所示的方法添加到线程组中 2) 取样器 逻辑控制器可帮助您控制线程中采样器处理顺序的流程。 它还可以更改来自其子元素 的请求的顺序。 以下是 JMeter 中所有逻辑控制器的列表： 运行时控制器 IF 控制器事务控制器 录制控制器 简单控制器 while 控制器 Switch 控制器 ForEach 控制器 模块控制器 包括控制器循环控制器 仅一次控制器测试系列课程——教学部刘波 交错控制器 14.随机控制器 随机顺序控制器 吞吐量控制器 5. JMeter 的监听器 性能测试就是以各种形式分析服务器响应，然后将其呈现给客户端。 当 JMeter 的采样器组件被执行时，监听器提供 JMeter 收集的关于那些测试用例的数据的图形表示。 它便于用户在某些日志文件中以表格，图形，树或简单文本的形式查看采样器结果。 监听器可以在测试的任何地方进行调整，直接包括在测试计划下。 JMeter 提供了大约 15 个监听器，但主要使用的是表，树和图形。 以下是 JMeter 中所有监听器的列表： 图表结果 样条曲线可视化器 断言结果 简单的数据编写者 监控结果 分布图(alpha) 聚合图 梅勒展示台 BeanShell 监听器 总结报告 示例结果保存配置 图表完整结果 查看结果树 汇总报告 查看表格中的结果 下图显示如何在 Jmeter 中添加监听器: 6. JMeter 的计时器 当您在网站或应用程序上执行任何操作时，它们自然会有暂停和延迟。 这 些可以使用计时器(Timers)进行模拟。 JMeter 发送请求时不会在每个采样器/请求之间应用延迟。 如果在服务器上执 行负载/压力测试没有指定延迟，它将会超载。 这可能不完全是我们想要的。可 以添加一个计时器元素，该元素允许您定义在每个请求到达时间等待的终止。 下面给出了 JMeter 提供的所有计时器元素的列表： 同步定时器 JSR223 时间 BeanShell 时间 高斯随机定时器 统一随机定时器 恒定吞吐量计时器 BSF 时间 泊松随机时间 下图显示了一个固定定时器控制面板： 7. JMeter 的配置元素 配置元素的工作与采样器的工作类似。但是，它不发送请求，但它允许修改采样器发出 的请求。 这是一个简单的元素，您可以在其中收集所有采样器的关联配置值，如 webserver 的 主机名或数据库 URL 等。 配置元素只能从放置元素的分支内部访问。 8. JMeter 预处理元素 预处理器元素在采样器发出请求之前执行，如果预处理器附加到采样器元 素，那么它将在该采样器元素运行之前执行。 预处理器元素用于在运行之前修改样本请求的设置，或更新未从响应文本中提取 的变量。 以下是 JMeter 提供的所有预处理器元素的列表: JDBC 预处理器 JSR223 预处理器 RegEx 用户参数 BeanShell 预处理器 BSF 预处理器 HTML 链接解析器 HTTP URL 重写修饰符 HTTP 用户参数修饰符 用户参数 下图显示了如何将预处理器元素添加到测试计划中 9. JMeter 的后处理元素 在发出采样器请求之后执行后处理器元素。 如果后处理器连接到 Sampler 元素，那么 它将在该 sampler 元素运行之后执行。 后处理器最常用于处理响应数据，例如，为了将来目的而提取特定值。 下面给出了 JMeter 提供的所有后处理器元素的列表： CSS/JQuery 抽取器 BeanShell 后处理器 JSR223 后处理器 JDBC 后处理器 调试后处理器 正则表达式提取器 XPath 抽取器 结果状态操作处理程序 BSF 后处理器 下图显示了如何将后处理器元素添加到测试计划中 10.JMeter 的函数 JMeter 函数可以称为特殊值，可以填充测试树中任何 Sampler 或其他元素的字段。 JMeter 中函数的语法: 1$&#123;__functionName(var1,var2,var3)&#125; , 这里__ functionName 匹配函数的名称，圆括号围绕发送给函数的参数。 如果函数参数包含逗号，那么请务必使用“\\”对其进行转义，否则 JMeter 会将其 视为参数分隔符。 例如: 1$&#123;__time(EEE\\, d MMM yyyy)&#125; 创建 JMeter 测试计划 123451.进入到 JMeter/bin 文件夹并双击 jmeter.bat 文件以启动 JMeter 界面。 2.选择测试计划节点，然后右键单击所选项目。 3.鼠标悬停在“Add”选项上，然后将显示元素列表。4.选择“Threads (Users)” &gt; “Thread Grou”。 5.将此线程组重命名为 Thread Group 1。 添加采样器 123456我们必须在线程组中添加一个 HTTP 请求采样器。 1.选择“Thread Group”，然后右键单击所选项。2.鼠标悬停在“Add”选项上，然后将显示元素列表。 3.选择 Sampler &gt; HTTP 请求选项。4.它将添加一个空的 HTTP 请求采样器。 12345将 HTTP Request Sampler 的字段配置为 -1.Name - HTTP 请求采样器 1。 2.Server 名称或 IP - 在示例中，Web 服务器名称将为 - www.baidu.com 3. Protocol - 此字段保持不变。 4. Path - 我们将其写为“/”(斜杠)。 它表示我们想要服务器的根页面 现在，复制整个线程组 1 并将其粘贴在测试计划中三次。 将其他线程组分别重命名为线程组 2 和线程组 3。 将其他采样器分别重命名为 HTTP 请求采样器 2 和 HTTP 请求采样器 3。 添加监听器 · 选择“Test Plan”节点，然后右键单击所选项目。 · 鼠标悬停在“Add”选项上，然后将显示元素列表。 · 选择 Listener -&gt; Summary Report。 保存并执行测试计划 单击文件 -&gt; 将测试计划另存为。 将整个测试计划保存为 Function_test.jmx。 然后单击“Run” -&gt; “Start” 以执行测试计划。 验证输出 因此，已经成功执行了测试计划。 现在，我们将使用 log 函数作为第一个 HTTP Request Sampler 的名称。 您可以看到日志功能已打印“Hello World”而不是完整的采样器名称。 让我们来 看看一个时间函数的例子，将再次使用它作为第二个 HTTP 采样器的名称。 时间函数的语法： 1$&#123;__time(dd MM YYYY HH mm ss)&#125; 单击 Run &gt; Start 以执行测试计划。 可以看到时间函数已打印确切的时间和日期，而不是完整的采样器名称。 三、JMeter 的实战1. JMeter 数据库测试计划 准备表数据 为了我们的测试目的，这里将创建一个数据库。 1231.创建名为 testdb 的数据库。 2.创建表 - tb_user。 3.将记录插入到 tb_user 表中。 注意: 您需要将相应的 JDBC 驱动程序复制到 jmeter 的文件夹里面“lib”目录中 下方链接：如何去下载 JDBC 的驱动包 https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-j ava-5.1.47.zip 重启 JMeter 创建 Jmeter 测试计划 1234561.进入到安装的 apache-jmeter-4.0\\bin文件夹，双击 jmeter.bat文件以启动 JMeter界面。2.选择测试计划节点，然后右键单击所选项目。3.鼠标悬停在“Add”选项上，然后将显示元素列表。4.选择“线程(用户)” -&gt; “Thread Group”。5.将此线程组重命名为:JDBC Users。6.线程组的默认属性保持不变。 创建 JDBC 请求 12345右键单击 JDBC users 元素。 鼠标悬停在**“Add”** 选项上，然后将显示元素列表。 选择 Config Element -&gt; JDBC Connection Configuration 。 需要设置一些重要的字段，这些字段将决定数据库和 JMeter 之间的正确连接。 这些 字段包括 1234561. 绑定到池的变量名称 - 它唯一地标识配置。 JDBC Sampler 将进一步使用此名称来标识 要使用的配置。这里将其命名为 test。 2. 数据库 URL： jdbc:mysql://localhost:3306/数据库名3. JDBC 驱动程序类： com.mysql.jdbc.Driver4. 用户名 ：数据库用户名（一般 root） 5. 密码 : root 用户的密码。 6. 其他字段保持不变。 12341. 右键单击 JDBC users 元素。 2. 鼠标悬停在“Add”选项上，然后将显示元素列表。 3. 选择 Sampler -&gt; JDBC request。 4. 选择此新元素以查看其控制面板。 需要设置一些重要的字段。 JDBC 请求控制面板包括 12341. 名字 - JDBC Request。 2. 输入池名称 - 测试(与配置元素中的相同)。 3. 查询类型 - 选择语句。 4. 查询 - 输入 SQL 查询字符串字段 创建监听器 验证输出 执行看监听器的结果 2. JMeter web 测试计划 现在我们学习如何去创建测试网页的基本的测试计划。 本次演示的目标网址：https://svnbucket.com/ 1) 创建测试计划 单击“Test Plan”节点。 将测试计划重命名为 Demo Test。 选择 Demo Test 节点并右键单击所选项目。 鼠标悬停在“Add”选项上，然后将显示元素列表。 选择 Threads (Users) -&gt; Thread Group。 将此线程组重命名为 Users。 对于此测试，Users 元素表示访问网站主页的用户数。 2) 添加采样器 我们必须在 Users 元素(线程组)中添加一个采样器。 选择 Users 元素(线程组)，然后右键单击所选项。 鼠标悬停在“Add”选项上，然后将显示元素列表。 选择 Sampler -&gt; HTTP request 选项。 它将添加一个空的 HTTP 请求采样器。 现在，配置 HTTP Request Sampler 的字段。它包括: 名称 - 访问易百网站主页(https://svnbucket.com )。 服务器名称或 IP - 在这个示例中，Web 服务器名称是: svnbucket.com 协议 - 此字段保持不变。 路径 - 将其写为/(斜杠)。 它表示想要服务器的根页面。 3) 添加监听器 选择 Users 元素。 鼠标悬停在“Add”选项上，然后将显示元素列表。 选择 Listener -&gt; View Results Tree 选项。 4) 验证输出 因为，我们将 Users 元素(线程组)的设置保留为单线程(一个用户)并循环 1 次(仅运行 1 次)。 因此，在 View Result Tree Listener 中将结果作为单个用户请求获取。 此测试计划仅适用于一个请求。 但是 JMeter 能够发送相同的请求，就好像许多用户正在 发送它一样。 要测试具有多个用户的 Web 服务器，需要更改 Users 元素(线程组)设置。 “View Result Tree” 面板的第一个选项卡是“Sampler result”。 它显示了 JMeter 数据以及 Web 服务器返回的数据。 “ Sampler result ” 选 项 卡 显 示 Web 服 务 器 发 送 的 所 有 响 应 标 头 。 “Sampler result”面板的第二个选项卡是“请求”，它显示作为请求的一部分发送到 Web 服务器的所有数据。 “Sampler result”面板的最后一个选项卡是响应数据。 它以文本格式显示从服务器接收 的数据。 3. JMeter 服务器代理方式 (1) 在 pc 端，通过服务器代理方式录制脚本步骤： 准备：IE 浏览器： 12341：工具---Internet 选项2：连接----局域网设置 3：勾选为 lan 代理……4：设置地址：localhost 端口：8080（用完记得关闭） JMeter 中操作: 1：添加线程组 2：选择线程组—》逻辑控制器—》录制控制器 3：右击 testplan—》非测试元件—-》http 代理服务器 4：进入 http 代理服务器设置： A:端口号与你的浏览器局域网设置当中为 LAN….设置的端口一致（前提是端口不能被占用） B:选择目标控制器，要求与你新建的录制控制器结构顺序一致，选择分租 为——每一个组放一个控制器。 C:最后配置好了之后，点击启动，如果报错，常见的问题就是一个端口占用问题， 继续回去设置端口。出现以下界面，则配置 ok. 5:启动禅道，观察 JMeter 里面的录制控制器。 6：清除记录 (2) 在移动端，通过服务器代理方式录制脚本 实现的效果： 通过 JMter 一个连接，然后你在手机操作你的 APP，JMter 它会有记录 它的准备工作： 手机+电脑+必须同一个 wifi 情况下（手机开热点是不行的） 步骤： 设备连接到同一个网络 在本地查看一下你的 ip 地址（命令：ipconfig） 一般安卓手机(如何设置手机的代理模式) 进入手机设置—进入 wifi 设置 长按住（点击后面叹号）你已经连接上那个 wifi,会弹出一个界面，点击该界面中的代 理（有些能够直接看到高级设置同理）然后设置为手动，会提示你输入主机名：要求与你本 地 ip 在同一个默认网关的 ip。 还有端口号：必须与你 JMeter 端口号一致。 启动服务，然后自己可以在手机上去模拟用户对 app 的操作,然后再到 JMeter 中的录 制控制器去观察结果。 最后一步，请用完了，记得关闭服务。 手动配置主机名： 作用：常用与移动 App 测试当中，用来模拟用户的一个操作，如果仅凭肉眼来观察， 它是没有一个可靠的步骤和记录的。","categories":[],"tags":[{"name":"JMeter的基础操作","slug":"JMeter的基础操作","permalink":"http://example.com/tags/JMeter%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"}],"keywords":[]},{"title":"Webdriver 的应用","slug":"Webdriver-的应用","date":"2021-08-18T07:31:26.000Z","updated":"2021-09-07T01:30:06.503Z","comments":true,"path":"2021/08/18/Webdriver-的应用/","link":"","permalink":"http://example.com/2021/08/18/Webdriver-%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"一、webdriver 的概述、环境搭建Webdriver (Selenium2）是一种用于 Web 应用程序的自动测试工具，它提供了一套友好的 API，与 Selenium 1（Selenium-RC）相比，Webdriver 的 API 更容易理解和使用，其可读性和可维护性也大大提高。Webdriver 完全就是一套类库，不依赖于任何测试框架，除了必要的浏览器驱动，不需要启动其他进程或安装其他程序，也不必像 Selenium 1 那样需要先启动服务。 (1)支持浏览器 Firefox （FirefoxDriver） IE（InternetExplorerDriver） Opera（OperaDriver） Chrome （ChromeDriver） safari（SafariDriver） (2)支持语言 Java C# PHP Python (3)安装，卸载、查看 安装：pip install selenium==XXXX 卸载 pip uninstall selenium 查看版本号： pip show selenium (4)环境的搭建 前提要求： 安装好 python 解释器 安装好 pycharm 软件 实现步骤： 下载好 geckodriver 驱动 下载地址：https://github.com/mozilla/geckodriver/releases 然后解压，把文件放到 python 解释器的安装目录 Pycharm 里面导入 selenium 模块 二、第一个自动化测试的脚本(1) 实现案例： 启动火狐浏览器， 首先打开网易首页，打印网页标题，等待 3 秒 打开百度首页，打印网页标题，再等待 2 秒 关闭浏览器。 (2)实现代码 1234from selenium import webdriver from time import sleep #加载浏览器驱动 driver=webdriver.Firefox() #打开网易首页 driver.get(&quot;http://www.163.com&quot;) #打印标题 print(driver.title) sleep(3) #打开百度首页 driver.get(&quot;http://www.baidu.com&quot;)print(driver.title) sleep(3) #关闭浏览器driver.quit() 三、浏览器操作的方法1.浏览器的操作方法： 1 .浏览器窗口大小设置：set_window_size(宽,高) 2 .页面前进、后退：back()、forward() 3 .页面刷新：refresh() 2. 案例：访问京东页面和京东男装页面 打开京东，等 2 秒 打开京东男装，设置窗口为(400,800) 刷新一下页面，等 2 秒 后退，等 2 秒 前进，等 2 秒 关闭窗口 3.实现代码： 123456789from selenium import webdriver from time import sleep driver=webdriver.Firefox()#打开京东 driver.get(&quot;https://www.jd.com&quot;) driver.maximize_window() sleep(2) #打开京东男装 driver.get(&quot;https://channel.jd.com/1315-1342.html&quot;) #设置页面的窗体大小 driver.set_window_size(400,800)#刷新一下页面 driver.refresh() sleep(2) #后退 driver.back() sleep(2)#前进 driver.forward() sleep(2) driver.quit() 四、元素的定位(1) 通过 id 选择器、****name 值去定位元素 打开网页 右击检查元素或者 F12 可以看到 id 与 name 案例：打开百度，输入”码云”，点击搜素按钮 1 打开百度网址 2 定位到输入框，输入“码云” 3 定位到搜素按钮，点击一下 4 打开搜素页面 实现代码： 123456789101112131415161718192021from selenium import webdriverfrom time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) #百度输入框的 id 名 kw driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;码云&quot;) #百度输入框的 name 属性值 kw #driver.find_element_by_name(&quot;wd&quot;).send_keys(&quot;码云&quot;) sleep(2) #百度的搜素按钮的 id 名为 su driver.find_element_by_id(&quot;su&quot;).click() 可以看出：.send_keys(“值”) 表示在输入框输入的值 (2) 通过通过标签名(tag_name)来定位 页面 html 文档下的各种标签： find_element_by_tag_name(“input”)； tag 往往用来定义一类功能，所以通过 tag 识别某个元素的概率 很低。任意打开一个页面，都会发现大量的、、等 tag，所以 tag name 定位很少用 (3) 通过 class_name 来定位 根据标签中属性 class 来进行定位的一种方法 案例： 1 打开百度 2 通过类名定位输入框，搜素“龟叔” 3 然后点击搜素，弹出搜素页面 实现代码： 12345from selenium import webdriver from time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) #百度输入框在类名 s_ipt 中 driver.find_element_by_class_name(&quot;s_ipt&quot;).send_keys(&quot;龟叔&quot;) sleep(2) driver.find_element_by_id(&quot;su&quot;).click() sleep(5) driver.quit() (4) 通过 link_Text 定位：专门用来定位文本链接 对象名.find_element_by_link_name(“text”)； 1#页面右上方的一些个人操作，比如退出、个人中心、消息通知等 driver.find_element_by_link_text(u&quot;退出&quot;).click() (5) XPath 定位：（了解） 对象名.find_element_by_xpath(“xpath 路径”)； 1）绝对路径定位： 对于没有 id，name、classname 不好定位的，可以通过 Firefox 可以方便的获取到 xpath 值 2） 利用元素属性定位： find_element_by_xpath(“.//[@id=’Title’]”)，这里是用的 id，也可以用元素其他能够唯一标识的属性，不局限于 id、name、 class 这些；代表的是标签名，不指定时就可以用*代替 3）层级与属性结合：下图中就是这种 案例代码： 123# 登录 driver.find_element_by_xpath(&quot;.//*[@id=&#x27;divword&#x27;]/input[7]&quot;).click()#个人页面的发布课程操作 driver.find_element_by_xpath(&quot;html/body/div[4]/div/div[2]/div/div[3]/a[1]&quot;).click() CSS 定位 Selenium 极力推荐使用 CSS 定位，而不是 XPath 来定位元素，原因是 CSS 定位比 XPath 定位速度快，语法也更加简洁。 (6) CSS 常用定位方法 find_element_by_css_selector（） #id id 选择器根据 id 属性来定位元素 class class 选择器，根据 class 属性值来定位元素 [attribute=’value’] 根据属性来定位元素 element&gt;element 根据元素层级来定位 父元素&gt;子元素 案例代码： 1234567891011from selenium import webdriver from time import sleepdriver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) #根据 id 来定位 driver.find_element_by_css_selector(&#x27;#kw&#x27;).send_keys(&quot;今日头条&quot;) #根据 class 定位 driver.find_element_by_css_selector(&#x27;.s_ipt&#x27;).send_keys(&#x27;python&#x27;) #通过属性来定位driver.find_element_by_css_selector(&quot;[autocomplete=&#x27;off&#x27;]&quot;).send_keys(&quot;selenium&quot;) sleep(2) driver.find_element_by_id(&#x27;su&#x27;).click() driver.get(&quot;http://www.toutiao.com&quot;) #通过元素层级来定位 driver.find_element_by_css_selector(&quot;form#loginForm&gt;ul&gt;input&quot;).send_keys(&quot;今日头条&quot;)sleep(2) driver.quit() (7) 下拉菜单定位 下拉菜单元素定位 案例：在今日头条登录页面选择指定的保留时间。 下面的案例可能会随着网页的内容改版，会失效，请参考思路。 1.根据选项元素标签定位 1234from selenium import webdriver from time import sleep from selenium.webdriver.support.ui import Select driver=webdriver.Firefox() driver.get(&quot;http://www.toutiao.com&quot;) sleep(2) #根据 option 标签来定位 driver.find_elements_by_tag_name(&#x27;option&#x27;)[1].click() driver.find_element_by_css_selector(&quot;[value=&#x27;2&#x27;]&quot;).click() sleep(2) driver.quit() 2.使用 Select 类定位 1234567from selenium import webdriverfrom time import sleep from selenium.webdriver.support.ui import Select driver=webdriver.Firefox() driver.get(&quot;http://www.toutiao.com&quot;) sleep(2) #利用 Select 类来进行定位 select = Select(driver.find_element_by_css_selector(&quot;[name=&#x27;CookieDate&#x27;]&quot;))select.select_by_index(2) select.select_by_visible_text(&quot;留一年&quot;) select.select_by_value(&quot;1&quot;)sleep(2) driver.quit() 五、鼠标键盘的操作1. 实现思路 需要引入 ActionChains 类 然后定位相关元素 在 ActionChains().调用相关鼠标操作方法 123456789from selenium import webdriverfrom selenium.webdriver.common.action_chains import ActionChains from time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) driver.maximize_window() driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(&quot;Python&quot;) # 获取搜索框元素对象 element=driver.find_element_by_css_selector(&quot;#kw&quot;) sleep(3) #双击操作 ActionChains(driver).double_click(element).perform() sleep(2) #右击操作 ActionChains(driver).context_click(element).perform() sleep(3)#鼠标悬停 above=driver.find_element_by_css_selector(&quot;.pf&quot;) ActionChains(driver).move_to_element(above).perform() sleep(4) driver.quit() 2. 键盘操作 案例： 在百度搜索关键词“Python” 然后将关键词复制或剪切到搜狗搜索框进行搜索 1234567891011121314from selenium import webdriver from selenium.webdriver.common.keys import Keys from time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(&quot;Python&quot;) sleep(2) #键盘全选操作 Ctrl+A driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(Keys.CONTROL,&#x27;a&#x27;) #键盘选择复制或剪切操作 Ctrl+C driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(Keys.CONTROL,&#x27;c&#x27;) driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(Keys.CONTROL,&#x27;x&#x27;)#打开搜狗页面 driver.get(&quot;http://www.sogou.com/&quot;) sleep(2) #粘贴复制内容 driver.find_element_by_css_selector(&quot;.sec-input&quot;).send_keys(Keys.CONTROL,&#x27;v&#x27;) sleep(2) #点击搜索按钮 # driver.find_element_by_xpath(&quot;//input[@id=&#x27;stb&#x27;]&quot;).click() driver.find_element_by_css_selector(&quot;#stb&quot;).click() sleep(3) driver.quit() 3. 元素的等待 显示等待是针对某一个元素进行相关等待判定； 隐式等待不针对某一个元素进行等待，全局元素等待。 a.相关模块 WebDriverWait 显示等待针对元素必用 expected_conditions 预期条件类（里面包含方法可以调用，用于显示等待） NoSuchElementException 用于隐式等待抛出异常 By 用于元素定位 123456from selenium import webdriverfrom selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait #注意字母大写 from selenium.webdriver.support importexpected_conditions as EC from selenium.common.exceptions import NoSuchElementException b.显示等待 案例：检测百度页面搜索按钮是否存在，存在就输入关键词“Selenium” 然后点击搜索 123456789from selenium import webdriverfrom selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By from time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(&quot;Selenium&quot;)sleep(2)#显示等待--判断搜索按钮是否存在 element=WebDriverWait(driver,5,0.5).until(EC.presence_of_element_located((By.ID,&quot;su&quot;))) element.click() sleep(3)driver.quit() C.隐式等待 123456789101112from selenium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionfrom time import sleep,ctime driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) sleep(2) driver.implicitly_wait(5) #隐式等待时间设定 5 秒#检测搜索框是否存在 try: print(ctime()) driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(&quot;Python&quot;) driver. find_element_by_css_selector(&quot;#su&quot;).click except NoSuchElementException as msg: print(msg) finally: print(ctime())sleep(3) driver.quit() 六、警告弹窗的处理 案例：点击百度首页设置按钮，然后进入搜索设置页面， 点击“保存设置”或“恢复默认”按钮，处理警告弹窗窗口 12345678from selenium import webdriver from time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) driver.find_element_by_link_text(&#x27;设置&#x27;).click() sleep(2) driver.find_element_by_link_text(&#x27;搜索设置&#x27;).click() sleep(3)driver.find_element_by_link_text(&#x27;保存设置&#x27;).click() # driver.find_element_by_link_text(&#x27;恢复默认&#x27;).click() sleep(3)#处理警告窗口 alert=driver.switch_to_alert() alert.accept() sleep(2) sleep(2) driver.quit() 七、文件上传 案例：在百度搜索上传本地图片进行搜索。 12345678from selenium import webdriverfrom time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;)driver.find_element_by_css_selector(&quot;.soutu-btn&quot;).click() sleep(3) driver.find_element_by_css_selector(&quot;.upload-pic&quot;).send_keys(r&quot;E:\\Python_script\\Web driver\\shuiyin.png&quot;) sleep(3) # driver.quit() 八、浏览器滚动操作 案例：打开京东页面，然后将滚动条拖到最底部，然后再拖到顶部 1234567891011from selenium import webdriverfrom time import sleep driver=webdriver.Firefox() driver.get(&quot;https://www.jd.com/&quot;) sleep(2)#将滚动调拖到最底部 js=&quot;var action=document.documentElement.scrollTop=10000&quot; driver.execute_script(js)sleep(2) #将滚动条拖到最顶部 js=&quot;var action=document.documentElement.scrollTop=0&quot; driver.execute_script(js) sleep(3)driver.quit() 九、网页自动截图 案例：打开百度页面，然后进行截图 12345678from selenium import webdriver from time import sleep #加载浏览器驱动 driver=webdriver.Firefox()#打开百度页面并截图driver.get(&quot;http://www.baidu.com&quot;) driver.get_screenshot_as_file(r&quot;E:\\Python_script\\baidu.png&quot;) sleep(2) driver.quit() 十、Cookie 处理1. 什么是 cookie Cookie 是储存在用户本地终端上的数据，实际上是一小段的文本信息。 2. Cookie 的作用 帮助 Web 站点保存有关访问者的信息，方便用户的访问。 如记住用户名密码实现自动登录。 案例：查看访问京东时的 Cookie 内容 12345678from selenium import webdriver driver=webdriver.Firefox() driver.get(&quot;http://www.jd.com/&quot;) #获取 cookie 全部内容 cookie=driver.get_cookies() #打印全部 cookile 信息 print(cookie) #打印 cookie 第一组信息 print(cookie[0]) driver.quit() 3. 验证码作用 不少网站在用户登录、用户提交信息等登录和输入的页面上使用了验证码技术。验证码 技术可以有效防止恶意用户对网站的滥用，使得网站可以有效避免用户信息失窃、保证网站 稳定安全性。 但是验证码给自动化测试带来一些不便，使脚本无法正常运行覆盖功能模块。 十一、验证码的处理 1.去掉验证码 这是最简单的方法，对于开发人员来说，只是把验证码的相关代码注释掉即可，如果 是在测试环境，这样做可省去了测试人员不少麻烦，如果自动化脚本是要在正式环境跑，这 样就给系统带来了一定的风险。 2.设置万能码 去掉验证码的主要是安全问题，为了应对在线系统的安全性威胁，可以在修改程序时不 取消验证码，而是程序中留一个“后门”—设置一个“万能验证码”，只要用户输入这个 “万能验证码”，程序就认为验证通过，否则按照原先的验证方式进行验证。 3.记录 cookie 通过向浏览器中添加 cookie 可以绕过登录的验证码。 十二、基于 Cookie 绕过验证码案例：使用 Cookie 绕过百度验证码自动登录账户。 12345678from selenium import webdriver from time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com/&quot;) #手动添加 cookie driver.add_cookie(&#123;&#x27;name&#x27;:&#x27;BAIDUID&#x27;,&#x27;value&#x27;:&#x27;9E4BF1D44014…(根据实际获取值填写)&#x27;&#125;) driver.add_cookie(&#123;&#x27;name&#x27;:&#x27;BDUSS&#x27;,&#x27;value&#x27;:&#x27;根据实际抓包获取值填写&#x27;&#125;) sleep(2) driver.refresh() sleep(3) driver.quit()","categories":[],"tags":[{"name":"webdriver","slug":"webdriver","permalink":"http://example.com/tags/webdriver/"}],"keywords":[]},{"title":"JavaScript","slug":"JavaScript","date":"2021-08-14T08:28:58.000Z","updated":"2021-09-04T10:06:41.848Z","comments":true,"path":"2021/08/14/JavaScript/","link":"","permalink":"http://example.com/2021/08/14/JavaScript/","excerpt":"","text":"一、什么是javascriptJavaScript 是可插入 HTML 页面的编程代码。 JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行 这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 Js三部分： es语法、浏览器[BOM]对象、文档【DOM】对象 二、Es语法1、js的快速入门——写法 内嵌在script标签 123&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;123&quot;) &lt;/script&gt; 外部链接 1&lt;script type=&quot;text/javascript&quot; src=&quot;../js/js1.js&quot; &gt;&lt;/script&gt; 2、js的输出 Document.write( ):输出内容在网页上面 Console.log(): 输出内容在控制台上面 3、变量、数据类型： 变量：程序执行中，其值可以改变的量；变量是一个容器，存储数据。 Var a=10; Var:声明变量的关键字 a是变量,在这个变量里面存了10 变量取名的时候注意： 123456&lt;script type=&quot;text/javascript&quot;&gt; //声明一个变量 var num1=false; //输出变量 document.write(num1) &lt;/script&gt; 数据类型： Boolean ——布尔 string ——字符串 Number ——数字 Underfind—— 未定义的数据类型 Js是一门弱类型的语言，数据类型的取值取决于赋给变量的值！！！ ① Js的声明变量关键字是var ② js同时声明两个不同的数据类型 ③ js变量可以存放不同类型的值 ④ js变量名声明不是必须的 typeof（）检测数据类型 12var num1=false;document.write(typeof(num1)) 4、js的运算符 算术： 加、减 、乘、除、++、– 单独给某个变量++或者–的时候，它会自增1或自减1； 比较：&gt;、&lt; &gt;= != &lt;= 区分： = :赋值 把右边赋值给左边 ==：比较两个值相等，不考虑数据类型 === ：考虑数据类型和值一样时，为true，否则false 结果只有两种，true和false 条件: var n3=(n2&gt;n1)?n2:n1; 解释：如果n2值大于n1，把n2的值赋给n3 否则相反 12345var n1=123; var n2=25; var n3=(n2&gt;n1)?n2:n1; document.write(n3)//25 逻辑: &amp;&amp; || ！ 逻辑运算符两边连接的是布尔类型的值 赋值： = += -= *= /= 把右边值赋值 运算符左边 5、程序的结构 程序的结构： 顺序结构【默认】：自上而下 选择结构： 程序自上而下执行时，遇到了什么条件，就会做出什么选择！ 循环结构 程序自上而下执行时，遇到了什么条件，就会做出循环 选择结构：if…else 12345678910//1.初始化值 var age=10; //2.判断条件 if(age&gt;=18)&#123; //3.执行语句1 document.write(&quot;可以上网&quot;) &#125;else&#123; //语句2 document.write(&quot;洗洗睡&quot;) &#125; for 循环： 12345678910111213循环——for 输出100句 你好 1.初始化值 var n=1; 2.循环的判断语句 n&lt;=100; 3.循环体语句 你好 4.控制循环语句 n++; for(初始化值;循环判断条件;控制循环语句)&#123; 循环体语句; &#125; for(var n=1;n&lt;=100;n++)&#123; document.write(&quot;你好&quot;); &#125; 6、数组 什么是数组？——数据的容器 存放一组数据(多个类型的) 长度不是固定 没有赋值定义的类型都是undefined 怎么声明数组？ var 数组名=new Array(); var 数组名=new Array(“值1”，”值2”) 1234&lt;script type=&quot;text/javascript&quot;&gt; var arr=new Array(&quot;张三&quot;,&quot;李四&quot;,123); document.write(arr.length) &lt;/script&gt; var 数组名=[“值1”,“值2”,”值3”] 数组结合循环来做遍历 1234567&lt;script type=&quot;text/javascript&quot;&gt; var arr=new Array(&quot;张三&quot;,&quot;李四&quot;,123);// document.write(arr[0]) for (var i=0;i&lt;arr.length;i++) &#123; document.write(arr[i]);//0 1 2 &#125; &lt;/script&gt; 7、字符串：“上海的自来水来自海上” CharAt():通过下标找单个字符 indexOf:字符串中某一个指定的字符首次出现的位置 12345&lt;script type=&quot;text/javascript&quot;&gt; var str=&quot;上海的自来水来自海上&quot;; //var n=str.charAt(0); document.write(str.indexOf(&quot;上&quot;)) &lt;/script&gt; [substring()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_substring.asp) 提取字符串中两个指定的索引号之间的字符。 包前不包后 详细用法： 手册——javascript——js字符串——详细用法 8、函数 函数是由事件驱动的 或者当他被调用时执行的可重复使用的代码块 系统函数与自定义 isNan() 值是数字给false，否则给true 字符串转换成数字： parseInt（） 格式： parseInt(转换的变量) 注意：字符串转换的数字只能是字符串开头的数字 parseFloat 案例： 前提：通过js代码输出html代码 1234567document.write(&quot;&lt;font size=&#x27;24&#x27; color=&#x27;red&#x27;&gt;文字&lt;/font&gt;&lt;br/&gt;&quot;) &lt;script type=&quot;text/javascript&quot;&gt; for (var i=1;i&lt;=10;i++) &#123; document.write(&quot;&lt;font size=&#x27;24&#x27; color=&#x27;red&#x27;&gt;文字&lt;/font&gt;&lt;br/&gt;&quot;) &#125; &lt;/script&gt; 请使用js来输出一个四行两列的表格！！！ 偶数行为绿色，奇数行为红色 自定义函数： 自己来写函数 如果你想让你的函数运行有效果，必须绑定事件【用户的动作——点击、打开了网页(加载)】 函数语法： function 函数名(){ //代码块 } 事件：用户的动作——点击 onclick——点击事件 先写好函数——这个函数具有什么功能？【里面代码块决定】 往html标签【如按钮】绑定事件【点击】同时加上函数名() 思路： 123456781.用html写出效果2.写个函数，通过点击事件绑定 “计算”按钮 A.先获取1-2框里面的值，判断是什么类型？string--&gt;number B.获取select的id--&gt;option的value--&gt;+ 、- 、* 、/ C.通过选择结构--&gt;根据用户选择+、-、*、/计算结果 if..else if ...else D.获取结果框的value,然后把计算结果赋值给它 代码： 参考计算器案例 9、date对象 日期对象用于处理日期和时间。 定义日期： var 对象名 = new Date()； 或 var 对象名 = new Date(“2020-04-10”)； 对象名.方法名() To方法组： [toDateString()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_toDateString.asp) 把 Date 对象的日期部分转换为字符串。 123456789&lt;script type=&quot;text/javascript&quot;&gt; //1.创建一个Date对象 var d=new Date(); //2.调用方法 var n=d.toDateString()//转换成字符串 document.write(typeof(n)) document.write(n) &lt;/script&gt; [toString()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_toString_date.asp) 把 Date 对象转换为字符串。 123456789&lt;script type=&quot;text/javascript&quot;&gt; //1.创建一个Date对象 var d=new Date(); //2.调用方法 var n=d.toString()//转换成字符串 document.write(typeof(n)) document.write(n) &lt;/script&gt; Get方法组： [getFullYear()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getFullYear.asp) 从 Date 对象以四位数字返回年份。 12345&lt;script type=&quot;text/javascript&quot;&gt; var d=new Date(); var y=d.getFullYear() document.write(y) &lt;/script&gt; [getDate()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getDate.asp) 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 [getDay()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getDay.asp) 从 Date 对象返回一周中的某一天 (0 ~ 6)。 [getMonth()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getMonth.asp) 从 Date 对象返回月份 (0 ~ 11)。 [getHours()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getHours.asp) 返回 Date 对象的小时 (0 ~ 23)。 [getMinutes()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getMinutes.asp) 返回 Date 对象的分钟 (0 ~ 59)。 [getSeconds()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getSeconds.asp) 返回 Date 对象的秒数 (0 ~ 59)。 [getMilliseconds()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getMilliseconds.asp) 返回 Date 对象的毫秒(0 ~ 999)。 [getTime()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getTime.asp) 返回 1970 年 1 月 1 日至今的毫秒数。 123456&lt;script type=&quot;text/javascript&quot;&gt; var d=new Date();// d.setDate(12); d.setMonth(1)//0 document.write(d) &lt;/script&gt; 10、math(算数)对象： 详细了解 [abs(x)](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_abs.asp) 返回数的绝对值。 X：表示参数 [floor(x)](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_floor.asp) 对数进行下舍入。 [ceil(x)](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_ceil.asp) 对数进行上舍入。 [max(x,y)](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_max.asp) 返回 x 和 y 中的最高值。 [min(x,y)](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_min.asp) 返回 x 和 y 中的最低值。 随机数： [random()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_random.asp) 返回 0 ~ 1 之间的随机数。 四舍五入： [round(x)](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_round.asp) 把数四舍五入为最接近的整数。 保留多少位小数： var d=12.345232;document.write(d.toFixed(3)) 三、BOM浏览器对象模型详细手册 1. 定义： 浏览器对象模型 (BOM)，使 JavaScript 有能力与浏览器“对话”、交互 浏览器对象模型（Browser Object Model）尚无正式标准。 2.BOM的分类 1.window对象———-是浏览器对象模型中的顶层对象 2.navigator对象———包含有关访问者的信息 3.screen对象————-包含用户屏幕的信息 4.history对象———–包含浏览器历史 5.location对象———-用于获取当前页面地址 6.document对象———-操作HTML标签、cookie 3.Window对象 所有浏览器都支持 *window* 对象。它表示浏览器窗口。 prompt函数：用户点击确定拿到输入内容，点击取消啥也没有 ​ 对话框 1234&lt;script type=&quot;text/javascript&quot;&gt; var n=prompt(&quot;请输入.....&quot;) document.write(n) &lt;/script&gt; alert函数——警告框 123&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;123&quot;) &lt;/script&gt; confirm函数——确认框 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; var n=confirm(&quot;你确定吗？&quot;)//返回结果布尔类型 if(n==true)&#123; for(var i=1;i&lt;=10;i++)&#123; alert(i) &#125; &#125;else&#123; document.write(&quot;你好呀&quot;) &#125; document.write(n) &lt;/script&gt; close函数 ​ 关闭顶层窗口 12345&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; window.close() &#125; &lt;/script&gt; open函数 ​ 格式： ​ window.open(“弹出窗口的url”,”窗口名称”,”窗口特征1=值,窗口特征2=值”); 1234567&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; for (var i=1;i&lt;=10;i++) &#123; window.open(&quot;https://www.baidu.com&quot;,i,&quot;height=200px,width=300px&quot;); &#125; &#125; &lt;/script&gt; 4.local对象 window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。 1234567&lt;script type=&quot;text/javascript&quot;&gt; document.write(location.search) document.write(location.href) document.write(location.host) document.write(location.port) document.write(location.protocol) &lt;/script&gt; search：？问号后面的 href：完整的 host:主机名 port:当前的端口号 protocol：返回当前的协议 1.加载一个新的网页——assign（url） 注意：历史记录有记录 ctrl+H 12345&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; location.assign(&quot;https://www.baidu.com&quot;) &#125; &lt;/script&gt; 2.刷新当前页面 reload() 12345&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; location.reload() &#125; &lt;/script&gt; 3.替换当前页面 ​ replace(url)——历史记录会覆盖现有的历史记录 5.history 对象 12345678&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; history.back()//后退 &#125; function fn2()&#123; history.forward()//前进 &#125; &lt;/script&gt; 6.navigator 对象的介绍 window.navigator 对象包含有关访问者浏览器的信息。 appName 属性返回浏览器的应用程序名称： appCodeName 属性返回浏览器的应用程序代码名称： appVersion 返回浏览器的平台和版本信息 navigator 详细说明 7.screen 对象包含有关用户屏幕的信息 width：宽度 height:高度 screen.availWidth 属性返回访问者屏幕的宽度，以像素计，减去诸如窗口工具条之类的界面特征。 8.延时器和定时器【重点】 设定的时间间隔之后来执行代码 而不是在函数被调用后立即执行 setTimeout() 未来的某时执行代码 1var t=setTimeout(&quot;javascript语句&quot;,毫秒) 案例代码：设置延时器与清除延时器 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; var t;//为什么t声明在这儿？？ function fn1()&#123; alert(&quot;123&quot;) &#125; function fn2()&#123; t=setTimeout(&quot;fn1()&quot;,3000); &#125; function fn3()&#123; clearTimeout(t); &#125; &lt;/script&gt; 定时器： tt=setInterval(函数名,毫秒值); ​ 当我隔多少秒调用这个函数，周期性的调用 clearInterval(tt) ​ 清除定时或者延时的效果用这个 四、dom对象详细手册","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}],"keywords":[]},{"title":"http协议","slug":"http协议","date":"2021-08-10T05:58:20.000Z","updated":"2021-09-04T06:48:19.562Z","comments":true,"path":"2021/08/10/http协议/","link":"","permalink":"http://example.com/2021/08/10/http%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"一、http协议简介1）协议简介超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的 一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了 提供一种发布和接收 HTML(超文本标记语言) 页面的方法。 HTTP 协议在网络 OSI 模型中属于应用层协议，应用层协议除了 HTTP 还有：FTP， SMTP，DNS，RIP，Telnet 等。 HTTP 协议工作于客户端—服务端架构上。浏览器作为 HTTP 客户端通过 URL(网址) 向 HTTP 服务端（即 Web 服务器） 发送请求。 2）什么是超文本？超文本英文名称叫做 Hypertext，我们在浏览器里面看到的网页就是超文本解析而成的， 其网页源代码是一系 列 HTML 代码，里面包含了一系列标签，如 img 显示图片，p 指定显 示段落等，浏览器解析这些标签后便形成了我们平常看到的网页，而这网页的源代码 HTML 就可以称作超文本。 例如我们在 Chrome 浏览器里面打开如百度页面，右键点击”查看源代码”，这些源代 码都是超文本。 3）什么是URL？我们在浏览器的地址栏里输入的网站地址叫做 URL (Uniform Resource Locator，统 一资源定位符)。就像每家每 户都有一个门牌地址一样，每个网页也都有一个 Internet 地 址（如：http://www.baidu.com）。 当你在浏览器的 地址框中输入一个 URL 或是单击一个超级链接时，URL 就确定了要浏 览的地址。浏览器通过超文本传输协议(HTTP)， 将 Web 服务器上站点的网页代码提取出 来，并翻译成漂亮的网页。 4）http 功能HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从服务器传输 超文本到本地浏览器的传输协议。 它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本 文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 5）http的特点无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户端的请求，并收到 客户端的应答后， 即断开连接。采用这种方式可以节省传输时间。 媒体独立：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可 以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 来传输。无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。如果服务 器不需要先前信 息，那么它的应答就比较快。但是缺少状态意味着如果后续处理需要前面 的信息，则它必须重传，这样可 能导致每次连接传送的数据量增大，此时可以设置缓存。 6）HTTP和HTTPS 的区别现在在浏览很多网站时，通过浏览器地址栏可以看到有的网站是 https 开头 （https://www.baidu.com/ ）, 但是 有的是 http 开头（如： http://www.weather.com.cn ）这两种有什么区别呢？难道加了 s 就是复数吗？ HTTPS 的全称是 Hyper Text Transfer Protocol over Secure Socket Layer，是以 安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层（Secure Sockets Layer 安全套接层），简称为 HTTPS。 S 其实是 Security 单词的首字母 HTTPS 的安全基础是 SSL，因此通过它传输的内容都是经过 SSL 加密的，它的主要作用 可以分为两种： 是建立一个信息安全通道，来保证数据传输的安全。 确认网站的真实性，凡是使用了 https 的网站，都可以通过点击浏览器地址栏的锁头标 志来查看网站认证之 后的真实信息，也可以通过 CA 机构颁发的安全签章来查询。现在越来越多的网站和 APP 都已经向 HTTPS 方向发展。例如：谷歌从 2017 年 1 月推出的 Chrome 56 开始， 对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户“此网页不安全”。 7）http与tcp/ip的特点：TCP/IP 协议是传输层协议，主要解决数据如何在网络中传输，而 HTTP 是应用层协 议，主要解决如何包装数据。 关于 TCP/IP 和 HTTP 协议的关系，网络有一段比较容易理解的介绍：“我们在传输 数据时，可以只使用（传输层） TCP/IP 协议，但是那样的话，如果没有应用层，便无法 识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很 多，比如 HTTP、FTP、TELNET 等，也可以自己定义应用层协议。 WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做 传输层协议将它发到网络上。” 二、http请求我们在浏览器输入百度首页的地址：https://www.baidu.com/ 输入之后浏览器会给 我们打开百度首页。 实际上这 个过程是浏览器向网站所在的服务器发送了一个 Request，即请求，网站服 务器接收到这个 Request 之后进行处 理和解析，然后返回对应的一个 Response，即响 应，然后传回给浏览器，Response 里面就包含了页面的源代码等内容，浏览器再对其进行解析便将网页呈现了出来。 例子：使用火狐浏览器，打开百度，查看页面的请求过程 点击呈现详细步骤 1）请求的四部分•Request Method: 请求方式 •Request URL: 请求链接 •Request Headers: 请求头 •Request Body: 请求体 2）请求方式—抓用户名和密码请求方式，常见的两种类型： GET 用于信息获取，而且应该是安全的和幂等的(幂等的的意思就是一个操作不会修改 状态信息，并且每次操作的时候都返回同样的结果。) 从发送请求的角度，GET 请求相当 于我们在数据库中做了查询的操作， 这样的操作不影响数据库本身的数据。 POST 表示可能会修改服务器上资源的请求，也相当于在数据库中做了修改的操作， 会影响数据库本身的数据（比如：注册了账户，发了帖子，做了评论，得到了积分等。这种 情况下，资源状态被改变了）。 案例： get请求： 1在浏览器地址栏输入：https://www.baidu.com/s?wd=appium并回车,这个其实就是在百度搜索appium这个关键词。URL中包含了请求的参数信息，这里参数wd就是要搜寻的关键字 post请求： 1234一般来说，网站登录验证的时候，需要提交用户名密码，这里包含了敏感信息，使用 GET 方式请求的话密码就会 暴露在 URL 里面，造成密码泄露，所以这里最好以 POST 方 式发送。文件的上传时，由于文件内容比较大，也会 选用 POST 方式。比如百度账户登 录，如下图所示： 例如：使用火狐浏览器抓用户名和密码 当然也可以使用fiddler抓包 3）请求网址（url）Request URL 就是请求的网址，即统一资源定位符，用 URL 可以唯一确定我们想请求的资源。 比如： https://www.baidu.com/ 4）请求头（request headers）请求头，用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、Referer、 User-Agent 等，下面将一些 常用的头信息说明如下： 123456789Accept，请求报头域，用于指定客户端可接受哪些类型的信息。 • Accept-Language，指定客户端可接受的语言类型。 • Accept-Encoding，指定客户端可接受的内容编码。 • Host，用于指定请求资源的主机 IP 和端口号，其内容为请求 URL 的原始服务器或网关 的位置。从 HTTP 1.1 版本开始，Request 必须包含此内容。 • Cookie，也常用复数形式 Cookies，是网站为了辨别用户进行 Session 跟踪而储存在 用户本地的数据。Cookies 的主要功能就是维持当前访问会话。 • Referer，此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做 相应的处理，如 做来源统计、做防盗链处理等。 • User-Agent，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统 及版本、浏览器 及版本等信息。 • Content-Type，即 Internet Media Type，互联网媒体类型，也叫做 MIME 类型，在 HTTP 协议消息头 中，使用它来表示具体请求中的媒体类型信息。例如 application/x-www-form-urlencoded 表示表单数 据， text/html 代表 HTML 格式， image/gif 代表 GIF 图片，application/json 代表json文件 5）请求体即请求体，一般用于 POST 请求中，主要定义向服务器提交的数据类型，而对于 GET 请求 Request Body 则为 空。 比如在登录之前我们填写了用户名和密码信息，提交时就这些内容就会以 Form Data 的形式提交给服务器，此时注意 Request Headers 中指定了 Content-Type 为 application/x-www-form-urlencoded。 Postman看 只有设 置 Content-Type 为 application/x-www-form-urlencoded 才会以 Form Data 形式提交，另外我们也可以 将 Content-Type 设置为 application/json 来 提交 Json 数据，或者设置为 multipart/form-data 来上传文件。 常用 Content-Type 和 POST 提交数据方式的关系： Content-Type 提交数据方式 application/x-www-form-urlencoded Form表单提交 multipart/form-data 表单文件上传提交 application/jason 序列化Json数据提交 text/html XML数据提交 三、http的响应1）响应的三部分上述内容讲述的 http 协议的请求，接着描述 http 协议的响应。 Response，即响应，由服务端返回给客户端。Response 可以划分为三部分: • Response Status Code ：响应状态码 • Response Headers ：响应头 • Response Body ：响应提 Response Status Code 响应状态码，此状态码表示了服务器的响应状态，如 200 则代表服务器正常响应，404 则代表页面未找到，500 则 代表服务器内部发生错误。常用响应状态码如下： 可以参考完整的 http 协议的响应状态码： 响应状态码的含义 1XX： 请求未完成 2XX: 表示响应成功 3XX：表示转发/重定向 4XX: 路径找不到 5XX：服务器内部资源错误 2）响应头响应头，其中包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等，下面将一些常用的头信息说明如下： *Date，标识 Response 产生的时间。 Last-Modified，指定资源的最后修改时间。 •Content-Encoding，指定 Response 内容的编码。 •server，包含了服务器的信息，名称，版本号等。 •Content-Type，文档类型，指定了返回的数据类型是什么，如 text/html 则代表返回 HTML 文档， application/x-javascript 则代表返回 JavaScript 文件，image/jpeg 则 代表返回了图片。 • Set-Cookie，设置 Cookie，Response Headers 中的 Set-Cookie 即告诉浏览器需要 将此内容放在 Cookies 中，下次请求携带 Cookies 内容。 **• Expires,**指定 Response 的过期时间，使用它可以控制代理服务器或浏览器将内容更 新到缓存中，如果再 次访问时，直接从缓存中加载，降低服务器负载，缩短加载时间。 3）响应体即响应体，响应的正文数据都是在响应体中，如请求一个网页，它的响应体就是网页的 HTML 代码，请求一张图 片，它的响应体就是图片的二进制数据。","categories":[],"tags":[{"name":"http协议","slug":"http协议","permalink":"http://example.com/tags/http%E5%8D%8F%E8%AE%AE/"}],"keywords":[]},{"title":"软件测试入门","slug":"软件测试入门","date":"2021-07-08T06:25:52.000Z","updated":"2021-09-08T11:36:29.541Z","comments":true,"path":"2021/07/08/软件测试入门/","link":"","permalink":"http://example.com/2021/07/08/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、软件研发流程1. 软件产品的特点a. 是一种逻辑产品，与物质产品有很大的区别。 b. 软件产品的生产主要是研制，生产成本主要在开发和研制，开发研制完成后，通过复制就产生了大量软件产品。 c. 软件产品不会用坏，不存在磨损，消耗。 d. 生产主要是脑力劳动，还末完全摆脱手工开发方式，大部分产品是”定做”的。 2. 软件工程软件工程：系统化、规范化、可管理、将软件开发变成一项工程。 软件工程亟需解决的问题： 软件开发进度难以预测 软件开发成本难以控制 用户对产品功能难以满足 软件产品质量无法保证 软件产品难以维护 软件缺少适当的文档资料 3. 软件的开发模型1）瀑布模型 瀑布模型是一种线形的、顺序的软件开发模型，主要分为6个阶段:可行性计划研究→需求分析→软件设计→编码→测试→运行维护 在瀑布模型中，软件开发的各项活动严格按照这条线进行，只有当一个阶段任务完成之后才能开始下一个阶段。软件开发的每一个阶段都要有结果产出，结果经过审核验证之后作为下一个阶段的输入，下个阶段才可以顺利进行。如果结果审核验证不通过，则需要返回修改。 瀑布模型为整个项目划分了清晰的检查点，当一个阶段完成之后，只需要把全部精力放置在后面的开发上即可，它有利于大型软件开发人员的组织管理及工具的使用与研究，可以提高开发的效率。 但是瀑布模型是严格按照线性方式进行的，无法适应用户需求变更，用户只能等到最后才能看到开发成果，增加了开发风险。如果开发人员与客户对需求理解有偏差，到最后开发完成后，最终成果与客户需求可能会差之千里。使用瀑布模型开发软件时，如果早期犯的错误在项目完成后才发现，此时再修改原来的错误需要付出巨大的代价。瀑布模型要求每一个阶段必须有结果产出，这就势必增加了文档的数量，使软件开发的工作量变大。 2）V模型 V 模型从左到右，描述了基本的开发过程和测试行为，明确地标明了测试工程中存在的不同级别以及测试阶段和开发过程各阶段的对应关系。图中箭头代表了时间方向，左边下降的是开发过程各阶段，与此相对应的是右边上升的部分，即测试过程各阶段。 V 模型指出，单元和集成测试是验证程序设计，单元测试主要由白盒测试工程对代码进行测试，但目前国内真正做白盒测试的企业不多。这主要有两大原因：第一，白盒测试投入的成本很高，并且产出不明显，很多企业不希望投入更多的资源去做这项工作;第二，白盒测试对测试工程师的要求较高，在目前系统测试还没有完全成熟的情况下很难真正地开展白盒测试。而集成测试是介于白盒测试与系统测试之间的一种测试，也叫灰盒测试，由于它与白盒测试和系统测试之间没有明显的界限，所以在实际的测试过程中，即使开展集成测试也是由系统测试工程师来完成。 系统测试主要验证系统设计，检测系统功能、性能的质量特性是否达到系统设计的指标，由测试人员和用户进行软件的确认测试和验收测试，以及对需求说明书进行测试，以确定软件的实现是否满足用户需求或合同要求。 V 模型存在一定的局限性，它把测试过程作为在需求分析、概要设计、详细设计及编码之后的一个阶段。如果不做白盒测试，那么其实都是在系统完成集成后才开始系统测试的，这样需求分析阶段隐藏的问题一直到后期的验收测试才被发现，因此修改缺陷的成本就高了很多。 3）快速原型模型 快速原型模型与瀑布模型正好相反，它在最初确定用户需求时快速构造岀一个可以运行的软件原型，这个软件原型向用户展示待开发软件的全部或部分功能和性能，客户对该原型进行审核评价，然后给出更具体的需求意见，这样逐步丰富细化需求，最后开发人员与客户达成最终共识，确定客户的真正需求。确定客户的真正需求之后，开始真正的软件开发。 ****快速原型模型类似于建造房子，确定客户对房子的需求之后快速地搭建一个房子模型****，由客户对房子模型进行评价，房子的样式、功能、布局等是否满足需求，哪里需要改进等，最后确定了客户对房子的要求，就开始真正地建造房子。 与瀑布模型相比，快速原型模型克服了需求不明确带来的风险，适用于不能预先确定需求的软件项目。但快速原型模型关键在于快速构建软件原型，准确地设计出软件原型存在定的难度。此外，这种开发模型也不利于开发人员对产品进行扩展。 4）迭代模型 迭代模型又称为增量模型或演化模型，它将一个完整的软件拆分成不同的组件，然后逐个组件地开发测试，每完成一个组件就展现给客户，让客户确认这一部件功能和性能是否达到客户需求，最终确定无误，将组件集成到软件体系结构中。 整个开发工作被组织为一系列短期、简单的小项目，称为一系列迭代，每一个迭代都需要经过需求分析→软件设计→编码→测试的过程 在迭代模型中，第一个迭代(即第一个组件)往往是软件基本需求的核心部分，第一个组件完成之后，经过客户审核评价形成下一个组件的开发计划，包括对核心产品的修改和新功能的发布，这样重复迭代步骤直到实现最终完善的产品。 迭代模型可以很好地适应客户需求变更，它逐个组件地交付产品，客户可以经常看到产品，如果某个组件没有满足客户需求，则只需要更改这一个组件，降低了软件开发的成本与风险。但是选代模型需要将开发完成的组件集成到软件体系结构中，这样会有集成失败的风险，因此要求软件必须有开放式的体系结构。此外，迭代模型逐个组件地开发修改，很容易退化为“边做边改”的开发形式，从而失去对软件开发过程的整体控制。 5）螺旋模型 该模型融合了瀑布模型、快速原型模型，它最大的特点是引入了其他模型所忽略的风险分析，如果项目不能排除重大风险，就停止项目从而减小损失。这种模型比较适合开发复杂的大型软件。 螺旋模型将整个项目开发过程划分为几个不同的阶段，每个阶段按部就班地执行，这种划分方式采用了瀑布模型。每个阶段在开始之前都要进行风险评估，如果能消除重大风险则可以开始该阶段任务。在每个阶段，首先构建软件原型，根据快速原型模型完成这个迭代过程，产出最终完善的产品，然后进入下一个阶段，同样下一个阶段开始之前也要进行风险评估，这样循环往复直到完成所有阶段的任务。螺旋模型的若干个阶段是沿着螺线方式进行的。 4个象限:制订计划、风险分析、实施工程、客户评估，各象限含义如下。 (1)制订计划:确定软件目标，制订实施方案，并且列出项目开发的限制条件。 (2)风险分析:评价所制订的实施方案，识别风险并消除风险。 (3)实施工程:开发产品并进行验证 (4)客户评估:客户对产品进行审核评估，提出修正建议，制订下一步计划。 在螺旋模型中，每一个选代都需要经过这4个步骤，直到最后得到完善的产品，可以进行提交。 螺旋模型强调了风险分析，这意味着对可选方案和限制条件都进行了评估，更有助于将软件质量作为特殊目标融入产品开发之中。它以小分段构建大型软件，使成本计算变得简单容易，而且客户始终参与每个阶段的开发，保证了项目不偏离正确方向，也保证了项目的可控制性。 4. 软件开发生命周期软件和其他产品一样，都有一个从“出生”到“消亡”的过程，这个过程称为软件的生命周期。在软件的生命周期中，软件测试是非常重要的一个环节。 软件生命周期分为多个阶段，每个阶段有明确的任务，这样就使得结构复杂、管理复杂的软件开发变得容易控制和管理。通常，可将软件生命周期划分为6个阶段。 每个阶段的目标任务及含义分别介绍如下。 第1阶段:问题定义，该阶段由软件开发方与需求方共同讨论，主要确定软件的开发目标及其可行性。 第2阶段:需求分析，该阶段对软件需求进行更深入的分析，划分出软件需要实现的功能模块，并制作成文档。需求分析在软件的整个生命周期中起着非常重要的作用，它直接关系到后期软件开发的成功率。在后期开发中，需求可能会发生变化，因此，在进行需求分析时，应考虑到需求的变化，以保证整个项目的顺利进行。 第3阶段:软件设计，该阶段在需求分析结果的基础上，对整个软件系统进行设计，如系统框架设计、数据库设计等。 第4阶段:软件开发，该阶段在软件设计的基础上，选择一种编程语言进行开发。在开发过程中，必须要制订统一的、符合标准的程序编写规范，以保证程序的可读性、易维护性以及可移植性。 第5阶段:软件测试，该阶段是软件开发完成后对软件进行测试，以查找软件设计与软件开发过程中存在的问题并加以修正。软件测试过程包括单元测试、集成测试、系统测试、验收测试等4个阶段;测试的方法以黑盒测试、白盒测试或者两者结合的形式进行。在测试过程中，为减少测试的随意性，需要制订详细的测试计划并严格遵守;测试完成之后，要对测试结果进行分析并对测试结果以文档的形式汇总。 第6阶段:软件维护，软件完成测试并投入使用之后，面对庞大的用户群体，软件可能无法满足用户使用需求，此时就需要对软件进行维护升级以延续软件的使用寿命。软件的维护包括纠错性维护和改进性维护两个方面。软件维护是软件生命周期中持续时间最长的阶段。 5. 项目团队里面的成员及其职责项目经理：驱动整个项目的运转，负责制定计划，安排人力，管理进度，协调团队，进行重大决策。 架构师 / 系统工程师：技术专家，经验丰富，负责整个系统的体系架构的设计以及关键模块的设计。 程序员 / 开发人员：设计、编写软件，并修复软件中的缺陷。 测试工程师：负责找出软件产品存在的问题并报告。 实施/运维工程师：负责软件系统安装部署、升级维护。 资料工程师：负责编写软件产品附带的文件和联机帮助文档 配置管理员：负责管理程序员写的代码和资料工程师写的文档资料，并组合成一个软件包。 QA：质量监管人员 二、软件测试的基础理论1. 软件测试的定义软件测试是使用人工或者自动手段运行或测定某个系统的过程，检验系统是否满足规定的需求，并找出预期结果与实际结果的差异。 2. 测试的对象根据软件的定义，软件包括程序、文档，所以软件测试并不仅仅是程序测试。软件测试贯穿于整个软件生命周期中。 由于在整个软件生命周期中，各阶段有不同的测试对象，形成了不同开发阶段的不同类型的测试。需求分析、概要设计、详细设计以及程序编码等各阶段产生的文档，包括需求规格说明、概要设计规格说明、详细设计规格说明以及源程序，都应作为“软件测试”的对象。 3. 软件测试的目的1) 预防缺陷，减少产品的风险：对于软件开发来说，软件测试通过找到的问题缺陷帮助开发人员找到开发过程中存在的问题，包括软件开发的模式、工具、技术等方面存在的问题与不足，预防下次缺陷的产生。 2) 发现被测对象与用户需求之间的差异（俗称找BUG） 3) 通过测试活动发现并解决缺陷，增加人们对被测对象的质量信心； 4) 通过测试活动，发现被测对象的质量信息，为决策者提供数据依据； 4. 软测测试所遵循的原则 测试应该基于客户的需求 所有的测试工作都应该建立在满足客户需求的基础上，从客户角度来看，最严重的错误就是软件无法满足要求。有时候，软件产品的测试结果非常完美，但却不是客户最终想要的产品，那么软件产品的开发就是失败的，而测试工作也是没有任何意义的。因此测试应依照客户的需求配置环境，并且按照客户的使用习惯进行测试并评价结果。 测试要尽早进行 软件的错误存在于软件生命周期的各个阶段，因此应该尽早开展测试工作，把软件测试贯穿到软件生命周期的各个阶段中，这样测试人员能够尽早地发现和预防错误，降低错误修复的成本。尽早地开展测试工作有利于帮助测试人员了解软件产品的需求和设计，从而预测测试的难度和风险，制订出完善的计划和方案，提高测试的效率。 穷尽测试是不可能的 由于时间和资源的限制，进行完全(各种输入和输出的全部组合)的测试是不可能的测试人员可以根据测试的风险和优先级等确定测试的关注点，从而控制测试的工作量，在测试成本、风险和收益之间求得平衡。 测试缺陷要符合“二八”定理 缺陷的“二八”定理也称为Pareto原则、缺陷集群效应，一般情况下，软件80%缺陷会集中在20%模块中，缺陷并不是平均分布的。因此在测试时，要抓住主要矛盾，如果发现某些模块比其他模块具有更多的缺陷，则要投入更多的人力、精力重点测试这些模块以提高测试效率。 杀虫剂的悖论 我们都知道虫子的抗药性原理，即一种药物使用久了，虫子就会产生抗药性。而在软件测试中，缺陷也是会产生免疫性的。同样的测试用例被反复使用，发现缺陷的能力就会越来越差;测试人员对软件越熟悉越会忽略一些看起来比较小的问题，发现缺陷的能力也越差，这种现象被称为软件测试的“杀虫剂”现象。它主要是由于测试人员没有及时更新测试用例或者是对测试用例和测试对象过于熟悉，形成了思维定式。 要克服这种情况，就要不断对测试用例进行修改和评审，不断增加新的测试用例，同时，测试人员也要发散思维，不能只是为了完成测试任务而做一些输入和输出的对比。 没有缺陷的软件是不存在的 没有缺陷的软件是不存在的，软件测试是为了找出软件中的缺陷，而不是为了证明软件没有缺陷。 5. 测试的风险软件测试中的软件风险分析是根据预测软件将出现的风险，制定软件测试计划并排列优先等级，风险分析是对软件中潜在的问题进行识别、估计和评价的过程。 风险也包括进度风险、质量风险、人员风险、变更风险、成本风险等 6. 软件的质量 软件质量就是“软件与明确的和隐含的定义的需求相一致的程度” 明确的需求指：软件符合明确叙述的功能和性能需求、文档中明确描述的开发标准； 隐性的需求指：所有专业开发的软件都应具有的隐含特征的程度，需要引导的用户需求。 软件的质量特点 功能性：软件在指定条件下使用时，满足用户明确和隐含需求的功能的能力 可靠性：软件在指定条件下使用时，维持规定的性能级别的能力 易用性：在指定条件下使用时，软件被理解、学习、使用和吸引用户的能力 可维护：软件从一种环境迁移到另外一种环境的能力 那些原因影响软件的质量 由于软件自身的特点和目前的软件开发模式使得隐藏在软件内部的质量缺陷无法完全根除,因此每一款软件都会存在一些质量问题。影响软件质量的因素有很多,下面介绍几种比较常见的影响因素。 a. 需求模糊 在软件开发之前,确定软件需求是一项非常重要的工作,它是后面软件设计与软件开发的基础,也是最后软件验收的标准。但是软件需求是不可视的,往往也说不清楚,导致产品设计、开发人员与客户存在一定的理解误差,开发人员对软件的真正需求不明确,结果开发出的产品与实际需求不符,这势必会影响软件的质量。 除此之外,在开发过程中客户往往会一而再再而三地变更需求,导致开发人员频繁地修改代码,这可能会导致软件在设计时期存在不能调和的误差,最终影响软件的质量。 b. 开发过程不规范 现代软件开发,大多数团队都将精力放在开发成本与开发周期上,而不太重视团队成员的工作规范,导致团队成员开发“随意性”比较大,这也会影响软件质量,而且一旦最后软件出现质量问题,也很难定责,导致后期维护困难。 c. 软件开发人员问题 软件是由人开发出来的,因此个人的意识对产品的影响非常大。除了个人技术水平限制,开发人员问题还包括人员流动,新来的成员可能会继承上一任的产品接着开发下去,两个人的思维意识、技术水平等都会不同,导致软件开发前后不一致,进而影响软件质量。 d. 软件缺乏质量控制管理 在软件开发行业,并没有一个量化的指标去度量一款软件的质量,软件开发的管理人员更关注开发成本和进度,毕竟这是显而易见的,并且是可以度量的。但软件质量则不同,软件质量无法用具体的量化指标去度量,而且软件开发的质量并没有落实到具体的责任人,因此很少有人关心软件最终的质量。 2. 软件测试的分类目前，软件测试已经形成一个完整的、体系庞大的学科，不同的测试领域都有不同的测试方法、技术与名称，有很多读者可能也听过类似的黑盒测试、白盒测试、冒烟测试、单元测试等，其实它们是按照不同的分类方法而产生的测试名称。按照不同的分类标准，可以将软件测试分为很多不同的种类，下面我们详细介绍这些软件测试行业的专业名词。 按照测试阶段划分 ① 单元测试 单元测试是软件开发的第一步测试，目的是为了验证软件单元是否符合软件需求与设计。单元测试大多是开发人员进行的自测。 ② 冒烟测试 冒烟测试最初是从电路板测试得来的，当电路板做好以后，首先会加电测试，如果电路板没有冒烟再进行其他测试，否则就必须重新设计后再次测试。 后来这种测试理念被引入到软件测试中。在软件测试中，冒烟测试是指软件构建版本建立后，对系统的基本功能进行简单的测试，这种测试重点验证的是程序的主要功能，而不会对具体功能进行深入测试。 如果测试未通过，需要返回给开发人员进行修正;如果测试通过则再进行其他测试。因此，冒烟测试是对新构建版本软件进行的最基本测试。 ③ 集成测试 集成测试是冒烟测试之后进行的测试，它是将已经测试过的软件单元组合在一起测试它们之间的接口，用于验证软件是否满足设计需求。 ④ 系统测试 系统测试是将经过测试的软件在实际环境中运行，并与其他系统的成分(如数据库、硬件和操作人员等)组合在一起进行的测试。 ⑤ 验收测试 验收测试主要是对软件产品说明进行验证，逐行逐字地按照说明书的描述对软件产品进行测试，确保其符合客户的各项要求。 按照测试技术分类 按照使用的测试技术可以将软件测试分为黑盒测试与白盒测试。 ① 黑盒测试 不需要关注被测对象的内部结构，仅从用户需求的角度去考虑，是否满足显性或者隐性的需求。 ① 白盒测试 白盒测试又叫透明盒测试，它是指测试人员了解软件程序的逻辑结构、路径与运行过程，在测试时，按照程序的执行路径得出结果。白盒测试就是把软件(程序)当作一个透明的盒子，测试人员清楚地知道从输入到输出的每一步过程。 相对于黑盒测试来说，白盒测试对测试人员的要求会更高一点，他要求测试人员具有一定的编程能力，而且要熟悉各种脚本语言。但是在软件公司里，黑盒测试与白盒测试并不是界限分明的，在测试一款软件时往往是黑盒测试与白盒测试相结合对软件进行完整全面的测试。 按照软件质量分类 按照软件质量特性可以将软件测试分为功能测试与性能测试。 ① 功能测试 功能测试就是测试软件的功能是否满足客户的需求，包括准确性、易用性、适合性、互操作性等。 ② 性能测试 性能测试就是测试软件的性能是否满足客户的需求，性能测试包括负载测试、压力测试、兼容性测试、可移植性测试和健壮性测试。 按照自动化程度来分类 按照自动化程度可以将软件测试分为手工测试与自动化测试。 ① 手工测试 手工测试是测试人员一条一条地执行代码完成测试工作。手工测试比较耗时费力，而且测试人员如果是在疲惫状态下，则很难保证测试的效果。 ② 自动化测试 自动化测试是借助脚本、自动化测试工具等完成相应的测试工作，它也需要人工的参与，但是它可以将要执行的测试代码或流程写成脚本，执行脚本完成整个测试工作。 按照测试类型分类 软件测试类型有多种，包括界面类测试、功能测试、性能测试、安全性测试、文档测试等，其中功能测试与性能测试前面已经介绍，下面主要介绍其他几种测试。 ① 界面类测试 界面类测试是验证软件界面是否符合客户需求，包括界面布局是否美观、按钮是否齐全等。 ② 安全性测试 安全性测试是测试软件在没有授权的内部或外部用户的攻击或恶意破坏时如何进行处理，是否能保证软件与数据的安全。 ③ 文档测试 文档测试以需求分析、软件设计、用户手册、安装手册为主，主要验证文档说明与实际软件之间是否存在差异。 其他分类 还有一些软件测试无法具体归到哪一类，但在测试行业中也会经常进行这些测试，如α测试、β测试、回归测试等，具体介绍如下。 ① α测试 α测试是指对软件最初版本进行测试。软件最初版本一般不对外发布，在上线之前，由开发人员和测试人员或者用户协助进行测试。测试人员记录使用过程中出现的错误与问题整个测试过程是可控的。 ② β测试 β测试是指对上线之后的软件版本进行测试，此时软件已上线发布，但发布的版本中可能会存在较轻微的Bug，由用户在使用过程中发现错误与问题并进行记录，然后反馈给开发人员进行修复。 ③ 回归测试 当测试人员发现缺陷以后，会将缺陷提交给开发人员，开发人员对程序进行修改，修改之后，测试人员会对修改后的程序重新进行测试，确认原有的缺陷已经消除并且没有引入新的缺陷，这个重新测试的过程就叫作回归测试。回归测试是软件测试工作中非常重要的一部分，软件开发的各个阶段都会进行多次回归测试。 ④ 随机测试 随机测试是没有测试用例、检查列表、脚本或指令的测试，它主要是根据测试人员的经验对软件进行功能和性能抽查。随机测试是根据测试用例说明书执行测试用例的重要补充手段，是保证测试覆盖完整性的有效方式和过程。 一、软件测试的流程 测试需求分析阶段： 阅读需求，理解需求，主要就是对业务的学习，分析需求点，参与需求评审会议; 测试计划阶段： 根据自己的角色说明 如:测试经理主要任务就是编写测试计划，参考软件需求规格说明书，项目总体计划，内容包括测试范围(来自需求文档)，进度安排，人力物力的分配，整体测试策略的制定。风险评估与规避措施有一个制定。测试人员的话一般是领取分配的测试任务; 测试设计阶段： 主要是编写测试用例，会参考需求文档(原型图)，概要设计，详细设计等文档，用例编写完成之后会进行评审; 测试执行阶段： 搭建环境，执行冒烟测试(预测试)，然后进入正式测试，bug管理,根据公司情况进行日报,周报跟踪进度及风险控制; 测试评估阶段： 出测试报告，确认是否可以上线。 二、测试相关文档介绍在软件研发过程当中，会产生很多的文档，下面罗列测试阶段所产生的文档，包含但不仅限于如下文档。 文档的名称 包括但不限于以下内容 文档编写目的 测试计划 测试的范围、测试的准则、测试的手段、测试工具、停止的标准、硬/软件环境、测试规划、测试执行、工作量预估、资源安排、进度安排、风险管理等。 明确测试工作内容（范围）、测试工作的方法以及测试工作所需要的各种资源。 测试用例 用例编号、用例名称、测试背景、测试数据、操作步骤、预期结果、实际结果、优先级、重要级、编写人、执行人、备注等。 避免漏测、多测，能够对项目的需求做一个理解，可以作为测试人员工作量的一个考核。 缺陷报告 缺陷编号、缺陷描述、严重度、缺陷状态、发现人、发现时间、修复时间、所属版本、所属模块、修复的优先级、详细描述、下一步处理人等。 把软件存在的缺陷准确的描述出来，便于开发人员修正，反映了当前产品的质量状态，更是测试人员价值的体现。 测试报告 包括项目背景、需求分析、测试时间、测试环境、评审记录、测试范围、测试用例、功能实现清单、缺陷统计、测试统计(包含资源、执行、问题统计)、测试总结是否通过、测试的风险。 把测试的过程和结果写成文档，对发现的问题和缺陷进行分析，为纠正软件的存在的质量问题提供依据，同时为软件验收和交付打下基础。 测试日、周报 1.当前测试进度的关键性数据(用例执行进度、发现问题情况、待回归的问题)2.遇到哪些测试活动中不能解决的问题风险，需要什么样的帮助。3.下一阶段的工作计划是什么？ 要求内容是每日/周测试活动的概述，和下一天/周测试活动的计划，要求反映出当前测试进度，成果及问题。 三、svn服务器的搭建1. Svn版本控制工具的介绍Subversion(SVN) 是一个开源的版本控制系統, 这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。 SVN的作用相当于大家获取资源的公共平台，比如：开发会把自己的代码放到SVN中，你要测试的时候可以从SVN里下载最新的代码到本地进行测试，同时你的测试报告等也可以上传的SVN和其他的测试人员进行交流。 可以理解为Subversion(SVN)需要一个服务端（对文件集中管理——VisualSVN），普通用户安装客户端（TortoiseSVN ）方式来连接上服务器进行工作。 2. Svn服务器的安装与配置软件下载链接： https://www.visualsvn.com/files/VisualSVN-Server-4.3.3-x64.msi 安装步骤 1.首先把这个VisualSvn-server软件放到虚拟机里面 常规配置： 1. 进入服务端配置界面 2. 创建一个仓库 3.创建一个用户 4. 创建分组 六、Svn的基础使用1) 下载、安装软件下载链接： https://osdn.net/projects/tortoisesvn/storage/1.14.1/Application/TortoiseSVN-1.14.1.29085-x64-svn-1.14.1.msi/ 安装步骤: 基础使用： A. 检出：如何把服务器的文件，关联到本地文件夹。 准备： 服务器的地址、服务器已有用户、本地文件夹 先进入虚拟机查看计算机的ip地址 再从svn服务器复制url 开始从本地检出 当看到一个隐藏文件，则检出成功。 B.提交文件到服务器 提示：如果文件没有图标，重启一下电脑就可以了。 C. 更新文件 现在我删除掉本地“软件测试.txt”这个文件，此时，服务器上面还有这个文件，你只要在本地“update”一下，就能跟服务器上面保持一致。 D. 删除 现在我要把软件测试这个文件从当前svn服务器上面删除掉。 本地“更新(update)”一下，文件不见了，也看到提示消息。 然后我们再看下，svn文件服务器上面的内容，也没有了 E. 查看操作的日志 F. 版本回退 现在我本地的“软件测试”文件已经删除了，我要退回删除前，可以选择“更新至版本”。 G. 忽略文件 有时候某些目录或者文件我们不想提交到SVN服务器，这时我们可以忽略这些文件。 比如我们需要忽略，选中需要忽略的文件夹或者文件，右键，依次选择下面的菜单，就添加一条忽略了 H. 撤销本地修改 I. 修改仓库地址 快速更换：右键点击仓库根目录 =&gt; TortoiseSVN =&gt; relocate，修改仓库地址，点击确定后就修改好了 3) 图标的含义 说明：","categories":[],"tags":[{"name":"软件测试入门","slug":"软件测试入门","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/"}],"keywords":[]},{"title":"linux","slug":"linux","date":"2021-06-22T08:14:20.000Z","updated":"2021-09-22T11:15:21.136Z","comments":true,"path":"2021/06/22/linux/","link":"","permalink":"http://example.com/2021/06/22/linux/","excerpt":"","text":"一、Linux简介Linux 操作系统性能稳定，并且是开源的操作系统软件。它的防火墙相关的组件保证了系统的安全，且配置简单、性能高效。Linux 在很多企业网络中，追求速度和安全，它不仅仅是被网络运维人员当作服务器使用，也可以作为网络防火墙。Linux 开放源码并且没有版权，技术社区用户多等特点 ，开放源码使得用户可以自由裁剪，灵活性高，功能强大，成本低。尤其系统中内嵌网络协议栈 ，经过适当的配置就可实现路由器的功能。这些特点使得 Linux 成为开发路由交换设备的理想开发平台。 1.Linux特性基本思想Linux 的基本思想有两点：第一，一切都是文件；第二，每个文件都有确定的用途。 完全免费Linux 是一款免费的操作系统，用户可以通过网络或其他途径免费获得，并可以任意修改其源代码。 完全兼容 POSIX1.0 标准这使得可以在 Linux 下通过相应的模拟器运行常见的 DOS、Windows 操作系统中的软件程序。 多用户、多任务Linux 支持多用户，各个用户对于自己的文件设备有自己特殊的权利，保证了各用户之间互不影响。 良好的界面Linux 同时具有字符界面和图形界面。在字符界面用户可以通过键盘输入相应的指令来进行操作。它同时也提供了类似于 Windows 图形界面的 X-Window 系统，用户可以使用鼠标对其进行操作。在 X-Window 环境中就和在 Windows 中相似，可以说是一个 Linux 版的 Windows 操作系统。 支持多种平台Linux 可以运行在多种硬件平台上，如具有 x86、680x0、SPARC、Alpha 等处理器的平台。此外 Linux 还是一种嵌入式操作系统，可以运行在掌上电脑、机顶盒或游戏机上。 2.Linux优点Linux 由众多微内核组成，其源代码完全开源； Linux 继承了 UNIX 的特性，具有非常强大的网络功能，其支持所有的因特网协议，包括 TCP/IPv4、 TCP/IPv6 和链路层拓扑程序等，并且可以利用 UNIX 的网络特性开发出新的协议栈； Linux 系统工具链完整，简单操作就可以配置出合适的开发环境，可以简化开发过程，减少开发中仿真工具的障碍，使系统具有较强的移植性； 二、Linux发行版本1.DebianDebian 计划是一个致力于创建一个自由操作系统的合作组织。我们所创建的这个操作系统名为 Debian。操作系统是使计算机运行的基本程序和工具的集合，其中最主要的部分称为内核（kernel）。内核是计算机中最重要的程序，负责一切基本的调度工作，并让您运行其他程序。Debian 系统目前采用 Linux 内核或者 FreeBSD 内核。 2.RedHat红帽在 2014 年 6 月发布了最新旗舰版企业操作系统，红帽企业 Linux 7。基于红帽企业 Linux 7 操作系统，企业可整合裸机服务器、 虚拟机、基础设施即服务（IaaS）和平台即服务（PaaS），以构建一个强大稳健的数据中心环境，满足不断变化的业务需求。红帽卫星是一个综合性解决方案，它通过配置软件分发、补丁和配置管理，以及物理、虚拟和云环境的订阅管理为红帽系统提供完整的生命周期管理，为管理构建、部署、运行和淘汰系统所需的工具提供了单独的管理控制台和方法论。 3.CentosCentOS（Community Enterprise Operating System，中文意思是社区企业操作系统）是 Linux 发行版之一，它是来自于 Red Hat Enterprise Linux 依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以 CentOS 替代商业版的 Red Hat Enterprise Linux 使用。两者的不同，在于 CentOS 完全开源。 4.SlackwareSlackware Linux 是由 Patrick Volkerding 开发的 GNU/Linux 发行版。与很多其他的发行版不同，它坚持 KISS（Keep It Simple Stupid） 原则。一开始，配置系统会有一些困难，但是更有经验的用户会喜欢这种方式的透明性和灵活性。 Slackware 的很多特性体现出了 KISS 原则，最为有名的例子就是不依赖图形界面的文本化系统配置，传统的服务管理方式和不解决依赖的包管理。 5.UbuntuUbuntu 是一个以桌面应用为主的 Linux 操作系统，其名称来自非洲南部祖鲁语或豪萨语的 “ubuntu” 一词，意思是 “人性”、“我的存在是因为大家的存在”，是非洲传统的一种价值观。Ubuntu 基于 Debian 发行版和 Gnome 桌面环境，而从 11.04 版起，Ubuntu 发行版放弃了 Gnome 桌面环境，改为 Unity。从前人们认为 Linux 的难以安装、难以使用，在 Ubuntu 出现后这些都成为了历史。Ubuntu 也拥有庞大的社区力量，用户可以方便地从社区获得帮助。 三、centos目录介绍 目录名称 功能与作用描述 /bin 二进制应用程序目录，其中包含二进制文件 CentOS 系统所有用户使用的命令都在这个目录下。 /boot 开机启动引导目录，启动 (boot) 配置文件，其中包括了 Linux 内核文件与开机所需要的文件。 /dev 设备目录，设备 (device) 相关的文件和目录，其中包含了所有应用程序的配置文件，还包含了启动 / 停止某个程序的 shell 脚本。 /etc 配置文件目录，配置文件、启动脚本等文件。 /home 本地用户目录，所有不同权限的系统用户可在 home 目录分配存储个人用户的文件和资料。 /lib 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。 /lost+fount 系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于 /disk 中，此目录下就会自动产生目录 /disk/lost+found 。 /media **挂载可移动介质 (media)**，诸如 CD、数码相机，软盘，光盘等，可移除设备挂载目录。 /mnt 挂载 (mounted) 文件系统，临时安装目录，系统的管理员可拥有挂载文件系统的权限。 /opt 第三方软件安装目录，第三方应用程序一般放在此目录下，但实际中通常习惯放在 /usr/local 目录下。 /proc 特殊的动态信息目录，此目录的数据都在内存中，如系统核心，外部设备，网络状态，用以维护系统信息和状态，包括当前运行中进程 (processes) 信息。 /root root 用户主文件夹，读作 “slash-root” ，其他用户均放置在 /home 目录下 /run 系统运行的时候所需的文件，以前在 /var/run 中，后来拆分成独立的 /run 目录，重启后重新生成对应的目录数据。 /sbin 重要的系统二进制 (system binaries) 文件，也是包含的二进制可执行文件。在这个目录下的 linux 命令通常都是由系统管理员使用的，对系统进行维护。 /srv 服务启动后需要访问的数据目录。 /sys 系统 (system) 文件，跟 proc 一样虚拟文件系统，记录核心系统硬件信息。 /tmp 临时文件目录，存放临时文件目录，所有用户对该目录均可读写。 /usr 应用程序放置目录，包含绝大部分所有用户 (users) 都能访问的应用程序和文件。 /var 经常变化的 (variable) 文件，存放系统执行过程经常改变的文件，代表变量文件。在这个目录下可以找到内容可能增长的文件。 四、Linux常用指令1、ls查看文件和目录列表1.列出目录列表 ls:列出来的目录排序默认是按字母的列排序 2.列出有标记的目录列表 ls -F :列出的文件名称后面会加一个标识，其中 * 表示可执行文件，/ 表示目录，= 表示 socket 文件，@ 表示 软链接，| 表示 FIFOs 文件。 3.列出包含隐藏文件的列表 ls -a :列出当前目录包含隐藏文件的所有文件列表 4.使用多个参数列出文件列表 ls -F -R -a 或者ls -FRa 5.使用ll命令显示文件列表详细信息 ll 命令是 ls -l 的简写，它可以显示出文件的权限、属主、大小、最后修改时间等等信息 ll后显示信息： 5.1最左侧一列表示该文件的类型： · “-” 表示普通文件； · “d” 表示目录； · “l” 表示链接文件； · “p” 表示管理文件； · “b” 表示块设备文件。 5.2文件属性： 这里以 boot 目录为例，r-xr-xr-x 可以分为三部分 [r-x][r-x][r-x]，其中的第一部分表示文件创建者/所有者对该文件所具有的的权限，第二部分表示创建者/所有者所在的组其他用户的权限，第三部分表示其他组的用户的权限。 · r（Read，读取权限）：若是文件，则表示可以读取文件内容，若是目录，则表示可以浏览目录； · w（Write，写入权限）：若是文件，则表示可以新增、修改内容，若是目录，则表示可以删除、移动目录列表的权限； x（Execute，执行权限）：若是文件，则表示具有执行文件的权限，若是目录，则表示该用户拥有进入目录的权限。 5.3 目录/链接个数 如果是目录那么这里的数量减 2 表示它下级目录或者文件的个数。 如果是文件则表示指向它的链接文件的数量。 Tips：每个目录下面都包含有 . 和 .. 目录，其中 . 表示当前目录，.. 表示上级目录。文件链接相当于 windows里面的快捷方式。 5.4 文件所有者 其中 root root 可以分为两部分，[root] [root]，前面的 root 表示该文件或目录的所有者/创建者是 root 用户，后面的 root 表示该文件或目录所在的组是 root。 5.5 文件的大小 · 如果是则表示该文件的大小，单位是字节(byte)。 · 如果是目录则表示该目录所占的空间大小，并不是指该目录下所有文件的大小。 5.6 修改日期 表示最后修改的时间，以 boot 目录为例，表示最后修改或者创建时间是 4 月 19 日 12:27。 5.7 文件名称 表示文件名，其中 bin-&gt;usr/bin 表示软链接。 5.8 字体颜色 · 亮黄色表示设备文件； · 亮蓝色表示链接文件； · 灰蓝色表示目录； · 亮红色表示压缩文件； · 亮绿色表示可执行文件； · 灰白色表示普通文件。 ls命令参数介绍 ls 命令参数名称 功能与作用描述 -a 表示 –all， 列出目录下的所有文件,包括以 . 开头的隐藏文件。 -A 表示 -a，但不列出 .(表示当前目录) 和 .. (表示当前目录的上级目录)。 -c 表示按照最后更改时间排序,可以使用 -l 显示出时间。 -f 对输出的文件不进行排序。 -g 类似 -l,列出目录信息。 -G 表示 –no-group，不列出任何有关组的信息。 -h 表示 –human-readable，与 -l 配合使用，如 ls -lh以容易理解的格式列出文件大小，如 10k、20M、100G。 -i 表示 –inode，打印出每个文件的 inode 号。 -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来，ls -l 可以简写为 ll。 -L 表示 –dereference，当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息。 -m 所有文件或目录以 , 分隔，并填满整行行宽。 -o 类似 -l,显示文件的除组信息外的详细信息。 -r 表示 –reverse，按照当前排序顺序相反的顺序排列。 -R 表示 –recursive，递归出所有子目录层。 -s 表示 –size，以块大小为单位列出所有文件的大小。 -S 根据文件大小排序。 2、cd 命令1.pwd 查看当前所在目录的绝对路径 如图所示显示的绝对路径是以 / 开头的，/ 表示根目录 2.cd 切换至下级目录 若想要进入当前目录的下一级某个目录，可以使用 cd 跟上相对路径，这里以切换至 usr 目录为例： 演示执行过程如下图： cd usr/ 表示切换至当前目录的下级目录 usr，左侧没有 / 表示相对路径，若使用 cd ./usr/，那么其中的 . 表示当前目录，可以通过 ls -a 命令查看到。 3.cd 切换至上级目录的其他目录 前面已经切换至 /usr 目录了，若想要切换至 /var 目录则可以使用 ../ 来表示上级目录： 1234pwdcd ../var/pwdls 执行结果如下图： 如图所示，cd ../var/ 表示切换至当前目录的上级目录下的 var 目录，其中 ../ 表示上级目录，可通过 ls -a 查看到 4.cd 切换至绝对路径 可以使用 cd 跟上绝对路径切换至指定的绝对路径，这里以切换至 /etc/sysconfig/network-scripts 为例: 1cd /etc/sysconfig/network-scripts 执行结果如图： 5.使用Tab键自动补全 若每一个目录名称一个个敲出来就会显得有些繁琐，这个时候就可以使用 Tab 键来自动补全了，演示结果如下图所示： 3、创建文件和目录1.touch 创建文件 实际业务中，有些应用程序写入日志时要求需要先存在指定的日志文件，创建文件命令如下： 1touch error.log 执行结果如下图： 可以看到新建的 error.log 文件大小为 0 (空文件)，文件的属主用户是当前登录的 root 用户,文件默认的权限是 rw-r–r–，关于权限相关的知识，后面小节会详细介绍。 2.mkdir 创建目录 若想要创建一个目录，可以使用 mkdir 目录名 来创建一个新的空目录，命令如下： 1mkdir new_dir 执行结果如下： 如图所示，新建的 new_dir 目录大小为 0，目录的属主用户是当前登录的 root 用户，目录的默认权限是 rwxr-xr-x，目录中文件或目录的数量是 2（目录中默认会有 . 和 ..，分别表示当前目录、上级目录）。 3.使用ls命令查看指定文件或目录信息 上面新创建的文件或目录可以使用 ls -l 命令指定地展示其信息： 12ls -l error.logls -l new_dir 4、rm删除文件和目录1.删除文件 使用 rm 文件名 命令可以删除文件，以删除普通文件为例： 123ls -l # 列出当前目录下的所有文件rm test.c # 使用 rm 命令删除 test.c 文件ls -l # 再次查看当前目录下的所有文件 执行结果如下图： 2.强制删除文件 直接使用 rm 命令删除文件的话会提示你一次是否确定删除文件。使用 rm -f 可以不需要提示强制删除文件，以删除普通文件为例： 123ls -l # 列出当前目录下的所有文件rm -f a.out # 加上 -f 参数强制删除 a.out 文件ls 执行结果如下图： 实际业务中尽量不要使用 -f 删除文件，使用这种方式删除几乎不能恢复，所以删除文件时需要谨慎。 3.递归删除目录和子目录下所有文件 有时候需要删除多层目录以及目录下的文件，可以使用 rm -r 递归删除，以删除 /home/data 目录为例： 123456ls -l # 列出当前目录下的所有文件cd /home/data # 进入 /home/data 目录ls -l # 列出当前目录下的所有文件cd .. # 返回上一级目录rm -rf data/ # 递归删除 data/ 目录下所有文件ls 执行结果如下： 4.rm 删除命令参数介绍 可以使用 rm –help 命令来查看 rm 相关的参数介绍： 1rm --help 执行结果如下图： 下面列举出 rm 常见的参数和描述： rm 命令参数名称 功能与作用描述 -f 表示 –force，忽略不存在的文件和参数，不提示任何信息，强制删除。 -i 进行任何删除操作前必须先确认。 -r/-R 表示 –recursive，递归删除该目录下的所有目录层。 -d 表示 –dir，删除可能包含有数据的目录。 5、Mv移动文件和目录1.移动文件或目录至另外一个目录下 可以使用 mv file_name 路径 这种格式，移动文件至其他目录下，后面跟的路径可以是相对路径，也可以是绝对路径，这里的路径操作和 cd 命令类似，下面介绍移动文件命令： 12345ls -l # 列出当前目录下所有文件mv test.txt /usr/local # 使用 mv 命令将 text.txt 移动到 /usr/local 路径下ls -l # 再次查看当前目录下的文件cd /usr/local # 进入 /usr/local 文件夹下ls -l # 查看 /usr/local 目录下的文件信息 执行结果如下图： 可以看到 text.txt 文件已经被移动到 /usr/local 目录下了。 Tips：注意这里直接移动可能会造成同名文件或目录覆盖。 2.带有覆盖提示的文件或移动 如果要移动的目标路径下有同名文件，若不想同名文件被覆盖，可以使用 -i 参数询问是否需要覆盖，这里可以自行在两个目录下创建同名的文件： 12345ls -l # 列出当前目录下所有文件mv -i error.log study/ # 使用 -i 参数询问是否覆盖目标路径下的同名文件ls -l # 再次查看当前目录下的文件cd study/ # 进入 study/ 文件夹下ls -l # 查看 study/ 目录下的文件信息 执行结果如下图： Tips：这里只是演示了移动文件，移动目录和移动文件的操作是一样的，参照上述步骤即可。 3.mv 移动命令参数介绍 可以使用 mv –help 命令来查看 mv 相关的参数介绍： 1mv --help 执行结果如下图： 下面列举出 mv 常见的参数和描述: mv 命令参数名称 功能与作用描述 -b 若有文件覆盖时，则覆盖前先行备份。 -f 表示 –force，强制的意思，若目标文件已存在，则不会询问直接覆盖掉。 -i 表示 –interactive，若目标文件已经存在时，就会询问是否覆盖。 -n 表示 –no-clobber，不会覆盖已经存在的文件。 -u 表示 –update，若目标文件已经存在，且 source 比较新，才会更新 -t 表示 –target，指定 mv 的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 6、文件压缩与解压1.tar命令介绍 下面列举 tar 命令的参数： tar 命令参数名称 功能与作用描述 -c 新建立压缩档案 -x 解压缩 -t 查看内容 -u 更新原压缩包的内容 -z gzip 属性的 -j bz2 属性的 -Z compress 属性的 -v 显示所有过程 -O 将文件解压缩成标准输出形式 -f 使用档案名字，此参数都是在最后，其后面跟上一个档案的名字 Tips：其中 -c、-x、-t、-u 这五个参数是独立的，每次使用选其中一个，-f 是最后一个参数，后面跟上档案名。 1.1 将指定类型文件打包成 tar 包 为了演示方便，先切入到 /home 目录下，使用 touch 命令创建几个 .txt 文件，然后使用 tar 命令将其打包，命令如下： 12345cd /hometouch a.txt b.txt c.txt d.txt e.txtls -ltar -cf alltxt.tar *.txt ls -l 执行结果如下图： Tips：其中 alltxt.tar 是一个自定义名称，后缀是 tar ,前半部分的名字可自行定义， *.txt 中的 * 表示通配符代表所有的意思。 1.2 向现有的 tar 包中新增文件 这里再使用 touch 命令创建一个 g.txt 文件,使用 tar 命令将其新增至 alltxt.tar 中，命令如下： 12touch g.txttar -rf alltxt.tar g.txt 执行结果如下图： 1.3 更新 原来 tar 包中的文件 使用 rm 命令删除 /home 目录中的 a.txt ，然后新建一个 a.txt 表示为更新后的 a.txt，使用 tar 命令将 a.txt 更新至 alltxt.tar 中，命令如下： 123rm -f a.txttouch a.txttar -uf alltxt.tar a.txt 执行结果如下图： Tips：若 alltxt.tar 中没有 a.txt，那么使用 tar -uf 就会将 a.txt 新增到 alltxt.tar 中。 1.4 列出 tar 包中打包的所有文件 这里为了演示方便，将 /home 目录原有的 .txt 文件全都删除掉，然后使用 tar 命令查看 alltxt.tar 中所有文件列表，命令如下： 1234lsrm -f *.txtlstar -tf alltxt.tar 执行结果如下图： 1.5 解开 tar 包中所有文件 接着上面的内容，可以使用 tar 命令将 alltxt.tar 解开把文件释放到当前目录，命令如下： 123lstar -xf alltxt.tarls 执行结果如下图： 1.6 使用 tar 命令压缩 上面打包的 alltxt.tar 文件并没有压缩文件，只是把文件都打包在一起，如下命令可以把 alltxt.tar 压缩成为不同格式的压缩包： 1234567lstar -czf alltxt.tar.gz alltxt.tarlstar -cjf alltxt.tar.bz2 alltxt.tarlstar -cZf alltxt.tar.Z alltxt.tarls 执行结果如下图： Tips：命令中参数的含义可参考前面参数表格中的功能描述。 1.7 使用 tar 命令解压缩 为了演示方便，防止读者混淆，先将 alltxt.tar.gz、alltxt.tar.bz2、alltxt.tar.Z 三种格式压缩包移动至 study 目录，然后使用 tar 命令解压，命令如下： 123456ls mv alltxt.tar.gz study/mv alltxt.tar.bz2 study/mv alltxt.tar.Z study/cd study/ls 移动过程执行如下图： 如上图所示，将需要解压的三种格式压缩包移动至 /home/study 目录中，下面对其解压缩，命令如下： 1234567891011lstar -zxvf alltxt.tar.gzlsrm -f alltxt.tarlstar -jxvf alltxt.tar.bz2lsrm -f alltxt.tarlstar -Zxvf alltxt.tar.Zls 执行结果如下图： Tips：命令中参数的含义可参考前面参数表格中的功能描述。 zip 格式压缩与解压 CentOS 8 系统中自带 zip、unzip 压缩与解压工具，可以使用 zip -v、unzip -v 命令查看当前是否安装 zip、unzip 工具，若是没有安装，则可以使用如下命令安装： 12yum -y updateyum -y install zip unzip 安装过程如下图： 如上图所示，先要更新 yum 源的软件包数据，如下图所示为安装 zip、unzip 的过程执行图： Tips：yum 是 Linux 中的一个软件管理仓库，关于 yum 如何安装软件后续小节会详细介绍。 2.1 使用 zip 压缩文件 使用 zip 命令可以将 alltxt.tar 包压缩为 .zip 压缩包，命令如下： 执行结果如下： 123lszip alltxt.zip alltxt.tarls Tips：可以使用 zip -r zip包名 目录名 递归压缩目录以及目录中所有文件。 2.2 使用 unzip 解压缩 为了演示方便，先将 alltxt.zip 文件移动至 /home/study 中，然后解压，命令如下： 123456lsmv alltxt.zip study/cd study/lsunzip alltxt.zipls 执行结果如下图： 7、文件和目录重名1.使用mv命令对文件名称 这里还是以 /home 目录的 alltxt.tar 文件为例，可以使用 mv 命令对其重命名： 123lsmv alltxt.tar newtxt.tarls 执行结果如下图： 如上图所示相当于文件移动路径没变，名称变了，还可以在移动文件路径之后修改文件的名称，命令如下： 12345lsmv newtxt.tar study/home_newtxt.tarlscd study/ls 执行结果如下图： Tips：目录的重命名和文件的重命名方法一样。 使用 rename 命令修改文件名称 首先下面先列出 rename 参数的功能描述，可以使用 rename –help 命令查看其参数： 1rename --help 执行结果如下图： 下面列举了部分参数说明： rename 命令参数名称 功能与作用描述 -v 表示 –verbose，打印修改之后文件的名称 -n 表示 –no-act，测试命令，执行之后不会改变任何内容 -o 表示 –no-overwrite，表示重命名之后不会覆盖原有文件 这里还是以 /home/study 目录中的 home_newtxt.tar 为例，使用 rename 命令对其重命名，命令如下： 1234cd /home/studylsrename home_newtxt newtxt home_newtxt.tarls 执行结果如下： 8、查找文件和目录 按照文件类型查找 使用 -type 参数可以查找不同类型的文件，其可以查找的文件类型如下： find -type 文件类型介绍 描述 f 普通文件 d 目录文件 l 符号链接文件 b 块设备文件 c 字符设备文件 p 管道文件 s 套接字文件 这里以查找 /home 目录中的所有目录为例，使用 find 命令跟上 -type 来限制文件类型，命令如下： 12cd /find ./home -type d 执行结果如下图： Tips：find ./home -type d 其中的 ./home 表示要查找的相对路径的目录， -type d 表示查找文件类型为目录。 2.按照文件名查找 使用 -name 参数可以按照文件名来查找，这里以查找 /home 目录下所有的 .txt 文件为例，命令如下： 12cd /find ./home -name *.txt 执行结果如下图： Tips：find ./home -name .txt 其中的 ./home 表示要查找的相对路径目录，-name 表示按照文件名查找，.txt 表示文件名匹配规则，* 表示通配符，还可以查找指定文件名，如 find ./home -name a.txt。 3.查找排除指定文件 可以在查找文件的时候使用 ! 取反来排除指定的文件，例如查找 /home 目录中除了 .txt 文件以外的所有文件，命令如下： 123cd /find ./home -name *.txtfind ./home ! -name a.txt 执行结果如下图： Tips：find ./home ! -name a.txt 中的 ! 可以理解为排除符合要求的文件。 4.对查找到的文件执行操作 有时候需要对查找到的指定文件执行特定的操作： 1234cd /find ./home -name *.txtfind ./home -name *.txt -exec rm &#123;&#125; \\;find ./home -name *.txt 执行结果如下图： Tips：注意 find ./home -name *.txt -exec rm {} ; 后面的 ; 不要漏掉， -exec 表示执行某个操作，rm 表示删除操作。 9、查看文件内容1.file 查看文件类型 file 命令可以用来查看文件类型，还能查看文件的编码格式，下面列举一些 file 命令的参数： file 命令参数名称 功能与作用描述 -b 表示 –brief，显示查看结果时，不显示文件名 -c 表示 –checking-printout，显示指令执行过程 -f 表示 –files-from FILE，列出文件中文件名的文件类型 -F 表示 –separator STRING，使用指定符号替换输出文件名后的默认的 ： -i 输出 mime 类型的字符串 -L 表示 –dereference，查看对应软链接对应文件的文件类型 -z 表示 –uncompress，尝试查看压缩文件信息 1.1 查看文件类型 这里还是以 /home 目录里面的文件为例，命令如下： 123456789cd /homelsfile a.txtfile new_dircd study/file alltxt.tarfile alltxt.tar.gzfile alltxt.tar.bz2file alltxt.tar.Z 执行结果如下图： Tips：如图所示，使用 file 命令可以看到文件的编码、文件类型。 1.2 查看文件时不显示文件名称 在 file 命令后面跟上一个 -b 参数重复一次上面的流程，命令如下： 123456789cd /homelsfile -b a.txtfile -b new_dircd study/file -b alltxt.tarfile -b alltxt.tar.gzfile -b alltxt.tar.bz2file -b alltxt.tar.Z Tips：如图所示使用 -b 参数查看的文件信息时没有打印出文件名。 1.3 查看压缩包信息 进入到 /home/study，使用 -z 参数去查看压缩包信息，命令如下： 12345cd /home/studylsfile -z alltxt.tar.gzfile -z alltxt.tar.bz2file -z alltxt.tar.Z 执行结果如下图： Tips：如图所示，展示了压缩包相关的信息。 2.cat 查看文件内容 cat 命令可以用来查看文件内容，下面列举一些 cat 命令的参数： cat 命令参数名称 功能与作用描述 -A 表示 –show-all，展示所有内容 -b 表示 –number-nonblank，对查看的内容的非空行，对其行数编号 -n 表示 –number，对查看的内容行数编号输出 -v 表示 –show-nonprinting，使用^ 和M- 引用，除了LFD和 TAB 之外 -E 表示 –show-ends，在每行的最后展示KaTeX parse error: Expected ‘EOF’, got ‘符’ at position 1: 符̲号；就是无论你输入了什么，屏幕…符号结尾 -e 同 -vE -s 表示 –squeeze-blank，抑制空行输入，就是如果你有多行连续的空行，他会压缩成一行输出 -T 表示 –show-tabs，将跳格字符显示为^I -t 同 -VT 2.1 查看文件所有内容 这里以之前小节配置过的 /etc/sysconfig/network-scripts/ifcfg-ens160 文件为例，使用如下命令查看其中的内容： 123cd /etc/sysconfig/network-scriptslscat ifcfg-ens160 Tips：在输入路径或者文件名称的时候可以使用 Tab 键来补全。 2.2 对查看内容编排 命令如下： 12cat -b ifcfg-ens160cat -n ifcfg-ens160 执行结果如下图： Tips：-b 表示排除掉空行的内容，然后对其输出编号，会后会补上一行空行展示出来。 3.more 命令查看文件内容 more 命令也用来查看文件内容，下面列举一些 more 命令的参数： more 命令参数名称 功能与作用描述 +n 从第 n 行开始显示 -n 定义屏幕大小为 n 行 +/pattern 在每个档案显示前搜寻该字串 pattern，然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示 Press space to continue，’q’ to quit（按空格键继续，按q键退出），而禁用响铃功能 -l 忽略 Ctrl+l（换页） 字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与 -c 选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 这里以查看 /etc/mtools.conf 文件内容为例，命令如下： 12cd /etcmore mtools.conf 执行结果如下图： Tips : 如图中所示，可以按空格键继续浏览剩下内容，也可以按 q 键结束浏览。 tail 命令查看文件内容 tail 命令也用来查看文件内容，下面列举一些 tail 命令的参数： tail 命令参数名称 功能与作用描述 -f 表示 –follow[={name|descriptor}]，该参数用于监听文件新增内容。 -c 表示 –bytes=[+]NUM，从 num 字节位置读取指定文件 -n 表示 –lines=[+]NUM，从 num 行位置读取指定文件。 -F 同 -f -q 表示 –quiet，从不输出给出文件名的首部 -s 表示 –sleep-interval=N，与-f合用,表示在每次反复的间隔休眠S秒 4.1 查看文件最后几行内容 以 /etc/mtools.conf 文件为例，如要查看最后 6 行内容，命令如下： 12cd /etctail -5 mtools.conf 执行结果如下图： Tips：使用如图所示的命令可以查看 mtools.conf 文件的最后 5 行内容。 4.2 查看指定行数的内容 以 /etc/mtools.conf 文件为例，如要从第 45 行开始显示内容，命令如下： 1tail -n +45 mtools.conf 执行结果如下图： Tips：使用如图所示的命令可以查看 mtools.conf 文件的第 45 行开始的内容。 4.3 监听日志文件 在实际工作中，经常会使用 -f 去监听日志新增内容，达到开发者调试的目的，这里为了演示方便，需要打开之前安装过的 MobaXterm 首先进入 /home 目录，新建一个日志文件 access.log，命令如下： 123cd /homelstouch access.log 执行结果如下图： 接下来使用 tail 命令跟上 -f 参数对 access.log 日志文件监听,命令如下： 1tail -f access.log 执行结果如下图： 接下来在新打开的窗口中，进入 /home 目录，向 access.log 文件写入内容: 1234cd /homeecho &quot;这是第一条测试内容(time=2020-05-05 18:00)&quot; &gt;&gt; access.logecho &quot;这是第二条测试内容(time=2020-05-05 19:00)&quot; &gt;&gt; access.logecho &quot;这是第三条测试内容(time=2020-05-05 20:00)&quot; &gt;&gt; access.log 执行结果如下图： Tips：这种监听日志的方法经常用在后端程序开发调试工作中。 此时模拟日志数据输入完成，接着打开原来的监听窗口，如下图所示： 10、VIM编辑器1.vim 编辑器用法介绍 1.1 vim 编辑器三种模式 · 普通模式：当你刚开始进入 vim 编辑器的时候默认会进入普通模式； · 插入模式：在 vim 普通模式的时候，按下 i 键就可以进入插入模式，若想从 插入模式 回到 普通模式， 可以按下 ESC 键； · 命令模式：在普通模式下按下 : 键（Shift + ：），若想从 命令模式 回到 普通模式，可以按下 ESC 键。 Tips：这三种模式其实就是文本编辑器当前的状态，普通模式 可以理解为一般的打开查阅文件，可以查看和查找文件内容，不能修改内容；插入模式 可以理解为编辑状态，能对当前的文件内容修改，但是想要保存就需要当前登录用户拥有该文件的写入权限才能保存成功；命令模式 中的命令操作可以理解为编辑器对编辑后的文件的退出、保存等操作，如 :wq 表示保存退出，:q! 表示不保存强制退出。 1.2 vim 光标移动键介绍 · **h(或←)**：光标往左移动一个字符； · **j(或↓)**：光标往下移动一行； · **k(或↑)**：光标往上移动一行； · **l(或→)**：光标往右移动一个字符； · **PageDown(或 Ctrl + F)**：光标往下翻动一屏； · **PageUp(或 Ctrl + B)**：光标往上翻动一屏； · G：光标往下移动到最后一行； · n G：光标移动到缓冲区的第 n 行； · gg：光标往上移动到第一行。 1.3 命令行模式下的命令介绍 · q：表示退出，若有修改内容按 q，则会提示 E37: 已修改但尚未保存 (可用 ! 强制执行)； · **q!**：表示强制退出，不会保存修改的内容； · w：表示对修改的内容保存； · wq：表示保存并退出。 Tips：输入以上命令后，按回车即可执行命令。 1..4 普通模式下的命令介绍 命令参数名称 功能与作用描述 x 删除当前光标所在位置的字符 dd 删除当前光标所在行 dw 删除当前光标所在位置的单词 d$ 删除当前光标所在位置至行尾的内容 J 删除当前光标所在行行尾的换行符（拼接符） u 撤销前一编辑命令 a 在当前光标后追加内容，输入完按 ESC 即可退出 插入模式 A 在当前光标所在行行尾追加数据 r char 用 char 替换当前光标所在位置的单个字符 R text 用 text 覆盖当前光标所在位置的数据，输入完按 ESC 即可退出 插入模式 2.使用 vim 新建文件 进入 /home 目录,然后使用 vim 命令新建一个 new.log 文件,命令如下： 1cd /homelsvim new.log 执行结果如下图： 如上图所示，建一个文件名为 new.log 的文件，面进入临时文件 new.log 界面，如下图所示： Tips：此时的 new.log 文件并没有被保存，vim 编辑器是在内存缓冲区中处理数据的，若在启动 vim 编辑器时没有指定文件名或者文件不存在时，vim 编辑器会开辟一个新的缓冲区。 3.使用 vim 编辑文件 在进入 vim 普通模式下，可以按下 i 键进入插入模式来编辑文件内容，如下图所示： 4.vim 编辑器保存退出 编辑完内容之后按下 ESC 键退出插入模式，然后输入 :wq 按回车之后既可以保存退出： 使用 cat 查看 vim 编辑的文件 这里可以使用之前学习的 cat 命令查看新建的 new.log 文件内容： 12lscat new.log 执行结果如下图： Tips：也可以使用 vim new.log 打开文件查看内容。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}],"keywords":[]}]}
{"meta":{"title":"HERO","subtitle":"","description":"","author":"hujun","url":"http://example.com"},"pages":[],"posts":[{"title":"JMeter 的基础操作","slug":"JMeter-的基础操作","date":"2021-09-07T09:24:41.000Z","updated":"2021-09-07T10:05:46.612Z","comments":true,"path":"2021/09/07/JMeter-的基础操作/","link":"","permalink":"http://example.com/2021/09/07/JMeter-%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","excerpt":"","text":"一、jmeter的介绍1. JMeter 是什么？ JMeter 也称为“Apache JMeter”，它是一个开源的，100%基于 Java 的应用程序，带有图形界面。 它旨在分析和衡量 Web 应用程序和各种服务的性能和负载功能行为。 JMeter 主要用于测试 Web 应用程序或 FTP 应用程序，但目前，它适用于功能测试，JDBC 数据库连接，Web 服务，通用 TCP 连接和 OS 本机进程。 您可以执行各种测试活动，如性能，负载，压力，回归和功能测试，以便针对您的 Web服务器获得准确的性能指标。 JMeter 不是一个浏览器，它不像任何浏览器那样呈现 html 页面，而是在协议级别上运行。 以下是 JMeter 支持的协议列表: 12345Web Services - SOAP / XML-RPCWeb - HTTP,HTTPS sites ‘web 1.0’ web 2.0 (ajax, flex 和 flex-ws-amf) 通过 JDBC 驱动程序的数据库目录 - LDAP通过 JMS 面向消息传递的服务 服务——POP3, IMAP, SMTP 2. JMeter 的特性 **开源应用程序:**JMeter 是一个免费的开源应用程序，可以帮助用户或开发人员使用源代码开发其他应用程序。 **支持各种测试方法:**JMeter 支持各种测试方法，如负载测试，分布式测试和功能测试等。 123Web: HTTP, HTTPS, SOAP 数据库: JDBC, LDAP, JMSMail: POP3 **支持多协议:**JMeter 支持 HTTP，JDBC，LDAP，SOAP，JMS 和 FTP 等协议。 **模拟:**JMeter 可以使用虚拟用户或唯一用户模拟多个用户，以便对正在测试的 Web 应用程序产生大量负载。 **测试结果可视化:**测试结果可以以不同的格式查看，如图形，表格，树型和报告等。 3. JMeter 的工作流程 JMeter 通过模拟一组用户将请求发送到目标服务器。 随后，收集数据以通过各种格式 计算目标服务器的统计和显示性能度量。 如下图所示： 4.JMeter的安装 注意：安装 Jmeter 需要安装配置好对应的 java 环境 JMeter 下载、安装教程参考： https://blog.csdn.net/qq_39706570/article/details/91447382 5. 构建 JMeter 的测试计划 可以将测试计划可视化为用于运行测试的 JMeter 脚本。测试计划由测试元素组成，例 如线程组，逻辑控制器，样本生成控制器，监听器，定时器，断言和配置元素。 每个测试计划中至少应有一个线程组。 我们可以根据要求添加或删除元素。 让我们按照以下简单步骤开始构建测试计划: 1. 启动 JMeter 窗口 双击文件夹里面 bin 目录里面的 Jmeter.bat，出现如下画面","categories":[],"tags":[{"name":"JMeter的基础操作","slug":"JMeter的基础操作","permalink":"http://example.com/tags/JMeter%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"}],"keywords":[]},{"title":"案例整合","slug":"案例整合","date":"2021-09-06T03:41:27.000Z","updated":"2021-09-07T01:30:02.394Z","comments":true,"path":"2021/09/06/案例整合/","link":"","permalink":"http://example.com/2021/09/06/%E6%A1%88%E4%BE%8B%E6%95%B4%E5%90%88/","excerpt":"","text":"一、pageobject+unittest在前面我们都是基于线性模型来编写测试脚本，而且元素定位方式和属性值都是写死的。 1.场景案例前面我们所学，测试考研帮App登录场景，按照线性模型来构造出脚本如下： 考研帮登录测试场景脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from appium import webdriverimport yamlfrom selenium.common.exceptions import NoSuchElementExceptionimport loggingimport logging.configCON_LOG=&#x27;./log/log.conf&#x27;logging.config.fileConfig(CON_LOG)logging=logging.getLogger()stream=open(&#x27;./yaml/desired_caps.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(stream)desired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps)def check_updateBtn(): logging.info(&quot;check_updateBtn&quot;) try: element = driver.find_element_by_id(&#x27;android:id/button2&#x27;) except NoSuchElementException: logging.info(&#x27;update element is not found!&#x27;) else: element.click()def check_skipBtn(): logging.info(&quot;check_skipBtn&quot;) try: element = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;) except NoSuchElementException: logging.info(&#x27;skipBtn element is not found!&#x27;) else: element.click()check_updateBtn()check_skipBtn()logging.info(&#x27;start login...&#x27;)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_login_btn&#x27;).click()logging.info(&#x27;login finished&#x27;) 1）案例分析 上面的脚本看似都比较完善，有了log采集，参数配置、启动时页面元素自动检测。但是也存在一些不足之处： · 公共模块和业务模块混合在一起显得代码冗余等 · 测试场景单一（如果要实现如下测试场景该怎么办？） · 元素定位属性和代码混杂在一起 以上这些都是需要优化的地方。 测试场景 操作步骤 预期结果 多账号登录 不同的用户名密码来进行登录 能够正常登录 异常登录 用户名或者密码错误、或者为空进行登录， 登录失败，同时界面要给出相应的提示 注册 点击注册，然后进行注册信息填写 能够注册成功 2）重构优化思路 · 将一些公共的内容（如：check_updateBtn，check_skipBtn,capability）抽离出来。 · 元素定位方法和元素属性值与业务代码分离 · 登录功能模块封装为一个独立的模块 · 使用unittest进行用例综合管理 3）page object Page Object是Selenium自动化测试项目开发实践的最佳设计模式之一，通过对界面元素的封装减少冗余代码，同时在后期维护中，若元素定位发生变化，只需要调整页面元素封装的代码，提高测试用例的可维护性。 2.代码实现封装App启动配置信息 desired_caps.py 123456789101112131415161718192021222324252627282930313233343536373839import yamlimport logging.configfrom appium import webdriver#把app启动封装到一个类里面CON_LOG = &#x27;../log/log.conf&#x27;logging.config.fileConfig(CON_LOG)logging = logging.getLogger()def appium_desired(): stream = open(&#x27;../yaml/desired_caps.yaml&#x27;, &#x27;r&#x27;) data = yaml.load(stream) desired_caps=&#123;&#125; desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;] desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;] desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;] desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;] desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;] desired_caps[&#x27;unicodeKeyboard&#x27;]=data[&#x27;unicodeKeyboard&#x27;] desired_caps[&#x27;resetKeyboard&#x27;]=data[&#x27;resetKeyboard&#x27;] desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;] desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;] logging.info(&#x27;start run app...&#x27;) driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps) driver.implicitly_wait(8) return driverif __name__ == &#x27;__main__&#x27;: appium_desired() 记得在原来的yaml配置表desired_caps.yaml补充如下内容： 12unicodeKeyboard: True resetKeyboard: True 封装基类：BaseView.py 初始化——获取driver 写一个获取所有元素的函数 1234567#封装对应基类class BaseView(object): def __init__(self,driver): self.driver=driver def find_element(self,*loc): return self.driver.find_element(*loc) 封装通用公共类 common_fun.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from Base_View import *from desired_caps import *from selenium.common.exceptions import NoSuchElementExceptionimport loggingfrom selenium.webdriver.common.by import Byclass Common(BaseView): cancelBtn=(By.ID,&#x27;android:id/button2&#x27;) skipBtn=(By.ID,&#x27;com.tal.kaoyan:id/tv_skip&#x27;) def check_cancelBtn(self): logging.info(&#x27;==========check_cancelBtn=========&#x27;) try: cancelBtn = self.driver.find_element(*self.cancelBtn) except NoSuchElementException: logging.info(&#x27;no cancelBtn&#x27;) else: cancelBtn.click() def check_skipBtn(self): logging.info(&#x27;=========check skipBtn=============&#x27;) try: skipBtn = self.driver.find_element(*self.skipBtn) except NoSuchElementException: logging.info(&#x27;no skipBtn&#x27;) else: skipBtn.click()if __name__ == &#x27;__main__&#x27;: driver=appium_desired() com=Common(driver) com.check_cancelBtn() com.check_skipBtn()封装登录操作 loginView.pyimport loggingfrom common_fun import *from desired_caps import *from selenium.webdriver.common.by import Byclass LoginView(Common): username_type=(By.ID,&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;) password_type=(By.ID,&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;) loginBtn=(By.ID,&#x27;com.tal.kaoyan:id/login_login_btn&#x27;) def login_action(self,username,password): self.check_cancelBtn() self.check_skipBtn() logging.info(&#x27;===============login===============&#x27;) logging.info(&#x27;input username:%s&#x27;%username) self.driver.find_element(*self.username_type).send_keys(username) logging.info(&#x27;input password:%s&#x27;%password) self.driver.find_element(*self.password_type).send_keys(password) logging.info(&#x27;click loginBtn.&#x27;) self.driver.find_element(*self.loginBtn).click() logging.info(&#x27;login finished &#x27;)if __name__ == &#x27;__main__&#x27;: driver=appium_desired() l=LoginView(driver) l.login_action(&#x27;liubo10010&#x27;,&#x27;liubo10010&#x27;) 3.unittest 用例封装测试场景：使用如下账号进行分别登录测试 用户名 密码 hj18594962283 jxx.hxx21. fghjffdee 33321 1.封装用例启动、结束时的配置： myunit.py 123456789101112131415import unittestfrom appium_Test4.page_object.desired_caps import appium_desiredimport loggingfrom time import sleep#unitTest创建与销毁class StartEnd(unittest.TestCase): def setUp(self): logging.info(&#x27;=====setUp====&#x27;) self.driver=appium_desired() def tearDown(self): logging.info(&#x27;====tearDown====&#x27;) sleep(5) self.driver.close_app() 用例封装 test_login.py 12345678910111213141516171819202122from appium_Test4.unitTest.myunit import StartEndfrom appium_Test4.page_object.loginView import LoginViewimport unittestimport loggingclass TestLogin(StartEnd): def test_login_liubo10010(self): logging.info(&#x27;=========test_login_liubo10010============&#x27;) l=LoginView(self.driver) l.login_action(&#x27;liubo10010&#x27;,&#x27;liubo10010&#x27;) def test_login_error(self): logging.info(&#x27;=======test_login_error=========&#x27;) l=LoginView(self.driver) l.login_action(&#x27;666&#x27;,&#x27;222&#x27;)if __name__ == &#x27;__main__&#x27;: unittest.main() 项目代码结构： 二、自动化测试框架综合案例1.框架功能 业务功能的封装 测试用例封装 测试包管理 截图处理 断言处理 日志获取 测试报告生成 配置参数 2.测试案例测试环境 · Appium-desktop 1.5.0 · 考研帮App Android版3.1.0 · 夜神模拟器 Android 7.1.2 · Win 10 64位 覆盖用例 1.登录场景 用户名 密码 hj18594962283 jxx.hxx21. fghjffdee 33321 3.代码实现1）driver 配置封装 kyb_caps.yaml 配置表 1234567891011platformName: AndroidplatformVersion: 7.1.2deviceName: 127.0.0.1:62025appname: kaoyan3.1.0.apknoReset: FalseunicodeKeyboard: TrueresetKeyboard: TrueappPackage: com.tal.kaoyanappActivity: com.tal.kaoyan.ui.activity.SplashActivityip: 127.0.0.1port: 4723 desired_caps.py 1234567891011121314151617181920212223242526272829303132333435363738from appium import webdriverimport yamlimport loggingimport logging.configimport osCON_LOG=&#x27;../config/log.conf&#x27;logging.config.fileConfig(CON_LOG)logging=logging.getLogger()def appium_desired(): with open(&#x27;../config/kyb_caps.yaml&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as file: data=yaml.load(file) desired_caps=&#123;&#125; desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;] desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;] desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;] base_dir = os.path.dirname(os.path.dirname(__file__)) app_path = os.path.join(base_dir, &#x27;app&#x27;, data[&#x27;appname&#x27;]) desired_caps[&#x27;app&#x27;]=app_path desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;] desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;] desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;] desired_caps[&#x27;unicodeKeyboard&#x27;]=data[&#x27;unicodeKeyboard&#x27;] desired_caps[&#x27;resetKeyboard&#x27;]=data[&#x27;resetKeyboard&#x27;] logging.info(&#x27;start app...&#x27;) driver=webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;,desired_caps) driver.implicitly_wait(8) return driverif __name__ == &#x27;__main__&#x27;: appium_desired() 相对路径符号含义 “.”表示当前目录 “..” 表示当前目录的上一级目录。 “./”表示当前目录下的某个文件或文件夹，视后面跟着的名字而定 “../”表示当前目录上一级目录的文件或文件夹，视后面跟着的名字而定。 2）基类封装 baseView.py 123456789class BaseView(object): def __init__(self,driver): self.driver=driver def find_element(self,*loc): return self.driver.find_element(*loc) def find_elements(self,*loc): return self.driver.find_elements(*loc) 3）common公共模块封装 公共方法封装 : common_fun.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from baseView.baseView import BaseViewfrom common.desired_caps import appium_desiredfrom selenium.common.exceptions import NoSuchElementExceptionimport loggingfrom selenium.webdriver.common.by import Byimport time,osimport csvclass Common(BaseView): cancelBtn=(By.ID,&#x27;android:id/button2&#x27;) skipBtn=(By.ID,&#x27;com.tal.kaoyan:id/tv_skip&#x27;) wemedia_cacel=(By.ID,&#x27;com.tal.kaoyan:id/view_wemedia_cacel&#x27;) def check_cancelBtn(self): logging.info(&#x27;==========check_cancelBtn=========&#x27;) try: cancelBtn = self.driver.find_element(*self.cancelBtn) except NoSuchElementException: logging.info(&#x27;no cancelBtn&#x27;) else: cancelBtn.click() def check_skipBtn(self): logging.info(&#x27;=========check skipBtn=============&#x27;) try: skipBtn = self.driver.find_element(*self.skipBtn) except NoSuchElementException: logging.info(&#x27;no skipBtn&#x27;) else: skipBtn.click() def getTime(self): self.now=time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;) return self.now def getScreenShot(self,module): time=self.getTime() image_file=os.path.dirname(os.path.dirname(__file__))+&#x27;/screenshots/%s_%s.png&#x27; %(module,time) logging.info(&#x27;get %s screenshot&#x27; %module) self.driver.get_screenshot_as_file(image_file) def check_market_ad(self): logging.info(&#x27;====check_market_ad====&#x27;) try: element=self.driver.find_element(*self.wemedia_cacel) except NoSuchElementException: pass else: logging.info(&#x27;close market ad&#x27;) element.click() def get_csv_data(self,csv_file,line): logging.info(&#x27;=====get_csv_data======&#x27;) with open(csv_file,&#x27;r&#x27;,encoding=&#x27;utf-8-sig&#x27;) as file: reader=csv.reader(file) for index,row in enumerate(reader,1): if index==line: return rowif __name__ == &#x27;__main__&#x27;: driver = appium_desired() c=Common(driver) c.check_cancelBtn() # # c.check_skipBtn() # c.swipeLef() # c.swipeLef() # c.getScreenShot(&quot;startApp&quot;) 4）业务模块封装 1.登录页面业务逻辑模块 ioginView.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import loggingfrom common.common_fun import Common,NoSuchElementExceptionfrom common.desired_caps import appium_desiredfrom selenium.webdriver.common.by import Byclass LoginView(Common): username_type=(By.ID,&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;) password_type=(By.ID,&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;) loginBtn=(By.ID,&#x27;com.tal.kaoyan:id/login_login_btn&#x27;) tip_commit=(By.ID,&#x27;com.tal.kaoyan:id/tip_commit&#x27;) button_mysefl=(By.ID,&#x27;com.tal.kaoyan:id/mainactivity_button_mysefl&#x27;) username=(By.ID,&#x27;com.tal.kaoyan:id/activity_usercenter_username&#x27;) RightButton=(By.ID,&#x27;com.tal.kaoyan:id/myapptitle_RightButton_textview&#x27;) logoutBtn=(By.ID,&#x27;com.tal.kaoyan:id/setting_logout_text&#x27;) def login_action(self,username,password): self.check_cancelBtn() self.check_skipBtn() logging.info(&#x27;============login_action==============&#x27;) logging.info(&#x27;username is:%s&#x27; %username) self.driver.find_element(*self.username_type).send_keys(username) logging.info(&#x27;password is:%s&#x27;%password) self.driver.find_element(*self.password_type).send_keys(password) logging.info(&#x27;click loginBtn&#x27;) self.driver.find_element(*self.loginBtn).click() logging.info(&#x27;login finished!&#x27;) def check_account_alert(self): logging.info(&#x27;=====check_account_alert====&#x27;) try: element=self.driver.find_element(*self.tip_commit) except NoSuchElementException: pass else: logging.info(&#x27;close tip_commit&#x27;) element.click() def check_loginStatus(self): logging.info(&#x27;====check_loginStatus======&#x27;) self.check_market_ad() self.check_account_alert() try: self.driver.find_element(*self.button_mysefl).click() self.driver.find_element(*self.username) except NoSuchElementException: logging.error(&#x27;login Fail!&#x27;) self.getScreenShot(&#x27;login fail&#x27;) return False else: logging.info(&#x27;login success!&#x27;) self.logout_action() return True def logout_action(self): logging.info(&#x27;=====logout_action======&#x27;) self.driver.find_element(*self.RightButton).click() self.driver.find_element(*self.logoutBtn).click() self.driver.find_element(*self.tip_commit).click()if __name__ == &#x27;__main__&#x27;: driver=appium_desired() l=LoginView(driver) l.login_action(&#x27;liubo10010&#x27;,&#x27;liubo10010&#x27;) l.check_loginStatus() 2.data 数据封装 使用背景 在实际项目过程中，我们的数据可能是存储在一个数据文件中，如txt,excel、csv文件类型。我们可以封装一些方法来读取文件中的数据来实现数据驱动。 案例： 将测试账号存储在account.csv文件，内容如下： 用户名 密码 hj18594962283 jxx.hxx21. fghjffdee 33321 enumerate()简介enumerate()是python的内置函数 · enumerate在字典上是枚举、列举的意思 · 对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值 · enumerate多用于在for循环中得到计数。 enumerate()使用如果对一个列表，既要遍历索引又要遍历元素时，首先可以这样写： 123456789list = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;,&quot;数据&quot;] for i in range(len(list)): print(i,list[i])&gt;&gt;&gt;0 这1 是2 一个3 测试4 数据 上述方法有些累赘，利用enumerate()会更加直接和优美： 12345678list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;,&quot;数据&quot;] for index, item in enumerate(list1): print(index,item)&gt;&gt;&gt;0 这1 是2 一个3 测试 数据读取方法封装123456789101112import csv def get_csv_data(csv_file,line): with open(csv_file, &#x27;r&#x27;, encoding=&#x27;utf-8-sig&#x27;) as file: reader=csv.reader(file) for index, row in enumerate(reader,1): if index == line: return row csv_file=&#x27;../data/account.csv&#x27; data=get_csv_data(csv_file,3) print(data) utf-8与utf-8-sig两种编码格式的区别UTF-8以字节为编码单元，它的字节顺序在所有系统中都是一样的，没有字节序的问题，也因此它实际上并不需要BOM(“ByteOrder Mark”)。但是UTF-8 with BOM即utf-8-sig需要提供BOM。 3.config文件配置 日志文件配置 log.config 1234567891011121314151617181920212223242526272829303132333435[loggers]keys=root,infoLogger[logger_root]level=DEBUGhandlers=consoleHandler,fileHandler[logger_infoLogger]handlers=consoleHandler,fileHandlerqualname=infoLoggerpropagate=0[handlers]keys=consoleHandler,fileHandler[handler_consoleHandler]class=StreamHandlerlevel=INFOformatter=form02args=(sys.stderr,)[handler_fileHandler]class=FileHandlerlevel=INFOformatter=form01args=(&#x27;../logs/runlog.log&#x27;, &#x27;a&#x27;)[formatters]keys=form01,form02[formatter_form01]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s[formatter_form02]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s 4. 测试用例封装 测试用例执行开始结束操作封装 myunit.py 1234567891011121314import unittestfrom common.desired_caps import appium_desiredimport loggingfrom time import sleepclass StartEnd(unittest.TestCase): def setUp(self): logging.info(&#x27;=====setUp====&#x27;) self.driver=appium_desired() def tearDown(self): logging.info(&#x27;====tearDown====&#x27;) sleep(5) self.driver.close_app() 2.登录用例：test_login.py 12345678910111213141516171819202122232425262728from common.myunit import StartEndfrom businessView.loginView import LoginViewimport unittestimport loggingclass TestLogin(StartEnd): csv_file=&#x27;../data/account.csv&#x27; def test_login_liubo10010(self): logging.info(&#x27;======test_login_liubo10010=====&#x27;) l=LoginView(self.driver) data=l.get_csv_data(self.csv_file,2) l.login_action(data[0],data[1]) self.assertTrue(l.check_loginStatus()) @unittest.skip(&#x27;test_login_error&#x27;) def test_login_error(self): logging.info(&#x27;======test_login_error=====&#x27;) l = LoginView(self.driver) data = l.get_csv_data(self.csv_file, 3) l.login_action(data[0], data[1]) self.assertTrue(l.check_loginStatus(),msg=&#x27;login fail!&#x27;)if __name__ == &#x27;__main__&#x27;: unittest.main() 5. 执行测试用例&amp;报告生成run.py 12345678910111213141516171819import unittestfrom BSTestRunner import BSTestRunnerimport time,loggingimport syspath=&#x27;D:\\\\kyb_testProject\\\\&#x27;sys.path.append(path)test_dir=&#x27;../test_case&#x27;report_dir=&#x27;../reports&#x27;discover=unittest.defaultTestLoader.discover(test_dir,pattern=&#x27;test_login.py&#x27;)now=time.strftime(&#x27;%Y-%m-%d %H_%M_%S&#x27;)report_name=report_dir+&#x27;/&#x27;+now+&#x27; test_report.html&#x27;with open(report_name,&#x27;wb&#x27;) as f: runner=BSTestRunner(stream=f,title=&#x27;Kyb Test Report&#x27;,description=&#x27;kyb Android app test report&#x27;) logging.info(&#x27;start run test case...&#x27;) runner.run(discover)","categories":[],"tags":[{"name":"pageobject+unittest 自动化测试框架综合","slug":"pageobject-unittest-自动化测试框架综合","permalink":"http://example.com/tags/pageobject-unittest-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%BB%BC%E5%90%88/"}],"keywords":[]},{"title":"python","slug":"python","date":"2021-09-04T10:13:15.000Z","updated":"2021-09-07T08:57:32.802Z","comments":true,"path":"2021/09/04/python/","link":"","permalink":"http://example.com/2021/09/04/python/","excerpt":"","text":"一、Python 的介绍python 定义及其作用 def: 是一种面向对象、解释型计算机程序设计语言 特点： 代码量小 维护成本低 编程效率高 作用： Python 最常用的应该就是写爬虫了吧，比较简单的应用就是爬取 web 网站的资源（图片，文字、链接等） 有些资深股民都是用 Python 抓取财经网站数据、并进行处理，然后输出可视化图表来帮助做决策。 人工智能机器学习方面应用，python 有很多库很方便做人工智能，比如 numpy, scipy 做数值计算的，sklearn 做机器学习的，pybrain 做神经网络的。 软件测试领域：自动化测试（Web 端(python+selenium)和移动客户端 python+appium） 二、python解释器的安装主要针对python3 进行学习，是对python2 的优化 1.下载和安装 python下载 python安装 安装注意： 在第一步的时候，一定要勾选上： Add python to PATH 其余都是下一步 直接安装下载的安装包即可（建议安装在 C 盘根目录） 2.验证安装是否成功 \\1. 进入 cmd 窗口 \\2. 输入 python \\3. 显示以下界面，表示 python 安装成功 1234C:\\Windows\\System32&gt;pythonPython 3.6.6 (v3.6.6:4cf1f54eb7, Jun 27 2018, 03:37:03) [MSC v.1900 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 三、python的输入和输出不要直接用电脑自带的记事本写代码，因为会造成中文乱码！！！ 推荐下载一个 nodepad++、或者 editplus 这类高级记事本来写 输出：Python 没有过分强调语句结尾的“;” ​ 可以写或者不写 输入：print()函数 输出字符串拼接直接使用逗号隔开 录入的类型为字符串类型 四、python的数据类型与运算符1. Python几个常见的数据类型 Python 不会像 JAVA 一样，刻意去强调数据类型 字符串——str 整数——int 浮点数——float 格式： num=13 解释： 变量 num 就是一个整数类型 2. Python 数据类型的检测 Python 的检测使用 type 函数 3.python 的运算符 python 常见的运算符 1.算术运算符：+、-、*、/ 、% 2.逻辑运算符：and 、or、not 3.赋值运算符：+=、-=、*=、/=、%=、**=(幂赋值) 4.比较运算符 &gt;= &lt;= != == 五、Python 的容器一：列表、元组1.列表list： 列表（list）可以存储多个不同类型的数据 列表可以通过下标(从 0 开始)来访问 列表的长度不是固定的 列表的功能： 1）使用 len()函数可以获得 list 的个数 2）使用 append()函数往列表里面追加数据 2.元组tuple： 元祖也是一个容器，可以用来存储数据，不过区别在于： 元祖的长度一旦声明不可以更改、元祖的存储值用的小括号 六、Pycharm工具的使用1.介绍 PyCharm 是一种 Python IDE，带有一整套可以帮助用户在使用 Python 语言开发时提高其效率的工具，比如调试、语法高亮、Project 管理、代码跳转、智能提示、自动完成、单 元测试、版本控制。此外，该 IDE 提供了一些高级功能，以用于支持 Django 框架下的专业 Web 开发。 2.下载、安装 pycharm下载、安装步骤链接 3.使用注意： 如何创建项目： 选择上方的”file” 然后选择”new project” 然后输入项目名和选择代码路径 设置字体： 选择上方的”file” 选择”setting” 输入”font”，设置 size 代码写好了，怎么运行？ 在代码编辑区域-右键 选择”Run” 七、Python 的选择结构1.第一种：1个条件，1个结果 if… 2.第二种：1个条件，2个结果 if…else… 3.第三种：多个条件，多个结果 if…elseif…else 4.if 里面套if 八、Python的循环结构1.什么是循环 分析：输出 100 句 hello,意味着要写 100 个 print 语句，但是我们会发现这是一件重复的 事情——一直在输出 hello。遇到这样重复的问题，我们可以通过循环来写一句 print(“hello”) 实现 100 句输出。 列如下面的代码： 1234n=1; while n&lt;=100: print(n,&quot;Hello&quot;) n+=1 2.循环的四要素 要了解循环，必须了解循环的几要素： 循环从哪里开始：循环的初始化变量 循环到哪里终止：循环的判断条件 循环一直在做什么：循环体语句 循环一次，计数记录更新：控制循环语句 列如：输出 100 句 hello 循环的初始化变量： n=1 循环的判断条件： while n&lt;=100: 循环体语句： print(“hello”) 控制循环语句： n+=1 3.while循环： 1循环的初始化变量： While 循环的判断条件： 循环体语句 控制循环语句 案例：循环输出 1-50 能被 2 整除并且能被 3 整除的数字： 1234n=1;while n&lt;=50: if n%2==0: print(n) 4.for循环： Python 的 for 循环可以用 rang()函数来确定数的范围： 列如：循环 1–50 12for x in range(1,51): print(x) 解释： range(1,51):表示这个数字从 1–50 x 和 in 表示从 range 函数取一个赋值给 x，然后打印 x 案例：求 1–100 的偶数和 12345sum=0 for x in range(1,51): if x%2 ==0: sum+=x print(sum) 5.循环的练习 打印一个直角三角形： 12345sum=0 for x in range(1,4): for y in range(0,x): print(&quot;*&quot;,end=&quot;&quot;) print() 解释：end=””组织它换行 打印一个倒菱形： 123456for i in range(4): for k in range(i, 7 - i): print(&quot; * &quot;, end=&quot;&quot;) print() for j in range(0, i + 1): print(&quot; &quot;, end=&quot;&quot;) 九、python的容器二：字典字典是另一种可变容器模型，且可存储任意类型对象。 字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号(**{})**中 ,格式如下所示： 1dict = &#123;&#x27;Alice&#x27;: &#x27;2341&#x27;, &#x27;Beth&#x27;: &#x27;9102&#x27;, &#x27;Cecil&#x27;: &#x27;3258&#x27;&#125; 1.访问字典里的值 把相应的键放入熟悉的方括号，通过访问 key 来找 value.如下实例: 123dict = &#123;&#x27;Name&#x27;: &#x27;W3CSchool&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;:&#x27;First&#x27;&#125;print (&quot;dict[&#x27;Name&#x27;]: &quot;, dict[&#x27;Name&#x27;])print (&quot;dict[&#x27;Age&#x27;]) dict[&#x27;Age&#x27;]) 2.修改字典 向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例: 1234dict = &#123;&#x27;Name&#x27;: &#x27;W3CSchool&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125; dict[&#x27;Age&#x27;] = 8; # 更新 Age dict[&#x27;School&#x27;] = &quot;python 教程&quot; # 添加信息 print (&quot;dict[&#x27;Age&#x27;]: &quot;, dict[&#x27;Age&#x27;])print (&quot;dict[&#x27;School&#x27;]: &quot;, dict[&#x27;School&#x27;]) 3.删除字典元素 能删单一的元素也能清空字典，清空只需一项操作。 显示删除一个字典用 del 命令，如下实例： 123456dict = &#123;&#x27;Name&#x27;: &#x27;W3CSchool&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;del dict[&#x27;Name&#x27;] # 删除键 &#x27;Name&#x27; dict.clear() # 删除字典del dict # 删除字典 print (&quot;dict[&#x27;Age&#x27;]: &quot;, dict[&#x27;Age&#x27;])print (&quot;dict[&#x27;School&#x27;]: &quot;, dict[&#x27;School&#x27;]) 4.字典键（key）的特性 1.不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住 12dict = &#123;&#x27;Name&#x27;: &#x27;zhangsan&#x27;, &#x27;Age&#x27;: 7, &#x27;Name&#x27;: &#x27;小菜鸟&#x27;&#125;print (&quot;dict[&#x27;Name&#x27;]: &quot;, dict[&#x27;Name&#x27;]) 5.字典内置函数&amp;方法 序号 函数及描述 实例 输出结果 1 len(dict) 计算字典元素个 数，即键的总数。 &gt;&gt;&gt; dict ={‘Name:’zhangsan’,’Age’:’7’,’Class’:’first’} &gt;&gt;&gt; len(dict) 3 2 str(dict)输出字典以可打印的字符串表示。 &gt;&gt;&gt; dict ={‘Name:’zhangsan’,’Age’:’7’,’Class’:’first’} &gt;&gt;&gt; str(dict) “{‘Name’: ‘zhangsan’, ‘Class’: ‘First’, ‘Age’: 7}” 3 type(variable)返回输入的变量类型，如果变量是字典就返回字典类型。 &gt;&gt;&gt; dict ={‘Name:’zhangsan’,’Age’:’7’,’Class’:’first’} &gt;&gt;&gt; type(dict) &lt;class ‘dict’&gt; 十、Python 的迭代器与生成器1.迭代器 迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。。 迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 **next()**。 字符串，列表或元组对象都可用于创建迭代器： 12345678#创建一个 list list=[1,2,3,4] #创建迭代器对象 it=iter(list) #开始迭代第 1 个元素 1print(next(it)) #开始迭代第 2 个元素 2print(next(it)) 迭代器对象可以使用常规 for 语句进行遍历： 1234list=[1,2,3,4] it = iter(list) # 创建迭代器对象 for x in it: print (x, end=&quot; &quot;) 也可以使用 next() 函数： 1234567list=[1,2,3,4] it = iter(list) # 创建迭代器对象while True: try: print (next(it)) except StopIteration: sys.exit() 解释： while True:这是一个死循环 try…except StopIteration:捕捉异常 2.生成器 在 Python 中，使用了 yield 的函数被称为生成器（generator）。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 在调用生成器运行的过程中，每次遇到 yield时函数会暂停并保存当前所有的 运行信息，返回 yield 的值。并在下一次执行next()方法时从当前位置继续运行。 以下实例使用 yield 实现斐波那契数列： 1234567891011121314import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1 f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=&quot; &quot;) except StopIteration: sys.exit() 十一、python的内置函数1.取绝对值 abs(x) 求绝对值 1、参数可以是整型，也可以是复数 2、若参数是复数，则返回复数的模 2.数据类型转换函数 float([x]) 将一个字符串或数转换为浮点数。如果无参数将返回 0.0 int([x[, base]]) 将一个字符转换为 int 类型，base 表示进制 long([x[, base]]) 将一个字符转换为 long 类型 完整参考 十二、Python 的自定义函数函数能提高应用的模块性，和代码的重复利用率。Python 提供了许多内建函数，比如print()等。也可以创建用户自定义函数。 1.函数的定义 函数定义的简单规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()，任何传入 参数和自变量必须放在圆括号中间 函数内容以冒号起始，并且缩进 若有返回值，Return[expression] 结束函数；不带 return 表达式相当于返回 None 函数通常使用三个单引号 ‘’’…’’’ 来注释说明函数；函数体内容不可为空，可用 pass 来表示空语句；以下几个为简单的函数示例： 1234567891011&#x27;&#x27;&#x27; some basic functions &#x27;&#x27;&#x27;def func1(): # 函数无传入参数 print(&quot;func1&quot;) # 无 return 值 func1() # 函数调用 def func2(): return(&quot;func2&quot;) # return 字符串 &quot;func2&quot; print(func2())def func3(a,b): # 需传两个参数 print(&quot;a+b = %d&quot; %(a+b)) # print 表达式，无return func3(3,4) def func4(a,b): # 需传两个参数 return (a+b) # return a+b 的值 print(func4(4,3)) 2.函数的调用 定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。 这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python 提示符执行。 上面的例子中 func1() 就是无参数函数的调用； func3(3,4) 为有参数函数的调用 十三、Python的面向对象：类与对象1.面向对象的关键因素 类(class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。 数据成员： 类的不同属性数据。 对象： 对象是类的实例 方法： 类中定义的函数，实现相关的功能。 2.面向对象编程 简称 OOP（Object Oriented Programming），是一种程序设计思想。OOP 把对象 作为程序的基本单元，一个对象包含了数据和操作数据的函数（方法）。 面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class 是一种抽象概念，比如我们定义的 Student 类，是指学生这个概念，而实例（Instance）则是一个个体的 Student 对象。 Python 是一门面向对象的语言，在 Python 中创建一个类和对象是很容易的 3.定义类 1class Student(object): 类体 Class 是类的定义的关键词，class 后面紧接着是类名，即 Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的。通常如果没有明确的继承类，就使用 object 类，括号内一般为空默认就是继承 Obejct 类。这是所有类最终都会继承的类，也就是基类。 4.属性初始化 由于类可以起到模板的作用，因此，可以在创建实例对象的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，如：在创建 Student 实例的时候，就把 name，city 等属性绑上去： 12345class Student(): def __init__(self,name,city): self.name=name self.city=city print(&quot;My name is %s and come from %s&quot; % (name, city)) __init__方法的第一个参数永远是 self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到 self，因为 self 就指向创建的实例本身。有了__init__方法， 在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但 self 不需要传，Python 解释器自己会把实例变量传进去。 5.定义方法 类的方法除了第一个参数是 self 外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用。 12345class Student(): def __init__(self,name,city): self.name=name self.city=city print(&quot;My name is %s and come from %s&quot; % (name, city)) def talk(self): print(&quot;Hello&quot;) 6.生成实例对象 1234stu1=Student(&#x27;Jack&#x27;,&#x27;Beijing&#x27;)stu1.talk() stu2=Student(&#x27;Harry&#x27;,&#x27;Shanghai&#x27;)stu2.talk() 十四、python 的模块应用1.为何要使用模块？ 随着项目功能和需求增多，代码量也会增大，把全部代码放在一个文件会显得冗余，因此需要使用模块进行分区管理。 2.python 的模块是什么？ Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和 Python 语句。 3.使用模块的好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。如：随机数模块，时间模块。 4.import语句 导入时间模块显示当前系统时间 123#模块 显示当前时间 import time print(time.ctime())#调用获取当前时间的方法 导入随机数模块显示随机整数 123import randomnum=random.randint()print(num) 5.from…import 语句 Python 的from 语句让你从模块中导入一个指定的部分到当前命名空间中。 12345from time import sleepfrom Student import Student stu1=Student(&#x27;jack&#x27;,&#x27;Beijing&#x27;) stu1.talk() stu2=Student(&#x27;Harry&#x27;,&#x27;Shanghai&#x27;) stu2.talk() 6.跨目录调用模块 案例：调用 School 目录下的 Student 模块 1234from School.Student import Student stu1=Student(&#x27;jack&#x27;,&#x27;Beijing&#x27;)stu1.talk() stu2=Student(&#x27;Harry&#x27;,&#x27;Shanghai&#x27;)stu2.talk() 7.import 搜索路径 当你导入一个模块，Python 解析器对模块位置的搜索顺序是： 1、当前目录 2、如果不在当前目录，Python 则搜索 PYTHONPATH 下的每个目录。 3、如果都找不到，Python 会察看安装默认路径。 十五、python的异常1.什么是异常？ 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。 一般情况 下，在 Python 无法正常处理程序时就会发生一个异常。 异常是 Python 对象，表示一个 错误。 当 Python 脚本发生异常时我们需要捕获处理它，否则程序会终止执行。 2.常见的异常类型？ 异常名称 描述 FileNotFoundError 找不到指定文件的异常 NameError 未声明/初始化对象 (没有属性) BaseException 所有异常的基类 3.异常的处理语句使用？ try…except… try…except…finally raise FileNotFoundError 1234try: fileName=input(&quot;Please input fileName:&quot;) open(&quot;%s.txt&quot; %fileName) except FileNotFoundError: print(&quot;%s file not found &quot; %fileName) NameError 1234try: print(stu) except NameError: print(&quot;stu not define !&quot;) BaseException 1234try: print(stu) except BaseException:print(&quot;stu not define !&quot;) try…except…as… 12345try: #stu=&#x27;Jack&#x27; print(stu) except BaseException as msg: print(msg) try… except… else 使用 1234567try: stu=&#x27;Jack&#x27; print(stu) except BaseException as msg: print(msg) else: print(&quot;stu is defined！&quot;) try..except…finally 输出 1234567try: #stu=&#x27;Jack&#x27; print(stu) except BaseException as msg: print(msg) finally: print(&quot;The end !&quot;) raise抛出异常 前面 try 语句是执行过程中捕获代码块的异常，而 raise 是通过事先定义一个条件，一 旦符合异常条件就抛出异常。 12345678def division(x,y) if y==0: raise ZeroDivisionError(&quot;Zero is not allow!&quot;) return x/y try: division(8,0) except BaseException as msg: print(msg) 注意：raise 只能用于 Python 标准异常类！ 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达 EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于 Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告 十六、Python 的文件处理1.打开文件 使用 Python 内置的方法 open（）可以打开文件 1file object = open(file_name [, access_mode][,buffering]) file_name：file_name 变量是一个包含了你要访问的文件名称的字符串值。 access_mode：access_mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 buffering:如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1,访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 1f=open(&#x27;stu_info.txt&#x27;,&#x27;r&#x27;) f=open(&#x27;E:\\\\test\\\\stu_info.txt&#x27;,&#x27;r&#x27;) 常用文件打开模式 模式 描述 r 以只读方式打开文件。 rb 以二进制格式打开一个文件用于只读。 w 打开一个文件只用于写入。 a 打开一个文件用于追加。新的内容将会被写入到已有内容之后。如果该文件 2.文件的读取 123line=f.read() line1=f.readline() line2=f.readlines() read() 每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。 readline() 每次只读取一行 readlines()一次性读取文件所有行 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理。 3.关闭文件 1f.close（） 读取 txt 文件 案例：读取 stu_info.txt 文件内容，并将所有文件中学生名称显示出来 12345f=open(&#x27;stu_info.txt&#x27;,&#x27;r&#x27;)lines=f.readlines()print(lines) for line in lines: print(line.split(&#x27;,&#x27;)[0]) split()方法语法： 1str.split(str=&quot;&quot;, num=string.count(str)). 参数 str – 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。 num – 分割次数 4. 读写 csv 文件 csv 即为逗号分隔值（Comma-Separated Values，CSV），有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。 csv 文件读取 案例：读取 Stu_info.csv 文件里所有学生信息。 123import csv csv_file=csv.reader(open(&#x27;Stu_info.csv&#x27;,&#x27;r&#x27;)) for stu in csv_file: print(stu) csv 文件写入 对 Stu_info.csv 文件追加写入两个学生信息 1234stu=[&#x27;Marry&#x27;,28,&#x27;Changsha&#x27;] stu1=[&#x27;Rom&#x27;,23,&#x27;Chengdu&#x27;] out=open(&#x27;Stu_info.csv&#x27;,&#x27;a&#x27;,newline=&#x27;&#x27;) csv_write=csv.writer(out,dialect=&#x27;excel&#x27;) csv_write.writerow(stu)csv_write.writerow(stu1)print(&quot;Write File Over!&quot;) 十七、python的xml的处理1. 什么是 xml 文件？ xml 即可扩展标记语言，它可以用来标记数据、定义数据类型，是一种允许用户对自己 的标记语言进行定义的源语言。 从结构上，很像 HTML 超文本标记语言。但他们被设计的目的是不同的，具体如下： XML 被设计用来传输和存储数据。 HTML 被设计用来显示数据。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;note&gt; &lt;to id=&#x27;001&#x27;&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 2. Xml 的特征？ 它是有标签对组成， 标签可以有属性： 标签对可以嵌入数据：abc 标签可以嵌入子标签（具有层级关系） 3. Xml 的文件结构 XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。 第一行是 XML 声明。它定义 XML 的版本 (1.0) 和所使用的编码 是根元素,也称为根节点。 是子元素（子节点） XML 文档必须包含根元素。该元素是所有其他元素的父元素 4. DOM 的文档对象模型 文档对象模型（Document Object Model，简称 DOM），DOM 就是针对 HTML 和 XML 提供的一个 API。什么意思？就是说为了能以编程的方法操作这个 HTML 的内容（比 如添加某些元素、修改元素的内容、删除某些元素），我们把这个 HTML 或 xml 看做一个测试系列课程——新睿教学部刘波 对象树（DOM 树），它本身和里面的所有东西比如 这些标签都看做一个 对象，每个对象都叫做一个节点（node）。 5. DOM 有什么用？ 就是为了操作 HTML 或 xml 中的元素，比如说我们要通过 JS 把这个网页的标题改了，直接这样就可以了： 1document.title = &#x27;baidu&#x27;; 6. 创建 XML 文件 创建一个 xml 文件 Class_info.xml 用来存储班级学生（姓名，年龄，城市），老师（姓名， 年龄，城市）、教务账号（学生和老师的账号，密码）等信息。 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;Class&gt; &lt;student&gt; &lt;name &gt;Jack&lt;/name&gt; &lt;age&gt;28&lt;/age&gt; &lt;city&gt;Beijing&lt;/city&gt; &lt;/student&gt; &lt;student&gt; &lt;name &gt;Bob&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;city&gt;Shanghai&lt;/city&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;Harry&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;city&gt;ShenZhen&lt;/city&gt; &lt;/student&gt; &lt;teacher&gt; &lt;name&gt;Marry&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;city&gt;Changsha&lt;/city&gt; &lt;/teacher&gt; &lt;account&gt; &lt;login username=&quot;student&quot; password=&quot;123456&quot;/&gt; &lt;login username=&quot;teacher&quot; password=&quot;888888&quot;/&gt; &lt;/account&gt;&lt;/Class&gt; 7.Xml 文件的读取案例 1) xml 的节点 xml 文件节点一般包含 3 类： 元素节点 文本节点 属性节点 每个节点都拥有包含着关于节点某些信息的属性。这些属性是： nodeName（节点名称） nodeValue（节点值） nodeType（节点类型） 2) 读取元素的节点 案例：查看 Class_info.xml 文件里 Class 节点的属性（结点名称，节点的值、节点类型） 123456789from xml.dom import minidom #加载 xml 文件 dom=minidom.parse(&#x27;Class_info.xml&#x27;) #加载 dom 对象元素 root=dom.documentElement #打印节点信息 print(root.nodeName)print(root.nodeValue) print(root.nodeType) nodeName 节点名称 nodeValue 返回文本节点的值 nodeType 属性返回以数字值返回指定节点的节点类型。 如果节点是元素节点，则nodeType 属性将返回 1。 如果节点是属性节点，则nodeType 属性将返回 2。 3) 读取文本节点的值 案例：分别打印出 Class_info.xml 里的学生和老师的详细信息（姓名，年龄、城市） 1234567891011from xml.dom import minidom #获取标签对的值 #打开文件dom=minidom.parse(&#x27;Class_info.xml&#x27;) #获取文档对象元素 root=dom.documentElement #根据标签名称获取标签对象names=root.getElementsByTagName(&#x27;name&#x27;) ages=root.getElementsByTagName(&#x27;age&#x27;) citys=root.getElementsByTagName(&#x27;city&#x27;) #分别打印显示 xml 文档标签对里面的内容for i in range(4): print(names[i].firstChild.data) print(ages[i].firstChild.data) print(citys[i].firstChild.data) 4) 读取属性节点的值 案例：分别读取打印老师和学生的账号密码 123from xml.dom import minidom dom=minidom.parse(&#x27;Class_info.xml&#x27;) root=dom.documentElement logins=root.getElementsByTagName(&#x27;login&#x27;)#获取 login 标签的 username 属性 for i in range(2): username=logins[i].getAttribute(&#x27;username&#x27;) print(username) password=logins[i].getAttribute(&#x27;password&#x27;) print(password) 5) 读取子节点信息 读取子节点相关属性 nodeName（节点名称） nodeValue（节点值） nodeType（节点类型） 12345678from xml.dom import minidom #加载 xml 文件 dom=minidom.parse(&#x27;Class_info.xml&#x27;)root=dom.documentElement tags=root.getElementsByTagName(&#x27;student&#x27;) print(tags[0].nodeName) print(tags[0].tagName) print(tags[0].nodeType)print(tags[0].nodeValue) 十八、Python 的单线程与多线程 1) 什么是进程？ 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 2) 什么是线程？ 有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。 线程是进程中的一个实体，是被系统独立调度和分派的基本单位，一个进程可以包含多个线程， 但是线程不能包含多个进程。线程自己不拥有系统资源 ，在单个程序中同时运行多个线程完成不同的工作，称为多线程。 3) 线程与进程的区别？ 线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。 提示： LoadRunner 和 Jmeter 等性能测试工具也利用了多线程和多进程来构造多个并发用户来执行性能测试。 1线程与进程图文解释 http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 4) 单线程 单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。 案例：一个学生先用2 秒说话，接着用 3 秒写字，最后结束。 1234567891011from time import ctime,sleep def talk(): print(&quot;Start talk %r&quot; %ctime()) sleep(2)def write(): print(&quot;Start Write! %r&quot; %ctime()) sleep(3) if __name__==&quot;__main__&quot;: talk() write() print(&quot;All end %r&quot; %ctime()) if name==”main“: 表示如果当前模块是被直接运行的，则该语句之后代码块被运 行，如果模块是被导入的，则代码块不被运行 5) 多线程： 多线程（MultiThreading）是指从软件或者硬件上实现多个线程并发执行的技术。 案例：让学生同时进行说和写操作 1234567891011121314151617181920from time import ctime,sleep import threadingdef talk(content,loop): for i in range(loop): print(&quot;Start Talk %s %s&quot; %(content,ctime())) sleep(3)def write(content,loop): for i in range(loop): print(&quot;Start Write %s %s&quot; %(content,ctime())) sleep(5) threads=[] t1=threading.Thread(target=talk,args=(&#x27;Speak: Hello&#x27;,2)) threads.append(t1) t2=threading.Thread(target=write,args=(&#x27;Write: Life is Short You need Python!&#x27;,2)) threads.append(t2) if __name__==&#x27;__main__&#x27;: for t in threads: t.start() for t in threads: t.join() print(&quot;All the End %r&quot; %ctime()) 6) 多进程 与多线程相比，多进程就是 import multiprocessing 然后替换相应的方法 multiprocessing.Process（） 12345678910111213141516from time import sleep,ctimeimport multiprocessing def talk(content,loop): for i in range(loop): print(&quot;Talk: %s %s&quot; %(content,ctime())) sleep(2) def write(content,loop): for i in range(loop): print(&quot;Write: %s %s&quot;%(content,ctime())) sleep(3)process=[] p1=multiprocessing.Process(target=talk,args=(&#x27;hello&#x27;,2)) process.append(p1) p2=multiprocessing.Process(target=write,args=(&#x27;Python&#x27;,2)) process.append(p2) if __name__==&#x27;__main__&#x27;: for p in process: p.start() for p in process: p.join() print(&quot;All process is Run %s&quot; %ctime()) 十九、Python 的爬虫案例 从网页页面上批量下载 jpg 格式图片，并按照数字递增命名保存到指定的文件夹。 Web 地址：http://p.weather.com.cn/2017/06/2720826.shtml#p=1 12345678910111213141516171819202122232425import urllib import urllib.requestimport re #正则表达式 #解析页面 def load_page(url): request=urllib.request.Request(url) #发送网络请求 response=urllib.request.urlopen(request)#根据 url 打开页面 data=response.read() #获取页面响应数据 return data #下载图片 def get_image(html): regx=r&#x27;http://[\\S]*jpg&#x27; #定义正则表达式，匹配页面图片元素 pattern=re.compile(regx) #编译表达式构造匹配模式 get_image=re.findall(pattern,repr(html)) #进行正则匹配并返回结果 num = 1 #遍历获取的图片 for img in get_image: image=load_page(img) #将图片存入到指定文件夹 with open(&#x27;E:\\\\Photo\\\\%s.jpg&#x27; %num,&#x27;wb&#x27;) as fb: fb.write(image) print(&quot;正在下载第 %s 张图片&quot; %num) num = num + 1 print(&quot;下载完成！&quot;) url=&#x27;http://p.weather.com.cn/2017/06/2720826.shtml#p=1&#x27;html=load_page(url)get_image(html) 正则表达式相关知识： https://deerchao.net/tutorials/regex/regex.htm","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}],"keywords":[]},{"title":"Appium的数据配置与日志收集","slug":"Appium的数据配置与日志收集","date":"2021-09-03T10:18:34.000Z","updated":"2021-09-03T11:18:28.787Z","comments":true,"path":"2021/09/03/Appium的数据配置与日志收集/","link":"","permalink":"http://example.com/2021/09/03/Appium%E7%9A%84%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/","excerpt":"","text":"一、yaml概述1） yaml 简介 YAML 是一种简洁的非标记语言。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。 YAML特别适合在脚本语言中使用，列一下现有的语言实现：Ruby，Java，Perl，Python，PHP，JavaScript等。 YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。比如同一段数据Josn和Yaml的表示分别如下： jason 1&#123; name: &#x27;Tom Smith&#x27;,age: 37,spouse: &#123; name: &#x27;Jane Smith&#x27;, age: 25 &#125;,children: [ &#123; name: &#x27;Jimmy Smith&#x27;, age: 15 &#125;,&#123; name: &#x27;Jenny Smith&#x27;, age: 12 &#125; ] &#125; yaml 12345678910name: Tom Smithage: 37spouse: name: Jane Smith age: 25children: name: Jimmy Smith age: 15 name: Jenny Smith age: 12 2）语法特点【注意】 · 大小写敏感 · 使用缩进表示层级关系 · 缩进时不允许使用Tab键，只允许使用空格。 · 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 3）yaml下载安装 官网 · 下载安装：cmd 输入pip install pyyaml或者pip3 install pyyaml · 安装完成后在python引入yaml检测是否安装成功。 123456C:\\Windows\\System32&gt;pythonPython 3.6.6 (v3.6.6:4cf1f54eb7, Jun 27 2018, 03:37:03) [MSC v.1900 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import yaml&gt;&gt;&gt; 二、yaml数据支持类型1.支持数据类型 1. **纯量(scalars)**：单个的、不可再分的值 2. 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 3. 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 2.纯量 数据最小的单位，不可以再分割。类似于Python中单个变量 1flag 3.list数组 与Python的list结构类似，数组元素使用“-”开头，也可以根据缩进进行数组嵌套。 123456- Jack- Harry- Sunny# 也可以写成一行[Jack,Harry,Sunny] 对应到python的list写法如下： 1[&#x27;Jack&#x27;,&#x27;Harry&#x27;,&#x27;Sunny&#x27;] 4.对象 12345platformName: AndroidplatformVersion: 7.1.2# Yaml 也允许另一种写法，将所有键值对写成一个行内对象。&#123;platformName: Android,platformVersion: 7.1.2&#125; 注意：冒号后面一定要有空格！对应到python字典的写法如下： 1&#123;&#x27;platformName&#x27;: &#x27;Android&#x27;, &#x27;platformVersion&#x27;: &#x27;6.0.1&#x27;&#125; 数据嵌套 yaml数据嵌套表示可以将上面的各类数据根据实际场景进行组合嵌套。 数据场景： Tom Smith 37岁，他有一个妻子叫 Jane Smith，35岁。 另外他有2个孩子，一个叫Jimmy Smith，15岁；另外一个叫Jenny Smith ，12岁。 yaml语法表示如下： familyInfo.yaml 12345678910name: Tom Smithage: 37spouse: name: Jane Smith age: 35children: - name: Jimmy Smith age: 15 - name: Jenny Smith age: 12 转化为Python的写法为： 1&#123;&#x27;name&#x27;:&#x27;Tom Smith&#x27;,&#x27;age&#x27;:37,&#x27;spouse&#x27;:&#123;&#x27;name&#x27;:&#x27;Jane Smith&#x27;,&#x27;age&#x27;:25&#125;,&#x27;childern&#x27;:[&#123;&#x27;name&#x27;:&#x27;Jimmy Smith&#x27;,&#x27;age&#x27;:15&#125;,&#123;&#x27;name&#x27;:&#x27;Jenny Smith&#x27;,&#x27;age&#x27;:12&#125;]&#125; 三、yaml数据操作1.数据读取1）测试场景 · 读取配置中的所有信息 · 读取yaml数据表中Tom Smith的姓名、年龄、信息 · 单独读取配偶的姓名和年龄信息 · 分别读取两个孩子的姓名、年龄信息 2）load方法 load(stream, Loader=Loader) 解析文件流中的第一个YAML文档并生成相应的Python对象。 3）代码实现 12345678910111213141516171819mport yamlfile=open(&#x27;runtest.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(file)print(data)print(data[&#x27;name&#x27;])print(data[&#x27;age&#x27;])print(data[&#x27;spouse&#x27;])print(data[&#x27;spouse&#x27;][&#x27;name&#x27;])print(data[&#x27;spouse&#x27;][&#x27;age&#x27;])print(data[&#x27;children&#x27;])print(data[&#x27;children&#x27;][0][&#x27;name&#x27;])print(data[&#x27;children&#x27;][0][&#x27;age&#x27;])print(data[&#x27;children&#x27;][1][&#x27;name&#x27;])print(data[&#x27;children&#x27;][1][&#x27;age&#x27;]) 2.数据修改如果想改变某个数据，可以使用如下方法： 12345import yamlfile=open(&#x27;runTest.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(file)data[&#x27;name&#x27;]=&#x27;Test123&#x27;print(data[&#x27;name&#x27;]) 注意：此处只是变量类型的数据变更，不会真正修改到yaml配置表中的数据。 3.数据转化方法：dump()可以将Python对象序列化成YAML流。如果stream为None，则返回生成的字符串。 1）测试场景 将下面python数据类型转化为yaml数据类型 2）代码实践 1234567891011import yamlcity=[&#x27;changsha&#x27;,&#x27;wuhan&#x27;,&#x27;beijing&#x27;]person=&#123;&#x27;tom&#x27;:&#x27;18&#x27;&#125;#python dataprint(city)print(person)#yaml dataprint(yaml.dump(city))print(yaml.dump(person)) 运行结果： 1234567[&#x27;changsha&#x27;, &#x27;wuhan&#x27;, &#x27;beijing&#x27;]&#123;&#x27;tom&#x27;: &#x27;18&#x27;&#125;- changsha- wuhan- beijingtom: &#x27;18&#x27; 4.Capability配置数据分离1）测试场景 将capability的各项参数值与代码进行分离。 2）场景分析 我们可以把之前capability中各项写死的配置信息来抽离出来，存放在一个yaml配置文件中，使用 对象数据类型来存储数据；然后调用load()方法读取数据，从而实现数据和代码的分离。 3）代码实践 参数配置表：desired_caps.yaml 123456789platformName: AndroidplatformVersion: 7.1.2deviceName: 127.0.0.1:62025app: D\\kaoyan3.1.0.apknoReset: FalseappPackage: com.tal.kaoyanappActivity: com.tal.kaoyan.ui.activity.SplashActivityip: 127.0.0.1port: 4723 Python脚本 12345678910111213141516171819from appium import webdriverimport yamlfile=open(&#x27;desired_caps.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(file)desired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps) 报错分析 1yaml.scanner.ScannerError: mapping values are not allowed here 该报错说明map对象数据类型写法错误，一般为“：”后面没有留空格。如： platformName:Android 四、日志概述1）日志作用 不管是在项目开发还是测试过程中，项目运行一旦出现问题日志信息就非常重要了。日志是定位问题的重要手段，就像侦探人员要根据现场留下的线索来推断案情。 2）日志级别 脚本运行会有很多的情况，比如调试信息、报错异常信息等。日志要根据这些不同的情况来继续分级管理，不然对于排查问题的筛选会有比较大的干扰。 。日志一般定位的级别如下： 级别 何时使用 DEBUG 调试信息，也是最详细的日志信息。 INFO 证明事情按预期工作。 WARNING 表明发生了一些意外，或者不久的将来会发生问题（如‘磁盘满了’）。软件还是在正常工作。 ERROR 由于更严重的问题，软件已不能执行一些功能了。 CRITICAL 严重错误，表明软件已不能继续运行了。 首先我们日志需要按照info、debug、error等级别来进行区分的。当然这个级别可以自己去设置。在一般的情况下我们普通的输出我们直接用info类型，调试的时候用debug类型，如果预计有错误时那么我们就需要用error类型的日志，一般情况去info级别最为合适。 3）日志格式 日志格式化是为了提高日志的可阅读性，比如：时间+模块+行数+日志具体信息 的内容格式。如果日志信息杂乱无章的全部输出来，这样也不利于定位问题。 4）日志位置 一个项目中会有很多的日志采集点，而日志采集点必须结合业务属性来设置。比如在登录代码执行前可以插入“准备登录..”日志信息,如果登录完成之后，再设置登录的提示日志就会给人造成误解，无法判断到底是登录之前的问题还是登录之后的问题，因此日志采集点的位置很重要。 五、logging 模块1）简介 Python的logging模块提供了通用的日志系统，这个模块提供不同的日志级别，并可以采用不同的方式记录日志，比如文件，HTTP GET/POST，SMTP，Socket等，甚至可以自己实现方式记录日志。 12#导入logging模块import logging 2）logging构成 logging模块包括logger，Handler，Filter，Formatter四个部分。 · Logger 记录器，用于设置日志采集。 · Handler 处理器，将日志记录发送至合适的路径。 · Filter 过滤器，提供了更好的粒度控制，它可以决定输出哪些日志记录。 · Formatter 格式化器，指明了最终输出中日志的格式。 3）logger 记录器 Logger是一个树形层级结构，在使用接口debug，info，warn，error，critical；使用之前必须创建Logger实例，即创建一个记录器，如果没有显式的进行创建，则默认创建一个root logger，并应用默认的日志级别(WARN)，Handler和Formatter。 方法： basicConfig(参数) 为日志记录系统做基本配置。 部分参数 filename 指定日志文件名称 filemode 指定打开文件的模式，如果指定了filename（如果文件模式未指定，则默认为’a） 文件读写模式 1234567891011w 以写方式打开，W 文件若存在，首先要清空，然后（重新）创建a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)r+ 以读写模式打开w+ 以读写模式打开 (参见 w )a+ 以读写模式打开 (参见 a ) format 为处理程序使用指定的格式字符串 datefmt 使用指定的日期/时间格式。样式如果指定了格式字符串，则使用它来指定 格式字符串的类型. level 将根记录器级别设置为指定级别 12345678import logginglogging.basicConfig(level=logging.DEBUG)logging.basicConfig(level=logging.INFO)logging.debug(&#x27;debug info&#x27;)logging.info(&#x27;hello tom！&#x27;)logging.warning(&#x27;warning info&#x27;)logging.error(&#x27;error info&#x27;)logging.critical(&#x27;critical info&#x27;) 4）haddler 处理器 Handler 处理器，将日志记录发送至合适的路径,Handler处理器类型有很多种，比较常用的有三个： 1.streamhandler 将日志记录输出发送到诸如sys.stdout，sys.stderr或任何类似文件流的对象。 2.filehandler 将日志记录输出发送到磁盘文件。 它继承了StreamHandler的输出功能。 3.nullhandler 5）formatter 使用Formatter对象设置日志信息最后的规则、结构和内容，默认的时间格式为%Y-%m-%d %H:%M:%S。 *格式* *描述* %(levelno)s 打印日志级别的数值 %(levelname)s 打印日志级别名称 %(pathname)s 打印当前执行程序的路径 %(filename)s 打印当前执行程序名称 %(funcName)s 打印日志的当前函数 %(lineno)d 打印日志的当前行号 %(asctime)s 打印日志的时间 %(thread)d 打印线程id %(threadName)s 打印线程名称 %(process)d 打印进程ID %(message)s 打印日志信息 使用方法： 12345678import logginglogging.basicConfig(filename=&#x27;runlog.log&#x27;,level=logging.DEBUG,format=&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;)logging.debug(&#x27;debug info&#x27;)logging.info(&#x27;hello tom！&#x27;)logging.warning(&#x27;warning info&#x27;)logging.error(&#x27;error info&#x27;)logging.critical(&#x27;critical info&#x27;) 输出结果： 2021-09-02 11:50:20,094 ��־.py[line:5] DEBUG debug info2021-09-02 11:50:41,359 ��־.py[line:5] DEBUG debug info2021-09-02 11:50:41,360 ��־.py[line:6] INFO hello tom��2021-09-02 11:50:41,360 ��־.py[line:7] WARNING warning info2021-09-02 11:50:41,360 ��־.py[line:8] ERROR error info2021-09-02 11:50:41,360 ��־.py[line:9] CRITICAL critical info 六、logging实践操作1）测试场景 将前面所学的启动考研帮App的脚本增加log采集功能，设置指定的日志格式输出，并将日志保存到指定文件。 2）代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from appium import webdriverimport yamlfrom selenium.common.exceptions import NoSuchElementExceptionimport loggingfile=open(&#x27;desired_caps.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(file)logging.basicConfig(level=logging.INFO,filename=&#x27;runlog.log&#x27;, format=&#x27;%(asctime)s %(filename)s[line:%(lineno)d]%(levelname)s%(message)s&#x27;)desired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]logging.info(&#x27;start app...&#x27;)driver=webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;,desired_caps)def check_cancelBtn(): logging.info(&#x27;check cancelBtn&#x27;) try: cancelBtn = driver.find_element_by_id(&#x27;android:id/button2&#x27;) except NoSuchElementException: logging.info(&#x27;no cancelBtn&#x27;) else: cancelBtn.click()def check_skipBtn(): logging.info(&#x27;check skipBtn&#x27;) try: skipBtn = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;) except NoSuchElementException: logging.info(&#x27;no skipBtn&#x27;) else: skipBtn.click()check_cancelBtn()check_skipBtn() 3）日志格式配置 将log输出格式，输出路径等参数抽离出来作为一个配置表，如下所示： log.conf 1234567891011121314151617181920212223242526272829303132333435[loggers]keys=root,infoLogger[logger_root]level=DEBUGhandlers=consoleHandler,fileHandler[logger_infoLogger]handlers=consoleHandler,fileHandlerqualname=infoLoggerpropagate=0[handlers]keys=consoleHandler,fileHandler[handler_consoleHandler]class=StreamHandlerlevel=INFOformatter=form02args=(sys.stdout,)[handler_fileHandler]class=FileHandlerlevel=INFOformatter=form01args=(&#x27;runlog.log&#x27;, &#x27;a&#x27;)[formatters]keys=form01,form02[formatter_form01]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s[formatter_form02]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s 在需要调用的模块增加如下代码： 1234567import loggingimport logging.configCON_LOG=&#x27;log.conf&#x27;logging.config.fileConfig(CON_LOG)logging=logging.getLogger() 方法： 1fileConfig(fname, defaults=None, disable_existing_loggers=True) 该放在作用是从ConfigParser格式的文件中读取日志配置，同时如果当前脚本有配置log参数，则覆盖当前log配置选项。 6）代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from appium import webdriverimport yamlfrom selenium.common.exceptions import NoSuchElementExceptionimport loggingimport logging.configstream=open(&#x27;desired_caps.yaml&#x27;,&#x27;r&#x27;)data=yaml.load(stream)CON_LOG=&#x27;log.conf&#x27;logging.config.fileConfig(CON_LOG)logging=logging.getLogger()desired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps)def check_updateBtn(): logging.info(&quot;check_pdateBtn&quot;) try: element = driver.find_element_by_id(&#x27;android:id/button2&#x27;) except NoSuchElementException: logging.info(&#x27;update element is not found!&#x27;) else: element.click()def check_skipBtn(): logging.info(&quot;check_skipBtn&quot;) try: element = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;) except NoSuchElementException: logging.info(&#x27;skipBtn element is not found!&#x27;) else: element.click()check_updateBtn()check_skipBtn()","categories":[],"tags":[{"name":"appium的数据配置与日志手机","slug":"appium的数据配置与日志手机","permalink":"http://example.com/tags/appium%E7%9A%84%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA/"}],"keywords":[]},{"title":"Appium基础操作","slug":"Appium基础操作","date":"2021-09-02T09:39:25.000Z","updated":"2021-09-04T05:06:44.218Z","comments":true,"path":"2021/09/02/Appium基础操作/","link":"","permalink":"http://example.com/2021/09/02/Appium%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","excerpt":"","text":"一、name 定位根据name进行定位，对于android来说，就是text属性 但是由于text稳定性不是很好，所以appium 1.5开始废弃了该方法。 123from Capability import *driver.find_element_by_name(&#x27;请输入用户名&#x27;).send_keys(&#x27;&#x27;)driver.find_element_by_name(&#x27;登录&#x27;).click() 二、classname 定位classname定位是根据元素类型来进行定位，在元素class中，一般有id不使用classname定位。 1234from Capability import *driver.find_element_by_class_name(&#x27;android.widget.EditText&#x27;).send_keys(&#x27;hj18594962283&#x27;)driver.find_element_by_class_name(&#x27;android.widget.EditText&#x27;).send_keys(&#x27;jxx.hxx21.&#x27;)driver.find_element_by_class_name(&#x27;android.widget.Button&#x27;).click() 三、相对定位相对定位是先找到该元素的有对应属性的父元素节点，然后基于父元素进行元素定位。 案例 通过打开考研帮注册界面 123456from Capability import driverdriver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_register_text&#x27;).click()root_element=driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_parentlayout&#x27;)root_element.find_element_by_class_name(&#x27;android.widget.ImageView&#x27;).click() 四、xpath定位xpath定位是一种路径定位方式，主要是依赖于元素绝对路径或者相关属性来定位，但是绝对路径xpath执行效率比较低（特别是元素路径比较深的时候），一般使用比较少。通常使用xpath相对路径和属性定位。 表达式 描述 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 nodename 选取此节点的所有子节点。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 使用xpath定位元素来进行登录操作。 1234from Capability import driverdriver.find_element_by_xpath(&#x27;//android.widget.EditText[@text=&quot;请输入用户名&quot;]&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_xpath(&#x27;//*[@class=&quot;android.widget.EditText&quot; and @index=&quot;3&quot;]&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_xpath(&#x27;//android.widget.Button&#x27;).click() 五、LIST 定位List定位首先是使用find_elements_by_XX获取一组相同的class属性的元素，然后使用数组下标来区分标记不同元素进行相关操作。 通过考研帮注册，选择指定头像 1234567891011from Capability import driverdriver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_register_text&#x27;).click()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_userheader&#x27;).click()images=driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/item_image&#x27;)images[2].click()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/save&#x27;).click() 经过实践执行测试用户注册功能时，发现无法完成注册功能，可能与APP有关 执行的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from Capability import driverimport random#进入注册界面选择并设置头像driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_register_text&#x27;).click()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_userheader&#x27;).click()images=driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/item_image&#x27;)images[2].click()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/save&#x27;).click()#注册信息填写username=&#x27;Test&#x27;+&#x27;FLY&#x27;+str(random.randint(1000,9000))print(&#x27;username: %s&#x27; %username)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_username_edittext&#x27;).send_keys(username)password=&#x27;appium&#x27;+str(random.randint(1000,9000))print(&#x27;password: %s&#x27; %password)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_password_edittext&#x27;).send_keys(password)email=&#x27;pwd&#x27;+str(random.randint(1000,9000))+&#x27;@163.com&#x27;print(&#x27;email: %s&#x27; %email)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_email_edittext&#x27;).send_keys(email)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_register_btn&#x27;).click()#院校选择driver.find_element_by_id(&#x27;com.tal.kaoyan:id/perfectinfomation_edit_school_name&#x27;).click()#选择省份driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/more_forum_title&#x27;)[1].click()#选择具体院校--同济大学driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/university_search_item_name&#x27;)[1].click()#专业选择driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_perfectinfomation_major&#x27;).click()#选择经济学类-统计学-经济统计学driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/major_subject_title&#x27;)[1].click()driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/major_group_title&#x27;)[2].click()driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/major_search_item_name&#x27;)[1].click()#点击“进入考研帮”按钮driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_perfectinfomation_goBtn&#x27;).click() 六、UIAutomator定位简介UIAutomator元素定位是 Android 系统原生支持的定位方式，虽然与 xpath 类似，但比它更加好用，且支持元素全部属性定位.定位原理是通过android 自带的android uiautomator的类库去查找元素。使用如下：find_element_by_android_uiautomator() 可以运用UiAutomator元素定位。 定位方法 · id定位 · text定位 · class name定位 id定位是根据元素的resource-id属性来进行定位，使用 UiSelector().resourceId()方法即可。 1234567from Capability import driverdriver.find_element_by_android_uiautomator(&#x27;newUiSelector().resourceId(&quot;com.tal.kaoyan:id/login_email_edittext&quot;)&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_android_uiautomator(&#x27;newUiSelector().resourceId(&quot;com.tal.kaoyan:id/login_password_edittext&quot;)&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_android_uiautomator&#x27;new UiSelector().resourceId(&quot;com.tal.kaoyan:id/login_login_btn&quot;)&#x27;).click() 七、元素等待作用设置元素等待可以更加灵活的制定等待定位元素的时间，从而增强脚本的健壮性，提高执行效率。 元素等待类型分为强制等待、隐式等待、显示等待 强制等待 设置固定的等待时间，使用sleep()方法即可实现 123from time import sleep#强制等待2秒sleep(2) 隐式等待 隐式等待是针对全部元素设置的等待时间 1driver.implicitly_wait(40) 显式等待 显示等待是针对某个元素来设置的等待时间 方法WebDriverWait格式参数如下： 12345678910from selenium.webdriver.support.ui import WebDriverWaitWebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)driver : WebDrivertimeout : 最长超时时间，默认以秒为单位poll_frequency : 休眠时间的间隔时间，默认为0.5秒ignored_exceptions : 超时后的异常信息，默认情况下抛NoSuchElementException异常。WebDriverWait()一般和until()或until_not()方法配合使用，另外，lambda提供了一个运行时动态创建函数的方法。from selenium.webdriver.support.ui import WebDriverWaitWebDriverWait(driver,10).until(lambda x:x.find_element_by_id(&quot;elementID&quot;)) 八、截图方法方法一 save_screenshot() 该方法直接保存当前屏幕截图到当前脚本所在文件位置。 1driver.save_screenshot(&#x27;login.png&#x27;) 方法二 截图保留到指定文件路径 1driver.get_screenshot_as_file(&#x27;./images/login.png&#x27;) “./“是在运行的py的目录下，images是存在该目录里，如果没有这个文件夹，需要手动建立 考研帮登录后截图测试脚本 1234567891011from Capability import driverdriver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).clear()driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)driver.save_screenshot(&#x27;login.png&#x27;)driver.get_screenshot_as_file(&#x27;./images/login.png&#x27;)driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_login_btn&#x27;).click() 九、滑动效果在Appium中模拟用户滑动操作需要使用swipe方法，该方法定义如下： 12345678910111213def swipe(self, start_x, start_y, end_x, end_y, duration=None): &quot;&quot;&quot;Swipe from one point to another point, for an optional duration. :Args: - start_x - x-coordinate at which to start - start_y - y-coordinate at which to start - end_x - x-coordinate at which to stop - end_y - y-coordinate at which to stop - duration - (optional) time to take the swipe, in ms. :Usage: driver.swipe(100, 100, 100, 400) 注释———-swipe()方法的参数说明： start_x：起始横坐标 start_y：起始纵坐标 end_x：结束时横坐标 end_y：结束时纵坐标 duration：滑动持续时间，单位毫秒，默认None（一般设置500-1000毫秒比较合适） 实现平面上各个方向位置滑动 通过调用get_size()、swipeLeft()函数来实现滑动效果 1234567891011121314151617#获取屏幕尺寸def get_size(): x=driver.get_window_size()[&#x27;width&#x27;] y=driver.get_window_size()[&#x27;height&#x27;] return x,y#显示屏幕尺寸（width,height）l=get_size()print(l)#向左滑动def swipeLeft(): l=get_size() x1=int(l[0]*0.9) y1=int(l[1]*0.5) x2=int(l[0]*0.1) driver.swipe(x1,y1,x2,y1,1000) Capability.py 123456789101112131415161718192021222324252627282930313233343536373839404142from appium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptiondesired_caps=&#123;&#125;desired_caps[&#x27;platformName&#x27;]=&#x27;Android&#x27;desired_caps[&#x27;deviceName&#x27;]=&#x27;127.0.0.1:62025&#x27;desired_caps[&#x27;platforVersion&#x27;]=&#x27;7.1.2&#x27;desired_caps[&#x27;app&#x27;]=r&#x27;d:\\kaoyan.apk&#x27;desired_caps[&#x27;appPackage&#x27;]=&#x27;com.tal.kaoyan&#x27;desired_caps[&#x27;appActivity&#x27;]=&#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;desired_caps[&#x27;noReset&#x27;]=&#x27;False&#x27;driver=webdriver.Remote(&#x27;http://localhost:4723/wd/hub&#x27;,desired_caps)driver.implicitly_wait(2)def check_cancelBtn(): print(&#x27;check cancelBtn&#x27;) try: cancelBtn = driver.find_element_by_id(&#x27;android:id/button2&#x27;) except NoSuchElementException: print(&#x27;no cancelBtn&#x27;) else: cancelBtn.click()def check_skipBtn(): print(&#x27;check skipBtn&#x27;) try: skipBtn=driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;) except NoSuchElementException: print(&#x27;no skipBtn&#x27;) else: skipBtn.click()check_cancelBtn()check_skipBtn()","categories":[],"tags":[{"name":"appuim 基础","slug":"appuim-基础","permalink":"http://example.com/tags/appuim-%E5%9F%BA%E7%A1%80/"}],"keywords":[]},{"title":"monkey日志管理","slug":"monkey日志管理","date":"2021-09-01T11:43:05.000Z","updated":"2021-09-01T11:51:10.789Z","comments":true,"path":"2021/09/01/monkey日志管理/","link":"","permalink":"http://example.com/2021/09/01/monkey%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/","excerpt":"","text":"自定义脚本的稳定性测试常规Monkey测试执行的是随机的事件流，但如果只是想让Monkey测试某个特定场景这时候就需要用到自定义脚本了，Monkey支持执行用户自定义脚本的测试，用户只需要按照Monkey脚本的规范编写好脚本，存放到手机上，启动Monkey通过-f 参数调用脚本即可 需求分析获取元素坐标点位置Monkey脚本只能通过****坐标****的方式来定位点击和移动事件的屏幕位置，这里就需要提前获取坐标信息。获取坐标信息的方法很多，最简单的方法就是打开手机中的开发人员选项，打开“显示指针位置”。随后，在屏幕上的每次操作，在导航栏上都会显示坐标信息。 monkey脚本APILaunchActivity(pkg_name, cl_name)：启动应用的Activity。参数：包名和启动的Activity。 Tap(x, y, tapDuration)： 模拟一次手指单击事件。参数：x,y为控件坐标，tapDuration为点击的持续时间，此参数可省略。 UserWait(sleepTime)： 休眠一段时间 DispatchPress(keyName)： 按键。参数： keycode。 RotateScreen(rotationDegree, persist)： 旋转屏幕。 参数：rotationDegree为旋转角度， e.g. 1代表90度；persist表示旋转之后是否固定，0表示旋转后恢复，非0则表示固定不变。 DispatchString(input)： 输入字符串。 DispatchFlip(true/false)： 打开或者关闭软键盘。 PressAndHold(x, y, pressDuration)： 模拟长按事件。 Drag(xStart, yStart, xEnd, yEnd, stepCount)： 用于模拟一个拖拽操作。 PinchZoom(x1Start, y1Start, x1End, y1End, x2Start, y2Start, x2End, y2End, stepCount)： 模拟缩放手势。 LongPress()： 长按2秒。 DeviceWakeUp()： 唤醒屏幕。 PowerLog(power_log_type, test_case_status)： 模拟电池电量信息。 WriteLog()： 将电池信息写入sd卡。 RunCmd(cmd)： 运行shell命令。 DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFlags)： 向指定位置，发送单个手势。 DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFilags)： 发送按键消息。 LaunchInstrumentation(test_name,runner_name)： 运行一个instrumentation测试用例。 DispatchTrackball： 模拟发送轨迹球事件。 ProfileWait： 等待5秒。 StartCaptureFramerate()： 获取帧率。 EndCaptureFramerate(input)： 结束获取帧率。 monkey脚本格式头部 123456type = raw events count = 1 speed = 1.0 //下面为monkey命令 start data &gt;&gt; 具体的monkey脚本内容 编写脚本 kyb.txt 1234567891011121314151617181920212223242526272829#头文件信息type = raw events count = 1speed = 1.0#启动测试start data &gt;&gt;LaunchActivity(com.tal.kaoyan,com.tal.kaoyan.ui.activity.SplashActivity)UserWait(2000)Tap(624,900,1000) #点击取消升级UserWait(2000)Tap(806,64,1000) #点击跳过UserWait(2000)Tap(217,378,1000) #点击用户名输入框DispatchString(账户)UserWait(2000)Tap(197,461,1000) #点击密码输入框DispatchString(密码)UserWait(2000)Tap(343,637,1000) #点击登录按钮 执行脚本 脚本编写完成后，传到手机设备上，然后执行。 123adb push C:\\Users\\admin\\Desktop\\kyb1.txt /sdcardadb shell monkey -f /sdcard/kyb1.txt -v 1 执行结果 123456789101112131415C:\\Users\\admin&gt;adb shell monkey -f /sdcard/kyb.txt -v 1:Monkey: seed=1524592021303 count=1:IncludeCategory: android.intent.category.LAUNCHER:IncludeCategory: android.intent.category.MONKEYReplaying 0 events with speed 1.0:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.tal.kaoyan/.ui.activity.SplashActivity;end // Allowing start of Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.tal.kaoyan/.ui.activity.SplashActivity &#125; in package com.tal.kaoyan:Sending Touch (ACTION_DOWN): 0:(267.0,1233.0) // Allowing start of Intent &#123; act=com.android.systemui.recent.action.TOGGLE_RECENTS cmp=com.android.systemui/.recent.RecentsActivity &#125; in package com.android.systemui:Sending Touch (ACTION_UP): 0:(267.0,1233.0)Events injected: 5:Sending rotation degree=0, persist=false:Dropped: keys=0 pointers=0 trackballs=0 flips=0 rotations=0## Network stats: elapsed time=7201ms (0ms mobile, 0ms wifi, 7201ms not connected)// Monkey finished 注意事项 头文件代码书写注意“=”两边预留空格，否则会出现如下报错 1java.lang.NumberFormatException: Invalid int: &quot;&quot; 参考资料","categories":[],"tags":[{"name":"monkey日志管理","slug":"monkey日志管理","permalink":"http://example.com/tags/monkey%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"}],"keywords":[]},{"title":"monkey","slug":"monkey","date":"2021-08-31T10:13:54.000Z","updated":"2021-09-01T11:41:54.865Z","comments":true,"path":"2021/08/31/monkey/","link":"","permalink":"http://example.com/2021/08/31/monkey/","excerpt":"","text":"monkey 理论monkey定义andriod自动化测试工具，对被测程序进行压力测试，检查和评估被测程序的稳定性。 monkey官方文档 monkey路径Monkey程序是Android系统自带的，其启动脚本是位于Android系统的/system/bin目录的Monkey文件，其jar包是位于Android系统的/system/framework目录的Monkey.jar文件。用户主要是通过adb命令来启动Monkey的，Monkey在运行时，会根据命令行参数的配置，生成伪随机的事件流，并在Android设备上执行对应的测试事件。 monkey 启动步骤 连接模拟器 12adb connect 127.0.0.1:62001#连接adb devices#检查设备连接情况 连接成功后输入命令 1adb shell 进入到指定目录1cd /system/bin 输入monkey 命令看到一串信息提示就是成功，没有报错即可。 强制关闭 monkey adb shell ps 查看全部在运行的进程 查找出com.android.commands.monkey 进程PID adb shell kill pid 杀掉monkey进程 monkey 命令monkey命令格式如下： 1$ adb shell monkey [options] &lt;event-count&gt; · [options] 是指monkey可传入的参数，是可选项（如果不指定options，Monkey将以无反馈模式启动，并把事件任意发送到安装在目标环境中的全部包） · 是指随机发送事件数。如：输入100就是执行100个伪随机事件，为必选项。 monkey 参数参数分类· 常规类参数 · 事件类参数 · 约束类参数 · 调试类参数 1.常规类参数常规类参数包括帮助参数和日志信息参数。 1.帮助类参数 1monkey -h 2.日志级别 1$ adb shell monkey -v &lt;event-count&gt; -v：打印出日志信息，每个-v将增加反馈信息的级别。-v越多日志信息越详细，不过目前最多支持3个-v 2.事件类参数1.执行指定脚本 1234$ adb shell monkey -f &lt;scriptfile&gt; &lt;event-count&gt;eg：$ adb shell monkey -f /mnt/sdcard/test1 2.伪随机数生成种子值 1234$ adb shell monkey -s &lt;seed&gt; &lt;event-count&gt;eg:$ adb shell monkey -s 666 100 3.设置间隔 如果你希望在每一个指令之间加上固定的间隔时间，可以用–throttle（注意，前面是–）命令。 123$ adb shell monkey --throttle &lt;milliseconds&gt;eg:$ adb shell monkey --throttle 3000 5 –throttle：后面接时间，单位为ms（），表示事件之间的固定延迟（即执行每一个指令间隔的时间），若不接该选项，monkey将不会延迟。 4.调整触摸事件百分比 如果你希望调整触摸事件的百分比，记住使用–pct-touch。 123$ adb shell monkey --pct-toucheg:$ adb shell monkey -v -v --pct-touch 100 200 注意：触摸事件不单单是按键，它泛指发生在某一位置的一个down-up事件 5.调整手势事件百分比 123$ adb shell monkey --pct-motioneg:$ adb shell monkey -v -v --pct-motion 100 200 6.调整应用启动事件的百分比 1$ adb shell monkey --pct-appswtich &lt;percent&gt; 7.调整屏幕旋转事件百分比 1$ adb shell monkey --pct-rotation &lt;percent&gt; 约束类参数1.包约束 -p：后面接一个或多个包名（&lt;”allowed-package-name”&gt;），如果应用需要访问其他包里的Activity，那相关的包也需要在此同时指定。如果不指定任何包，monkey将允许系统启动全部包里的Activity。 12345$ adb shell monkey -p &lt;allowed-package-name&gt; &lt;event-count&gt;eg：$ adb shell monkey -p com.tal.kaoyan 500$ adb shell monkey -p com.tal.kaoyan -p com.tencent.mm 500 2.activity类约束 1adb shell monkey -c &lt;main-category&gt; &lt;event-count&gt; 调试类参数1.应用程序崩溃后继续发送时间 1$ adb shell monkey --ignore-crashes &lt;event-count&gt; 2.超时错误继续发送事件 1$ adb shell monkey --ignore-timeouts 3.应用程序权限错误发生后继续发送事件 1$ adb shell monkey --ignore-security-exceptions 测试命令 12345678adb shell monkey -p com.tal.kaoyan--pct-touch 40 --pct-motion 25 --pct-appswitch 10--pct-rotation 5-s 1666 --throttle 400--ignore-crashes--ignore-timeouts-v -v 200","categories":[],"tags":[{"name":"monkey","slug":"monkey","permalink":"http://example.com/tags/monkey/"}],"keywords":[]},{"title":"MonkeyRunner API","slug":"MonkeyRunner-API","date":"2021-08-31T05:58:58.000Z","updated":"2021-08-31T10:08:08.649Z","comments":true,"path":"2021/08/31/MonkeyRunner-API/","link":"","permalink":"http://example.com/2021/08/31/MonkeyRunner-API/","excerpt":"","text":"MonkeyRunner工具主要有三个类： MonkeyRunner MonkeyDevice MonkeyImage ​ 官方API文档 1.MonkeyRunner 类：MonkeyRunner提供连接真机和模拟器、输入、暂停、警告框等方法 alert() 警告框 choice() 选项列表框 help() API帮助文档 input() 输入 sleep() 暂停 waitForConnection() 等待设备连接 常用方法waitForConnection(float timeout,string deviceid)， 12345from com.android.monkeyrunner import MonkeyRunner as mrprint(&quot;connect devices...&quot;)device=mr.waitForConnection()# device=mr.waitForConnection(5,&#x27;127.0.0.1:62001&#x27;) 2.MonkeyDevices类MonkeyDevice类提供了安装和卸载程序包、开启Activity、发送按键和点击事件、运行测试包等方法。 broadcastInternt() 发送广播 drag() 拖动 getProperty() 获取当前设备属性 getSystemProperty() 获取当前设备属性 installPackage() 安装应用 instrument() 执行测试用例 press() 按键 reboot() 重启 removePackage() 删除指定Package shell() 执行命令 startActivity() 启动应用 touch() 点击 常用方法 · installPackage (string path) · removePackage (string package) · startActivity (string uri, string action, string data, string mimetype, iterable categories dictionary extras, component component, flags) · touch (integer x, integer y, integer type) touch参数说明 integer x，x坐标值。integer y，y坐标值。integer type，key event类型（如DOWN、UP、DOWN_AND_UP）。 DOWN为按下事件 UP为弹起事件 DOWN_AND_UP为按下弹起事件。 · drag (tuple start, tuple end, float duration, integer steps) drag参数详细说明如下： tuple start，拖拽起始位置，为tuple类型的(x,y)坐标点。tuple end，拖拽终点位置，为tuple类型的(x,y)坐标点。float duration，拖拽手势持续时间，默认为1.0s。-integer steps，插值点的步数，默认值为10。 实践案例：连接设备，安装考研帮App并启动 代码如下： 1234567891011121314151617181920from com.android.monkeyrunner import MonkeyRunner as mrfrom com.android.monkeyrunner import MonkeyDevice as mdprint(&quot;connect devices...&quot;)device=mr.waitForConnection()print(&quot;install app...&quot;)device.installPackage(r&#x27;C:\\Users\\admin\\Desktop\\kaoyan3.1.0.apk&#x27;)package = &#x27;com.tal.kaoyan&#x27;activity = &#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;runComponent = package + &#x27;/&#x27; + activityprint(&quot;launch App...&quot;)device.startActivity(component=runComponent)代码执行方式monkeyrunner scripfileC:\\Users\\admin&gt;monkeyrunner E:\\monkeyrunner_script\\kyb.py 3.MonkeyImage类MonkeyImage类在测试过程中用来保存各种格式的测试截图，并可以进行图像对比。 convertToBytes() 转换图像格式 getRawPixel() 获取当前坐标像素元组 getRawPixelint() 获取当前坐标像素元组 sameAs() 图像对比 writeToFile() 保存图像文件 getSubimage() 截取子图像 常用方法 · takeSnapshot() 进行屏幕截图 · writeToFile() 保存图像文件到指定的文件路径 用法示例 1234from com.android.monkeyrunner import MonkeyImage as mi print(&quot;takeSnapshot&quot;)screenshot=device.takeSnapshot() screenshot.writeToFile(r&#x27;E:\\monkeyrunner_script\\test.png&#x27;,&#x27;png&#x27;) 综合实践测试场景· 连接设备，自动安装并启动考研帮app · 启动后登录账号，然后截图并保存到指定文件位置。 思路分析· 连接设备 · 安装app · 启动app · 输入用户名密码点击登录按钮 · 截图 脚本实现kyb_login.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344from com.android.monkeyrunner import MonkeyRunner as mrfrom com.android.monkeyrunner import MonkeyDevice as mdfrom com.android.monkeyrunner import MonkeyImage as miprint(&quot;connect devices...&quot;)device=mr.waitForConnection()print(&quot; install app&quot;)device.installPackage(r&#x27;C:\\Users\\admin\\Desktop\\kaoyan3.1.0.apk&#x27;)print(&quot;launch app...&quot;)package=&#x27;com.tal.kaoyan&#x27;activity=&#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;runComponent=package+&#x27;/&#x27;+activitydevice.startActivity(component=runComponent)mr.sleep(3)print(&quot;touch cancel button&quot;)device.touch(618,895,&#x27;DOWN_AND_UP&#x27;)mr.sleep(1)print(&quot;touch skip button&quot;)device.touch(804,67,&#x27;DOWN_AND_UP&#x27;)mr.sleep(1)print(&quot;input username and password&quot;)device.touch(57,373,&#x27;DOWN_AND_UP&#x27;)mr.sleep(2)device.type(账户)device.touch(152,480,&#x27;DOWN_AND_UP&#x27;)mr.sleep(2)device.type(密码)mr.sleep(2)print(&quot;touch login button&quot;)device.touch(331,634,&#x27;DOWN_AND_UP&#x27;)print(&quot;takeSnapshot&quot;)screenshot=device.takeSnapshot()screenshot.writeToFile(r&#x27;D:\\monkeyrunner\\kyb.png&#x27;,&#x27;png&#x27;) 注意事项方法调用错误 1AttributeError: type object &#x27;com.android.monkeyrunner.XXXXX&#x27; has no attribute XXXXXX 检查调用的方法名是否写错，特别是注意区分大小写。 字符编码错误 1SyntaxError: Non-ASCII character in file &#x27;E:\\monkeyrunner_script\\kyb.py&#x27;, but no encoding declared; 需要在代码顶部补充 # -- coding: utf-8 -- 或者去掉代码中的中文字符","categories":[],"tags":[{"name":"Monkeyrunner","slug":"Monkeyrunner","permalink":"http://example.com/tags/Monkeyrunner/"}],"keywords":[]},{"title":"从0开始搭建一个博客站点","slug":"从0开始搭建一个博客站点","date":"2021-08-30T07:41:14.000Z","updated":"2021-08-30T10:37:50.229Z","comments":true,"path":"2021/08/30/从0开始搭建一个博客站点/","link":"","permalink":"http://example.com/2021/08/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/","excerpt":"","text":"1.Hexo的入门 hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。 hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。 参考：官网文档 1.1安装node.js网上安装教程 验证安装是否成功 进入cmd 输入node -v 出现相应的版本号ok 12C:\\Windows\\System32&gt;node -vv14.17.5 1.2安装gitgit安装教程 验证git安装成功与否 进入cmd 输入 git version 出现相应的版本号ok 12C:\\Windows\\System32&gt;git versiongit version 2.33.0.windows.2 1.3安装、配置hexo文件1.进入git bash窗口 2.输入以下命令 1npm install -g hexo-cli 3.出现一堆代码 4.输入以下命令 123hexo init d:/文件夹名 ----表示在d盘创建这个文件夹 cd 文件名 ----进入文件夹 npm install ----安装 1.4关于hexo文件夹里面的内容1.4.1 hexo文件目录安装hexo完毕，d盘目录下你创建的文档下面的内容： 1234567891011├── _config.yml├── .deploy_git├── .github├── public├── themes├── source| └── .gitkeep ├── scraffolds| ├── draft.md ├── page.md └── post.md 1.4.2 hexo目录文件介绍（了解）_confifig.yml 网站的配置信息，您可以在此配置大部分的参数。 package.json 已经默认给你安装的应用程序的信息 scaffffolds 模版文件夹。当您新建文章时，Hexo 会根据 scaffffold 来建立文件，了解即可 source 资源文件夹是存放用户资源的地方。一般你通过命令创建的文章都存储在 _posts 文件夹里面 themes 这个主要存放的hexo的主题文件，类似英雄皮肤，通过更改不同主题来实现不同酷炫的效果。 1.5_confifig.yml配置文件详解（了解）1.5.1网站相关 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 你的名字 language 网站使用的语言 timezone 网站时区时区列表 1.5.2网址相关 参数 描述 url 网址 root 网站根目录 permalink 文章永久链接 格式 permalink_defaults 永久链接中各部分的默认值 1.5.3目录相关 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public archive_dir 标签文件夹 tags category_dir 归档文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 1.5.4日期与格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 1.6hexo相关命令指令参考 1.7建立远程博客访问1.7.1 本地启动hexo启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可： 1hexo server 或者 hexo s 浏览器访问网址：http://localhost:4000/ 至此，你的hexo本地博客已经搭建成功。 1.7.2GithubPages的使用在开始之前创建github官网账号，并创建一个仓库 注意仓库名的格式： 仓库名为：Github账号名称.github.io 1.安装 hexo-deployer-git插件。在命令（Git Bash）运行以下命令 $ npm install hexo-deployer-git --save 2.添加SSH key 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可。 邮箱地址和注册github的邮箱保持一致。 $ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如 C:\\users\\administrator\\.ssh\\id_rsa.pub)，粘贴到 New SSH KEY即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com $ yes 3.修改 _config.yml （在站点目录下）。文件末尾修改为： 123456# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy:type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面的格式type和repo的冒号后面需要空格两下； ​ 上面仓库地址写ssh地址，不写http地址 。 4.推送到GithubPages。在命令行（即Git Bash）依次输入以下命令，返回 INFO Deploy done: git即成功推送： 12$ hexo g $ hexo d 或 1$ hexo g -d 5.等待1分钟左右，浏览器访问网址： https://&lt;Github账号 名称&gt;.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为 https://&lt;Github账号名称&gt;.github.io 。","categories":[],"tags":[{"name":"hexo 搭建","slug":"hexo-搭建","permalink":"http://example.com/tags/hexo-%E6%90%AD%E5%BB%BA/"}],"keywords":[]},{"title":"胡俊学习经历","slug":"胡俊学习经历","date":"2021-08-28T08:38:36.000Z","updated":"2021-09-07T09:25:43.982Z","comments":true,"path":"2021/08/28/胡俊学习经历/","link":"","permalink":"http://example.com/2021/08/28/%E8%83%A1%E4%BF%8A%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86/","excerpt":"","text":"黑盒测试一、测试活动1、需求分析2、测试计划3、用例设计4、用例执行5、测试报告（天猫项目）二、等价类测试法1. 什么是等价类是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。2、划分等价类可以把全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件就可以用少量代表性的测试数据取得较好的测试结果3、划分等价类的方法1）区间；2）数值集合划分；3）输入是布尔量，确定有效和无效等价类；4）按照数值划分；5）按照限制条件或规则划分；6）细分等价类4、设计测试用例（原则）1）为每一个等价类规定一个唯一的编号；2）设计一个新的测试用例,使其尽可能多地覆盖尚未被覆盖地有效等价类,重复这一步，直到所有的有效等价类都被覆盖为止；3） 设计一个新的测试用例,使其仅覆盖一个尚未被覆盖的无效等价类,重复这一步，直到所有的无效等价类都被覆盖为止；（三角形案例）三、边界值分析1.定义边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。2.与等价类的区别边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。3.边界值分析设计1）确定边界情况；2）选取正好等于、刚刚大于、刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据；健壮性测试：有效和无效均要测试；0作为边界值要反复测试强性测试：有效覆盖弱性测试：无效覆盖弱健壮性：有效、无效均覆盖部分三角形问题的边界值分析测试用例","categories":[],"tags":[{"name":"黑盒测试","slug":"黑盒测试","permalink":"http://example.com/tags/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"}],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2021-08-27T11:11:52.026Z","updated":"2021-08-27T11:11:52.026Z","comments":true,"path":"2021/08/27/hello-world/","link":"","permalink":"http://example.com/2021/08/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"Webdriver 的应用","slug":"Webdriver-的应用","date":"2021-08-18T07:31:26.000Z","updated":"2021-09-07T01:30:06.503Z","comments":true,"path":"2021/08/18/Webdriver-的应用/","link":"","permalink":"http://example.com/2021/08/18/Webdriver-%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"一、webdriver 的概述、环境搭建Webdriver (Selenium2）是一种用于 Web 应用程序的自动测试工具，它提供了一套友好的 API，与 Selenium 1（Selenium-RC）相比，Webdriver 的 API 更容易理解和使用，其可读性和可维护性也大大提高。Webdriver 完全就是一套类库，不依赖于任何测试框架，除了必要的浏览器驱动，不需要启动其他进程或安装其他程序，也不必像 Selenium 1 那样需要先启动服务。 (1)支持浏览器 Firefox （FirefoxDriver） IE（InternetExplorerDriver） Opera（OperaDriver） Chrome （ChromeDriver） safari（SafariDriver） (2)支持语言 Java C# PHP Python (3)安装，卸载、查看 安装：pip install selenium==XXXX 卸载 pip uninstall selenium 查看版本号： pip show selenium (4)环境的搭建 前提要求： 安装好 python 解释器 安装好 pycharm 软件 实现步骤： 下载好 geckodriver 驱动 下载地址：https://github.com/mozilla/geckodriver/releases 然后解压，把文件放到 python 解释器的安装目录 Pycharm 里面导入 selenium 模块 二、第一个自动化测试的脚本(1) 实现案例： 启动火狐浏览器， 首先打开网易首页，打印网页标题，等待 3 秒 打开百度首页，打印网页标题，再等待 2 秒 关闭浏览器。 (2)实现代码 1234from selenium import webdriver from time import sleep #加载浏览器驱动 driver=webdriver.Firefox() #打开网易首页 driver.get(&quot;http://www.163.com&quot;) #打印标题 print(driver.title) sleep(3) #打开百度首页 driver.get(&quot;http://www.baidu.com&quot;)print(driver.title) sleep(3) #关闭浏览器driver.quit() 三、浏览器操作的方法1.浏览器的操作方法： 1 .浏览器窗口大小设置：set_window_size(宽,高) 2 .页面前进、后退：back()、forward() 3 .页面刷新：refresh() 2. 案例：访问京东页面和京东男装页面 打开京东，等 2 秒 打开京东男装，设置窗口为(400,800) 刷新一下页面，等 2 秒 后退，等 2 秒 前进，等 2 秒 关闭窗口 3.实现代码： 123456789from selenium import webdriver from time import sleep driver=webdriver.Firefox()#打开京东 driver.get(&quot;https://www.jd.com&quot;) driver.maximize_window() sleep(2) #打开京东男装 driver.get(&quot;https://channel.jd.com/1315-1342.html&quot;) #设置页面的窗体大小 driver.set_window_size(400,800)#刷新一下页面 driver.refresh() sleep(2) #后退 driver.back() sleep(2)#前进 driver.forward() sleep(2) driver.quit() 四、元素的定位(1) 通过 id 选择器、****name 值去定位元素 打开网页 右击检查元素或者 F12 可以看到 id 与 name 案例：打开百度，输入”码云”，点击搜素按钮 1 打开百度网址 2 定位到输入框，输入“码云” 3 定位到搜素按钮，点击一下 4 打开搜素页面 实现代码： 123456789101112131415161718192021from selenium import webdriverfrom time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) #百度输入框的 id 名 kw driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;码云&quot;) #百度输入框的 name 属性值 kw #driver.find_element_by_name(&quot;wd&quot;).send_keys(&quot;码云&quot;) sleep(2) #百度的搜素按钮的 id 名为 su driver.find_element_by_id(&quot;su&quot;).click() 可以看出：.send_keys(“值”) 表示在输入框输入的值 (2) 通过通过标签名(tag_name)来定位 页面 html 文档下的各种标签： find_element_by_tag_name(“input”)； tag 往往用来定义一类功能，所以通过 tag 识别某个元素的概率 很低。任意打开一个页面，都会发现大量的、、等 tag，所以 tag name 定位很少用 (3) 通过 class_name 来定位 根据标签中属性 class 来进行定位的一种方法 案例： 1 打开百度 2 通过类名定位输入框，搜素“龟叔” 3 然后点击搜素，弹出搜素页面 实现代码： 12345from selenium import webdriver from time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) #百度输入框在类名 s_ipt 中 driver.find_element_by_class_name(&quot;s_ipt&quot;).send_keys(&quot;龟叔&quot;) sleep(2) driver.find_element_by_id(&quot;su&quot;).click() sleep(5) driver.quit() (4) 通过 link_Text 定位：专门用来定位文本链接 对象名.find_element_by_link_name(“text”)； 1#页面右上方的一些个人操作，比如退出、个人中心、消息通知等 driver.find_element_by_link_text(u&quot;退出&quot;).click() (5) XPath 定位：（了解） 对象名.find_element_by_xpath(“xpath 路径”)； 1）绝对路径定位： 对于没有 id，name、classname 不好定位的，可以通过 Firefox 可以方便的获取到 xpath 值 2） 利用元素属性定位： find_element_by_xpath(“.//[@id=’Title’]”)，这里是用的 id，也可以用元素其他能够唯一标识的属性，不局限于 id、name、 class 这些；代表的是标签名，不指定时就可以用*代替 3）层级与属性结合：下图中就是这种 案例代码： 123# 登录 driver.find_element_by_xpath(&quot;.//*[@id=&#x27;divword&#x27;]/input[7]&quot;).click()#个人页面的发布课程操作 driver.find_element_by_xpath(&quot;html/body/div[4]/div/div[2]/div/div[3]/a[1]&quot;).click() CSS 定位 Selenium 极力推荐使用 CSS 定位，而不是 XPath 来定位元素，原因是 CSS 定位比 XPath 定位速度快，语法也更加简洁。 (6) CSS 常用定位方法 find_element_by_css_selector（） #id id 选择器根据 id 属性来定位元素 class class 选择器，根据 class 属性值来定位元素 [attribute=’value’] 根据属性来定位元素 element&gt;element 根据元素层级来定位 父元素&gt;子元素 案例代码： 1234567891011from selenium import webdriver from time import sleepdriver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) #根据 id 来定位 driver.find_element_by_css_selector(&#x27;#kw&#x27;).send_keys(&quot;今日头条&quot;) #根据 class 定位 driver.find_element_by_css_selector(&#x27;.s_ipt&#x27;).send_keys(&#x27;python&#x27;) #通过属性来定位driver.find_element_by_css_selector(&quot;[autocomplete=&#x27;off&#x27;]&quot;).send_keys(&quot;selenium&quot;) sleep(2) driver.find_element_by_id(&#x27;su&#x27;).click() driver.get(&quot;http://www.toutiao.com&quot;) #通过元素层级来定位 driver.find_element_by_css_selector(&quot;form#loginForm&gt;ul&gt;input&quot;).send_keys(&quot;今日头条&quot;)sleep(2) driver.quit() (7) 下拉菜单定位 下拉菜单元素定位 案例：在今日头条登录页面选择指定的保留时间。 下面的案例可能会随着网页的内容改版，会失效，请参考思路。 1.根据选项元素标签定位 1234from selenium import webdriver from time import sleep from selenium.webdriver.support.ui import Select driver=webdriver.Firefox() driver.get(&quot;http://www.toutiao.com&quot;) sleep(2) #根据 option 标签来定位 driver.find_elements_by_tag_name(&#x27;option&#x27;)[1].click() driver.find_element_by_css_selector(&quot;[value=&#x27;2&#x27;]&quot;).click() sleep(2) driver.quit() 2.使用 Select 类定位 1234567from selenium import webdriverfrom time import sleep from selenium.webdriver.support.ui import Select driver=webdriver.Firefox() driver.get(&quot;http://www.toutiao.com&quot;) sleep(2) #利用 Select 类来进行定位 select = Select(driver.find_element_by_css_selector(&quot;[name=&#x27;CookieDate&#x27;]&quot;))select.select_by_index(2) select.select_by_visible_text(&quot;留一年&quot;) select.select_by_value(&quot;1&quot;)sleep(2) driver.quit() 五、鼠标键盘的操作1. 实现思路 需要引入 ActionChains 类 然后定位相关元素 在 ActionChains().调用相关鼠标操作方法 123456789from selenium import webdriverfrom selenium.webdriver.common.action_chains import ActionChains from time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) driver.maximize_window() driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(&quot;Python&quot;) # 获取搜索框元素对象 element=driver.find_element_by_css_selector(&quot;#kw&quot;) sleep(3) #双击操作 ActionChains(driver).double_click(element).perform() sleep(2) #右击操作 ActionChains(driver).context_click(element).perform() sleep(3)#鼠标悬停 above=driver.find_element_by_css_selector(&quot;.pf&quot;) ActionChains(driver).move_to_element(above).perform() sleep(4) driver.quit() 2. 键盘操作 案例： 在百度搜索关键词“Python” 然后将关键词复制或剪切到搜狗搜索框进行搜索 1234567891011121314from selenium import webdriver from selenium.webdriver.common.keys import Keys from time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(&quot;Python&quot;) sleep(2) #键盘全选操作 Ctrl+A driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(Keys.CONTROL,&#x27;a&#x27;) #键盘选择复制或剪切操作 Ctrl+C driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(Keys.CONTROL,&#x27;c&#x27;) driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(Keys.CONTROL,&#x27;x&#x27;)#打开搜狗页面 driver.get(&quot;http://www.sogou.com/&quot;) sleep(2) #粘贴复制内容 driver.find_element_by_css_selector(&quot;.sec-input&quot;).send_keys(Keys.CONTROL,&#x27;v&#x27;) sleep(2) #点击搜索按钮 # driver.find_element_by_xpath(&quot;//input[@id=&#x27;stb&#x27;]&quot;).click() driver.find_element_by_css_selector(&quot;#stb&quot;).click() sleep(3) driver.quit() 3. 元素的等待 显示等待是针对某一个元素进行相关等待判定； 隐式等待不针对某一个元素进行等待，全局元素等待。 a.相关模块 WebDriverWait 显示等待针对元素必用 expected_conditions 预期条件类（里面包含方法可以调用，用于显示等待） NoSuchElementException 用于隐式等待抛出异常 By 用于元素定位 123456from selenium import webdriverfrom selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait #注意字母大写 from selenium.webdriver.support importexpected_conditions as EC from selenium.common.exceptions import NoSuchElementException b.显示等待 案例：检测百度页面搜索按钮是否存在，存在就输入关键词“Selenium” 然后点击搜索 123456789from selenium import webdriverfrom selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By from time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(&quot;Selenium&quot;)sleep(2)#显示等待--判断搜索按钮是否存在 element=WebDriverWait(driver,5,0.5).until(EC.presence_of_element_located((By.ID,&quot;su&quot;))) element.click() sleep(3)driver.quit() C.隐式等待 123456789101112from selenium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionfrom time import sleep,ctime driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) sleep(2) driver.implicitly_wait(5) #隐式等待时间设定 5 秒#检测搜索框是否存在 try: print(ctime()) driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys(&quot;Python&quot;) driver. find_element_by_css_selector(&quot;#su&quot;).click except NoSuchElementException as msg: print(msg) finally: print(ctime())sleep(3) driver.quit() 六、警告弹窗的处理 案例：点击百度首页设置按钮，然后进入搜索设置页面， 点击“保存设置”或“恢复默认”按钮，处理警告弹窗窗口 12345678from selenium import webdriver from time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) driver.find_element_by_link_text(&#x27;设置&#x27;).click() sleep(2) driver.find_element_by_link_text(&#x27;搜索设置&#x27;).click() sleep(3)driver.find_element_by_link_text(&#x27;保存设置&#x27;).click() # driver.find_element_by_link_text(&#x27;恢复默认&#x27;).click() sleep(3)#处理警告窗口 alert=driver.switch_to_alert() alert.accept() sleep(2) sleep(2) driver.quit() 七、文件上传 案例：在百度搜索上传本地图片进行搜索。 12345678from selenium import webdriverfrom time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;)driver.find_element_by_css_selector(&quot;.soutu-btn&quot;).click() sleep(3) driver.find_element_by_css_selector(&quot;.upload-pic&quot;).send_keys(r&quot;E:\\Python_script\\Web driver\\shuiyin.png&quot;) sleep(3) # driver.quit() 八、浏览器滚动操作 案例：打开京东页面，然后将滚动条拖到最底部，然后再拖到顶部 1234567891011from selenium import webdriverfrom time import sleep driver=webdriver.Firefox() driver.get(&quot;https://www.jd.com/&quot;) sleep(2)#将滚动调拖到最底部 js=&quot;var action=document.documentElement.scrollTop=10000&quot; driver.execute_script(js)sleep(2) #将滚动条拖到最顶部 js=&quot;var action=document.documentElement.scrollTop=0&quot; driver.execute_script(js) sleep(3)driver.quit() 九、网页自动截图 案例：打开百度页面，然后进行截图 12345678from selenium import webdriver from time import sleep #加载浏览器驱动 driver=webdriver.Firefox()#打开百度页面并截图driver.get(&quot;http://www.baidu.com&quot;) driver.get_screenshot_as_file(r&quot;E:\\Python_script\\baidu.png&quot;) sleep(2) driver.quit() 十、Cookie 处理1. 什么是 cookie Cookie 是储存在用户本地终端上的数据，实际上是一小段的文本信息。 2. Cookie 的作用 帮助 Web 站点保存有关访问者的信息，方便用户的访问。 如记住用户名密码实现自动登录。 案例：查看访问京东时的 Cookie 内容 12345678from selenium import webdriver driver=webdriver.Firefox() driver.get(&quot;http://www.jd.com/&quot;) #获取 cookie 全部内容 cookie=driver.get_cookies() #打印全部 cookile 信息 print(cookie) #打印 cookie 第一组信息 print(cookie[0]) driver.quit() 3. 验证码作用 不少网站在用户登录、用户提交信息等登录和输入的页面上使用了验证码技术。验证码 技术可以有效防止恶意用户对网站的滥用，使得网站可以有效避免用户信息失窃、保证网站 稳定安全性。 但是验证码给自动化测试带来一些不便，使脚本无法正常运行覆盖功能模块。 十一、验证码的处理 1.去掉验证码 这是最简单的方法，对于开发人员来说，只是把验证码的相关代码注释掉即可，如果 是在测试环境，这样做可省去了测试人员不少麻烦，如果自动化脚本是要在正式环境跑，这 样就给系统带来了一定的风险。 2.设置万能码 去掉验证码的主要是安全问题，为了应对在线系统的安全性威胁，可以在修改程序时不 取消验证码，而是程序中留一个“后门”—设置一个“万能验证码”，只要用户输入这个 “万能验证码”，程序就认为验证通过，否则按照原先的验证方式进行验证。 3.记录 cookie 通过向浏览器中添加 cookie 可以绕过登录的验证码。 十二、基于 Cookie 绕过验证码案例：使用 Cookie 绕过百度验证码自动登录账户。 12345678from selenium import webdriver from time import sleep driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com/&quot;) #手动添加 cookie driver.add_cookie(&#123;&#x27;name&#x27;:&#x27;BAIDUID&#x27;,&#x27;value&#x27;:&#x27;9E4BF1D44014…(根据实际获取值填写)&#x27;&#125;) driver.add_cookie(&#123;&#x27;name&#x27;:&#x27;BDUSS&#x27;,&#x27;value&#x27;:&#x27;根据实际抓包获取值填写&#x27;&#125;) sleep(2) driver.refresh() sleep(3) driver.quit()","categories":[],"tags":[{"name":"webdriver","slug":"webdriver","permalink":"http://example.com/tags/webdriver/"}],"keywords":[]},{"title":"JavaScript","slug":"JavaScript","date":"2021-08-14T08:28:58.000Z","updated":"2021-09-04T10:06:41.848Z","comments":true,"path":"2021/08/14/JavaScript/","link":"","permalink":"http://example.com/2021/08/14/JavaScript/","excerpt":"","text":"一、什么是javascriptJavaScript 是可插入 HTML 页面的编程代码。 JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行 这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 Js三部分： es语法、浏览器[BOM]对象、文档【DOM】对象 二、Es语法1、js的快速入门——写法 内嵌在script标签 123&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;123&quot;) &lt;/script&gt; 外部链接 1&lt;script type=&quot;text/javascript&quot; src=&quot;../js/js1.js&quot; &gt;&lt;/script&gt; 2、js的输出 Document.write( ):输出内容在网页上面 Console.log(): 输出内容在控制台上面 3、变量、数据类型： 变量：程序执行中，其值可以改变的量；变量是一个容器，存储数据。 Var a=10; Var:声明变量的关键字 a是变量,在这个变量里面存了10 变量取名的时候注意： 123456&lt;script type=&quot;text/javascript&quot;&gt; //声明一个变量 var num1=false; //输出变量 document.write(num1) &lt;/script&gt; 数据类型： Boolean ——布尔 string ——字符串 Number ——数字 Underfind—— 未定义的数据类型 Js是一门弱类型的语言，数据类型的取值取决于赋给变量的值！！！ ① Js的声明变量关键字是var ② js同时声明两个不同的数据类型 ③ js变量可以存放不同类型的值 ④ js变量名声明不是必须的 typeof（）检测数据类型 12var num1=false;document.write(typeof(num1)) 4、js的运算符 算术： 加、减 、乘、除、++、– 单独给某个变量++或者–的时候，它会自增1或自减1； 比较：&gt;、&lt; &gt;= != &lt;= 区分： = :赋值 把右边赋值给左边 ==：比较两个值相等，不考虑数据类型 === ：考虑数据类型和值一样时，为true，否则false 结果只有两种，true和false 条件: var n3=(n2&gt;n1)?n2:n1; 解释：如果n2值大于n1，把n2的值赋给n3 否则相反 12345var n1=123; var n2=25; var n3=(n2&gt;n1)?n2:n1; document.write(n3)//25 逻辑: &amp;&amp; || ！ 逻辑运算符两边连接的是布尔类型的值 赋值： = += -= *= /= 把右边值赋值 运算符左边 5、程序的结构 程序的结构： 顺序结构【默认】：自上而下 选择结构： 程序自上而下执行时，遇到了什么条件，就会做出什么选择！ 循环结构 程序自上而下执行时，遇到了什么条件，就会做出循环 选择结构：if…else 12345678910//1.初始化值 var age=10; //2.判断条件 if(age&gt;=18)&#123; //3.执行语句1 document.write(&quot;可以上网&quot;) &#125;else&#123; //语句2 document.write(&quot;洗洗睡&quot;) &#125; for 循环： 12345678910111213循环——for 输出100句 你好 1.初始化值 var n=1; 2.循环的判断语句 n&lt;=100; 3.循环体语句 你好 4.控制循环语句 n++; for(初始化值;循环判断条件;控制循环语句)&#123; 循环体语句; &#125; for(var n=1;n&lt;=100;n++)&#123; document.write(&quot;你好&quot;); &#125; 6、数组 什么是数组？——数据的容器 存放一组数据(多个类型的) 长度不是固定 没有赋值定义的类型都是undefined 怎么声明数组？ var 数组名=new Array(); var 数组名=new Array(“值1”，”值2”) 1234&lt;script type=&quot;text/javascript&quot;&gt; var arr=new Array(&quot;张三&quot;,&quot;李四&quot;,123); document.write(arr.length) &lt;/script&gt; var 数组名=[“值1”,“值2”,”值3”] 数组结合循环来做遍历 1234567&lt;script type=&quot;text/javascript&quot;&gt; var arr=new Array(&quot;张三&quot;,&quot;李四&quot;,123);// document.write(arr[0]) for (var i=0;i&lt;arr.length;i++) &#123; document.write(arr[i]);//0 1 2 &#125; &lt;/script&gt; 7、字符串：“上海的自来水来自海上” CharAt():通过下标找单个字符 indexOf:字符串中某一个指定的字符首次出现的位置 12345&lt;script type=&quot;text/javascript&quot;&gt; var str=&quot;上海的自来水来自海上&quot;; //var n=str.charAt(0); document.write(str.indexOf(&quot;上&quot;)) &lt;/script&gt; [substring()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_substring.asp) 提取字符串中两个指定的索引号之间的字符。 包前不包后 详细用法： 手册——javascript——js字符串——详细用法 8、函数 函数是由事件驱动的 或者当他被调用时执行的可重复使用的代码块 系统函数与自定义 isNan() 值是数字给false，否则给true 字符串转换成数字： parseInt（） 格式： parseInt(转换的变量) 注意：字符串转换的数字只能是字符串开头的数字 parseFloat 案例： 前提：通过js代码输出html代码 1234567document.write(&quot;&lt;font size=&#x27;24&#x27; color=&#x27;red&#x27;&gt;文字&lt;/font&gt;&lt;br/&gt;&quot;) &lt;script type=&quot;text/javascript&quot;&gt; for (var i=1;i&lt;=10;i++) &#123; document.write(&quot;&lt;font size=&#x27;24&#x27; color=&#x27;red&#x27;&gt;文字&lt;/font&gt;&lt;br/&gt;&quot;) &#125; &lt;/script&gt; 请使用js来输出一个四行两列的表格！！！ 偶数行为绿色，奇数行为红色 自定义函数： 自己来写函数 如果你想让你的函数运行有效果，必须绑定事件【用户的动作——点击、打开了网页(加载)】 函数语法： function 函数名(){ //代码块 } 事件：用户的动作——点击 onclick——点击事件 先写好函数——这个函数具有什么功能？【里面代码块决定】 往html标签【如按钮】绑定事件【点击】同时加上函数名() 思路： 123456781.用html写出效果2.写个函数，通过点击事件绑定 “计算”按钮 A.先获取1-2框里面的值，判断是什么类型？string--&gt;number B.获取select的id--&gt;option的value--&gt;+ 、- 、* 、/ C.通过选择结构--&gt;根据用户选择+、-、*、/计算结果 if..else if ...else D.获取结果框的value,然后把计算结果赋值给它 代码： 参考计算器案例 9、date对象 日期对象用于处理日期和时间。 定义日期： var 对象名 = new Date()； 或 var 对象名 = new Date(“2020-04-10”)； 对象名.方法名() To方法组： [toDateString()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_toDateString.asp) 把 Date 对象的日期部分转换为字符串。 123456789&lt;script type=&quot;text/javascript&quot;&gt; //1.创建一个Date对象 var d=new Date(); //2.调用方法 var n=d.toDateString()//转换成字符串 document.write(typeof(n)) document.write(n) &lt;/script&gt; [toString()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_toString_date.asp) 把 Date 对象转换为字符串。 123456789&lt;script type=&quot;text/javascript&quot;&gt; //1.创建一个Date对象 var d=new Date(); //2.调用方法 var n=d.toString()//转换成字符串 document.write(typeof(n)) document.write(n) &lt;/script&gt; Get方法组： [getFullYear()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getFullYear.asp) 从 Date 对象以四位数字返回年份。 12345&lt;script type=&quot;text/javascript&quot;&gt; var d=new Date(); var y=d.getFullYear() document.write(y) &lt;/script&gt; [getDate()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getDate.asp) 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 [getDay()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getDay.asp) 从 Date 对象返回一周中的某一天 (0 ~ 6)。 [getMonth()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getMonth.asp) 从 Date 对象返回月份 (0 ~ 11)。 [getHours()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getHours.asp) 返回 Date 对象的小时 (0 ~ 23)。 [getMinutes()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getMinutes.asp) 返回 Date 对象的分钟 (0 ~ 59)。 [getSeconds()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getSeconds.asp) 返回 Date 对象的秒数 (0 ~ 59)。 [getMilliseconds()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getMilliseconds.asp) 返回 Date 对象的毫秒(0 ~ 999)。 [getTime()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_getTime.asp) 返回 1970 年 1 月 1 日至今的毫秒数。 123456&lt;script type=&quot;text/javascript&quot;&gt; var d=new Date();// d.setDate(12); d.setMonth(1)//0 document.write(d) &lt;/script&gt; 10、math(算数)对象： 详细了解 [abs(x)](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_abs.asp) 返回数的绝对值。 X：表示参数 [floor(x)](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_floor.asp) 对数进行下舍入。 [ceil(x)](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_ceil.asp) 对数进行上舍入。 [max(x,y)](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_max.asp) 返回 x 和 y 中的最高值。 [min(x,y)](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_min.asp) 返回 x 和 y 中的最低值。 随机数： [random()](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_random.asp) 返回 0 ~ 1 之间的随机数。 四舍五入： [round(x)](mk:@MSITStore:D:\\第1小节\\day 03 web前端基础与安全分析\\手册\\W3School离线手册.chm::/www.w3school.com.cn/jsref/jsref_round.asp) 把数四舍五入为最接近的整数。 保留多少位小数： var d=12.345232;document.write(d.toFixed(3)) 三、BOM浏览器对象模型详细手册 1. 定义： 浏览器对象模型 (BOM)，使 JavaScript 有能力与浏览器“对话”、交互 浏览器对象模型（Browser Object Model）尚无正式标准。 2.BOM的分类 1.window对象———-是浏览器对象模型中的顶层对象 2.navigator对象———包含有关访问者的信息 3.screen对象————-包含用户屏幕的信息 4.history对象———–包含浏览器历史 5.location对象———-用于获取当前页面地址 6.document对象———-操作HTML标签、cookie 3.Window对象 所有浏览器都支持 *window* 对象。它表示浏览器窗口。 prompt函数：用户点击确定拿到输入内容，点击取消啥也没有 ​ 对话框 1234&lt;script type=&quot;text/javascript&quot;&gt; var n=prompt(&quot;请输入.....&quot;) document.write(n) &lt;/script&gt; alert函数——警告框 123&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;123&quot;) &lt;/script&gt; confirm函数——确认框 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; var n=confirm(&quot;你确定吗？&quot;)//返回结果布尔类型 if(n==true)&#123; for(var i=1;i&lt;=10;i++)&#123; alert(i) &#125; &#125;else&#123; document.write(&quot;你好呀&quot;) &#125; document.write(n) &lt;/script&gt; close函数 ​ 关闭顶层窗口 12345&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; window.close() &#125; &lt;/script&gt; open函数 ​ 格式： ​ window.open(“弹出窗口的url”,”窗口名称”,”窗口特征1=值,窗口特征2=值”); 1234567&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; for (var i=1;i&lt;=10;i++) &#123; window.open(&quot;https://www.baidu.com&quot;,i,&quot;height=200px,width=300px&quot;); &#125; &#125; &lt;/script&gt; 4.local对象 window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。 1234567&lt;script type=&quot;text/javascript&quot;&gt; document.write(location.search) document.write(location.href) document.write(location.host) document.write(location.port) document.write(location.protocol) &lt;/script&gt; search：？问号后面的 href：完整的 host:主机名 port:当前的端口号 protocol：返回当前的协议 1.加载一个新的网页——assign（url） 注意：历史记录有记录 ctrl+H 12345&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; location.assign(&quot;https://www.baidu.com&quot;) &#125; &lt;/script&gt; 2.刷新当前页面 reload() 12345&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; location.reload() &#125; &lt;/script&gt; 3.替换当前页面 ​ replace(url)——历史记录会覆盖现有的历史记录 5.history 对象 12345678&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; history.back()//后退 &#125; function fn2()&#123; history.forward()//前进 &#125; &lt;/script&gt; 6.navigator 对象的介绍 window.navigator 对象包含有关访问者浏览器的信息。 appName 属性返回浏览器的应用程序名称： appCodeName 属性返回浏览器的应用程序代码名称： appVersion 返回浏览器的平台和版本信息 navigator 详细说明 7.screen 对象包含有关用户屏幕的信息 width：宽度 height:高度 screen.availWidth 属性返回访问者屏幕的宽度，以像素计，减去诸如窗口工具条之类的界面特征。 8.延时器和定时器【重点】 设定的时间间隔之后来执行代码 而不是在函数被调用后立即执行 setTimeout() 未来的某时执行代码 1var t=setTimeout(&quot;javascript语句&quot;,毫秒) 案例代码：设置延时器与清除延时器 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; var t;//为什么t声明在这儿？？ function fn1()&#123; alert(&quot;123&quot;) &#125; function fn2()&#123; t=setTimeout(&quot;fn1()&quot;,3000); &#125; function fn3()&#123; clearTimeout(t); &#125; &lt;/script&gt; 定时器： tt=setInterval(函数名,毫秒值); ​ 当我隔多少秒调用这个函数，周期性的调用 clearInterval(tt) ​ 清除定时或者延时的效果用这个 四、dom对象详细手册","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}],"keywords":[]},{"title":"http协议","slug":"http协议","date":"2021-08-10T05:58:20.000Z","updated":"2021-09-04T06:48:19.562Z","comments":true,"path":"2021/08/10/http协议/","link":"","permalink":"http://example.com/2021/08/10/http%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"一、http协议简介1）协议简介超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的 一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了 提供一种发布和接收 HTML(超文本标记语言) 页面的方法。 HTTP 协议在网络 OSI 模型中属于应用层协议，应用层协议除了 HTTP 还有：FTP， SMTP，DNS，RIP，Telnet 等。 HTTP 协议工作于客户端—服务端架构上。浏览器作为 HTTP 客户端通过 URL(网址) 向 HTTP 服务端（即 Web 服务器） 发送请求。 2）什么是超文本？超文本英文名称叫做 Hypertext，我们在浏览器里面看到的网页就是超文本解析而成的， 其网页源代码是一系 列 HTML 代码，里面包含了一系列标签，如 img 显示图片，p 指定显 示段落等，浏览器解析这些标签后便形成了我们平常看到的网页，而这网页的源代码 HTML 就可以称作超文本。 例如我们在 Chrome 浏览器里面打开如百度页面，右键点击”查看源代码”，这些源代 码都是超文本。 3）什么是URL？我们在浏览器的地址栏里输入的网站地址叫做 URL (Uniform Resource Locator，统 一资源定位符)。就像每家每 户都有一个门牌地址一样，每个网页也都有一个 Internet 地 址（如：http://www.baidu.com）。 当你在浏览器的 地址框中输入一个 URL 或是单击一个超级链接时，URL 就确定了要浏 览的地址。浏览器通过超文本传输协议(HTTP)， 将 Web 服务器上站点的网页代码提取出 来，并翻译成漂亮的网页。 4）http 功能HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从服务器传输 超文本到本地浏览器的传输协议。 它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本 文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 5）http的特点无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户端的请求，并收到 客户端的应答后， 即断开连接。采用这种方式可以节省传输时间。 媒体独立：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可 以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 来传输。无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。如果服务 器不需要先前信 息，那么它的应答就比较快。但是缺少状态意味着如果后续处理需要前面 的信息，则它必须重传，这样可 能导致每次连接传送的数据量增大，此时可以设置缓存。 6）HTTP和HTTPS 的区别现在在浏览很多网站时，通过浏览器地址栏可以看到有的网站是 https 开头 （https://www.baidu.com/ ）, 但是 有的是 http 开头（如： http://www.weather.com.cn ）这两种有什么区别呢？难道加了 s 就是复数吗？ HTTPS 的全称是 Hyper Text Transfer Protocol over Secure Socket Layer，是以 安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层（Secure Sockets Layer 安全套接层），简称为 HTTPS。 S 其实是 Security 单词的首字母 HTTPS 的安全基础是 SSL，因此通过它传输的内容都是经过 SSL 加密的，它的主要作用 可以分为两种： 是建立一个信息安全通道，来保证数据传输的安全。 确认网站的真实性，凡是使用了 https 的网站，都可以通过点击浏览器地址栏的锁头标 志来查看网站认证之 后的真实信息，也可以通过 CA 机构颁发的安全签章来查询。现在越来越多的网站和 APP 都已经向 HTTPS 方向发展。例如：谷歌从 2017 年 1 月推出的 Chrome 56 开始， 对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户“此网页不安全”。 7）http与tcp/ip的特点：TCP/IP 协议是传输层协议，主要解决数据如何在网络中传输，而 HTTP 是应用层协 议，主要解决如何包装数据。 关于 TCP/IP 和 HTTP 协议的关系，网络有一段比较容易理解的介绍：“我们在传输 数据时，可以只使用（传输层） TCP/IP 协议，但是那样的话，如果没有应用层，便无法 识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很 多，比如 HTTP、FTP、TELNET 等，也可以自己定义应用层协议。 WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做 传输层协议将它发到网络上。” 二、http请求我们在浏览器输入百度首页的地址：https://www.baidu.com/ 输入之后浏览器会给 我们打开百度首页。 实际上这 个过程是浏览器向网站所在的服务器发送了一个 Request，即请求，网站服 务器接收到这个 Request 之后进行处 理和解析，然后返回对应的一个 Response，即响 应，然后传回给浏览器，Response 里面就包含了页面的源代码等内容，浏览器再对其进行解析便将网页呈现了出来。 例子：使用火狐浏览器，打开百度，查看页面的请求过程 点击呈现详细步骤 1）请求的四部分•Request Method: 请求方式 •Request URL: 请求链接 •Request Headers: 请求头 •Request Body: 请求体 2）请求方式—抓用户名和密码请求方式，常见的两种类型： GET 用于信息获取，而且应该是安全的和幂等的(幂等的的意思就是一个操作不会修改 状态信息，并且每次操作的时候都返回同样的结果。) 从发送请求的角度，GET 请求相当 于我们在数据库中做了查询的操作， 这样的操作不影响数据库本身的数据。 POST 表示可能会修改服务器上资源的请求，也相当于在数据库中做了修改的操作， 会影响数据库本身的数据（比如：注册了账户，发了帖子，做了评论，得到了积分等。这种 情况下，资源状态被改变了）。 案例： get请求： 1在浏览器地址栏输入：https://www.baidu.com/s?wd=appium并回车,这个其实就是在百度搜索appium这个关键词。URL中包含了请求的参数信息，这里参数wd就是要搜寻的关键字 post请求： 1234一般来说，网站登录验证的时候，需要提交用户名密码，这里包含了敏感信息，使用 GET 方式请求的话密码就会 暴露在 URL 里面，造成密码泄露，所以这里最好以 POST 方 式发送。文件的上传时，由于文件内容比较大，也会 选用 POST 方式。比如百度账户登 录，如下图所示： 例如：使用火狐浏览器抓用户名和密码 当然也可以使用fiddler抓包 3）请求网址（url）Request URL 就是请求的网址，即统一资源定位符，用 URL 可以唯一确定我们想请求的资源。 比如： https://www.baidu.com/ 4）请求头（request headers）请求头，用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、Referer、 User-Agent 等，下面将一些 常用的头信息说明如下： 123456789Accept，请求报头域，用于指定客户端可接受哪些类型的信息。 • Accept-Language，指定客户端可接受的语言类型。 • Accept-Encoding，指定客户端可接受的内容编码。 • Host，用于指定请求资源的主机 IP 和端口号，其内容为请求 URL 的原始服务器或网关 的位置。从 HTTP 1.1 版本开始，Request 必须包含此内容。 • Cookie，也常用复数形式 Cookies，是网站为了辨别用户进行 Session 跟踪而储存在 用户本地的数据。Cookies 的主要功能就是维持当前访问会话。 • Referer，此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做 相应的处理，如 做来源统计、做防盗链处理等。 • User-Agent，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统 及版本、浏览器 及版本等信息。 • Content-Type，即 Internet Media Type，互联网媒体类型，也叫做 MIME 类型，在 HTTP 协议消息头 中，使用它来表示具体请求中的媒体类型信息。例如 application/x-www-form-urlencoded 表示表单数 据， text/html 代表 HTML 格式， image/gif 代表 GIF 图片，application/json 代表json文件 5）请求体即请求体，一般用于 POST 请求中，主要定义向服务器提交的数据类型，而对于 GET 请求 Request Body 则为 空。 比如在登录之前我们填写了用户名和密码信息，提交时就这些内容就会以 Form Data 的形式提交给服务器，此时注意 Request Headers 中指定了 Content-Type 为 application/x-www-form-urlencoded。 Postman看 只有设 置 Content-Type 为 application/x-www-form-urlencoded 才会以 Form Data 形式提交，另外我们也可以 将 Content-Type 设置为 application/json 来 提交 Json 数据，或者设置为 multipart/form-data 来上传文件。 常用 Content-Type 和 POST 提交数据方式的关系： Content-Type 提交数据方式 application/x-www-form-urlencoded Form表单提交 multipart/form-data 表单文件上传提交 application/jason 序列化Json数据提交 text/html XML数据提交 三、http的响应1）响应的三部分上述内容讲述的 http 协议的请求，接着描述 http 协议的响应。 Response，即响应，由服务端返回给客户端。Response 可以划分为三部分: • Response Status Code ：响应状态码 • Response Headers ：响应头 • Response Body ：响应提 Response Status Code 响应状态码，此状态码表示了服务器的响应状态，如 200 则代表服务器正常响应，404 则代表页面未找到，500 则 代表服务器内部发生错误。常用响应状态码如下： 可以参考完整的 http 协议的响应状态码： 响应状态码的含义 1XX： 请求未完成 2XX: 表示响应成功 3XX：表示转发/重定向 4XX: 路径找不到 5XX：服务器内部资源错误 2）响应头响应头，其中包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等，下面将一些常用的头信息说明如下： *Date，标识 Response 产生的时间。 Last-Modified，指定资源的最后修改时间。 •Content-Encoding，指定 Response 内容的编码。 •server，包含了服务器的信息，名称，版本号等。 •Content-Type，文档类型，指定了返回的数据类型是什么，如 text/html 则代表返回 HTML 文档， application/x-javascript 则代表返回 JavaScript 文件，image/jpeg 则 代表返回了图片。 • Set-Cookie，设置 Cookie，Response Headers 中的 Set-Cookie 即告诉浏览器需要 将此内容放在 Cookies 中，下次请求携带 Cookies 内容。 **• Expires,**指定 Response 的过期时间，使用它可以控制代理服务器或浏览器将内容更 新到缓存中，如果再 次访问时，直接从缓存中加载，降低服务器负载，缩短加载时间。 3）响应体即响应体，响应的正文数据都是在响应体中，如请求一个网页，它的响应体就是网页的 HTML 代码，请求一张图 片，它的响应体就是图片的二进制数据。","categories":[],"tags":[{"name":"http协议","slug":"http协议","permalink":"http://example.com/tags/http%E5%8D%8F%E8%AE%AE/"}],"keywords":[]},{"title":"软件测试","slug":"软件测试","date":"2021-08-01T03:51:16.000Z","updated":"2021-09-07T09:10:56.487Z","comments":true,"path":"2021/08/01/软件测试/","link":"","permalink":"http://example.com/2021/08/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/","excerpt":"","text":"一、软件研发流程1. 软件产品的特点计算机软件是由程序及其文档组成，关于软件的特点，我们可以总结如下： a. 是一种逻辑产品，与物质产品有很大的区别。 b. 软件产品的生产主要是研制，生产成本主要在开发和研制，开发研制完成后，通过复制就产生了大量软件产品。 c. 软件产品不会用坏，不存在磨损，消耗。 d. 生产主要是脑力劳动，还末完全摆脱手工开发方式，大部分产品是”定做”的。 2. 软件工程1.什么是软件工程？软件工程一直以来都缺乏一个统一的定义，很多学者、组织机构都分别给出了自己的定义。但具体总结起来就是几个关键点： ​ 系统化、规范化、可管理、将软件开发变成一项工程。 2. 为什么需要软件工程？早期做软件是小作坊式的生产，后来随着硬件的提升，用户的需求。小作坊明显解决不了问题，就出现了软件危机 软件危机(Software Crisis) 是计算机软件在它的开发和维护过程中所遇到的一系列严重问题。 软件危机主要表现在：软件产品质量低和生产效率低，后期维护也不得力。 为了更好解决诸如此类的问题，软件规模化，工厂化的生产越发成为需要，软件工程便呼之欲出啦，需要解决以下问题： 软件开发进度难以预测 软件开发成本难以控制 用户对产品功能难以满足 软件产品质量无法保证 软件产品难以维护 软件缺少适当的文档资料 3. 软件的开发模型软件测试工作与软件开发模型息息相关，在不同的软件开发模型中，测试的任务和作用也不相同，因此测试人员要充分了解软件开发模型，以便找准自己在其中的定位与任务。 软件开发模型规定了软件开发应遵循的步骤，是软件开发的导航图，它能够清晰、直观地表达软件开发的全过程，以及每个阶段要进行的活动和要完成的任务。 开发人员在选择开发模型时，要根据软件的特点、开发人员的参与方式选择稳定可靠的开发模型自有软件开发以来，软件开发模型也从最初的“边做边改”发展出了多个模型，下面以软件开发模型发展历史为顺序，介绍几个典型的开发模型。 1）瀑布模型在20世纪70年代，由温斯顿·罗伊斯（Winston Royce）提出，瀑布模型一直是惟一被广泛采用的软件过程模型，现在它仍然是软件工程中应用得非常广泛的过程模型。瀑布模型是一种线形的、顺序的软件开发模型，主要分为6个阶段:可行性计划研究→需求分析→软件设计→编码→测试→运行维护，其开发过程如图下面所示。 在瀑布模型中，软件开发的各项活动严格按照这条线进行，只有当一个阶段任务完成之后才能开始下一个阶段。软件开发的每一个阶段都要有结果产出，结果经过审核验证之后作为下一个阶段的输入，下个阶段才可以顺利进行。如果结果审核验证不通过，则需要返回修改。 瀑布模型为整个项目划分了清晰的检查点，当一个阶段完成之后，只需要把全部精力放置在后面的开发上即可，它有利于大型软件开发人员的组织管理及工具的使用与研究，可以提高开发的效率。 但是瀑布模型是严格按照线性方式进行的，无法适应用户需求变更，用户只能等到最后才能看到开发成果，增加了开发风险。如果开发人员与客户对需求理解有偏差，到最后开发完成后，最终成果与客户需求可能会差之千里。使用瀑布模型开发软件时，如果早期犯的错误在项目完成后才发现，此时再修改原来的错误需要付出巨大的代价。瀑布模型要求每一个阶段必须有结果产出，这就势必增加了文档的数量，使软件开发的工作量变大。 2）V模型V 模型最早是由Paul Rook 在20 世纪80 年代后期提出的，V 模型在英国国家计算中心文献中发布，目的是改进软件开发的效率和效果。它是软件测试最具代表性的测试模型之一。 在传统的开发模型中，如瀑布模型，通常把软件测试过程作为在需求分析、概要设计、详细设计和编码全部完成之后的一个阶段，尽管有时软件测试工作会占整个项目周期一半的时间，但是仍然被认为软件测试只是一个收尾工作，而不是主要的工程。故对以前的测试模型进行了一定程度的改进，V 模型其实是软件开发瀑布模型的变种，反映了软件测试活动与软件开发过程(从分析到设计)的关系，如图 V 模型从左到右，描述了基本的开发过程和测试行为，明确地标明了测试工程中存在的不同级别以及测试阶段和开发过程各阶段的对应关系。图中箭头代表了时间方向，左边下降的是开发过程各阶段，与此相对应的是右边上升的部分，即测试过程各阶段。 V 模型指出，单元和集成测试是验证程序设计，单元测试主要由白盒测试工程对代码进行测试，但目前国内真正做白盒测试的企业不多。这主要有两大原因：第一，白盒测试投入的成本很高，并且产出不明显，很多企业不希望投入更多的资源去做这项工作;第二，白盒测试对测试工程师的要求较高，在目前系统测试还没有完全成熟的情况下很难真正地开展白盒测试。而集成测试是介于白盒测试与系统测试之间的一种测试，也叫灰盒测试，由于它与白盒测试和系统测试之间没有明显的界限，所以在实际的测试过程中，即使开展集成测试也是由系统测试工程师来完成。 系统测试主要验证系统设计，检测系统功能、性能的质量特性是否达到系统设计的指标，由测试人员和用户进行软件的确认测试和验收测试，以及对需求说明书进行测试，以确定软件的实现是否满足用户需求或合同要求。 V 模型存在一定的局限性，它把测试过程作为在需求分析、概要设计、详细设计及编码之后的一个阶段。如果不做白盒测试，那么其实都是在系统完成集成后才开始系统测试的，这样需求分析阶段隐藏的问题一直到后期的验收测试才被发现，因此修改缺陷的成本就高了很多。 3）快速原型模型快速原型模型与瀑布模型正好相反，它在最初确定用户需求时快速构造岀一个可以运行的软件原型，这个软件原型向用户展示待开发软件的全部或部分功能和性能，客户对该原型进行审核评价，然后给出更具体的需求意见，这样逐步丰富细化需求，最后开发人员与客户达成最终共识，确定客户的真正需求。确定客户的真正需求之后，开始真正的软件开发。 **快速原型模型类似于建造房子，确定客户对房子的需求之后快速地搭建一个房子模型**，由客户对房子模型进行评价，房子的样式、功能、布局等是否满足需求，哪里需要改进等，最后确定了客户对房子的要求，就开始真正地建造房子。该模型的开发过程如图 与瀑布模型相比，快速原型模型克服了需求不明确带来的风险，适用于不能预先确定需求的软件项目。但快速原型模型关键在于快速构建软件原型，准确地设计出软件原型存在定的难度。此外，这种开发模型也不利于开发人员对产品进行扩展。 4） 迭代模型迭代模型又称为增量模型或演化模型，它将一个完整的软件拆分成不同的组件，然后逐个组件地开发测试，每完成一个组件就展现给客户，让客户确认这一部件功能和性能是否达到客户需求，最终确定无误，将组件集成到软件体系结构中。 整个开发工作被组织为一系列短期、简单的小项目，称为一系列迭代，每一个迭代都需要经过需求分析→软件设计→编码→测试的过程，其开发过程如图 在迭代模型中，第一个迭代(即第一个组件)往往是软件基本需求的核心部分，第一个组件完成之后，经过客户审核评价形成下一个组件的开发计划，包括对核心产品的修改和新功能的发布，这样重复迭代步骤直到实现最终完善的产品。 迭代模型可以很好地适应客户需求变更，它逐个组件地交付产品，客户可以经常看到产品，如果某个组件没有满足客户需求，则只需要更改这一个组件，降低了软件开发的成本与风险。但是选代模型需要将开发完成的组件集成到软件体系结构中，这样会有集成失败的风险，因此要求软件必须有开放式的体系结构。此外，迭代模型逐个组件地开发修改，很容易退化为“边做边改”的开发形式，从而失去对软件开发过程的整体控制。 5）螺旋模型螺旋模型由巴利·玻姆(Barry Boehm)于1988年提岀，该模型融合了瀑布模型、快速原型模型，它最大的特点是引入了其他模型所忽略的风险分析，如果项目不能排除重大风险，就停止项目从而减小损失。这种模型比较适合开发复杂的大型软件。螺旋模型将整个项目开发过程划分为几个不同的阶段，每个阶段按部就班地执行，这种划分方式采用了瀑布模型。每个阶段在开始之前都要进行风险评估，如果能消除重大风险则可以开始该阶段任务。在每个阶段，首先构建软件原型，根据快速原型模型完成这个迭代过程，产出最终完善的产品，然后进入下一个阶段，同样下一个阶段开始之前也要进行风险评估，这样循环往复直到完成所有阶段的任务。螺旋模型的若干个阶段是沿着螺线方式进行的，如图 (1)制订计划:确定软件目标，制订实施方案，并且列出项目开发的限制条件。 (2)风险分析:评价所制订的实施方案，识别风险并消除风险。 (3)实施工程:开发产品并进行验证 (4)客户评估:客户对产品进行审核评估，提出修正建议，制订下一步计划。 在螺旋模型中，每一个选代都需要经过这4个步骤，直到最后得到完善的产品，可以进行提交。 螺旋模型强调了风险分析，这意味着对可选方案和限制条件都进行了评估，更有助于将软件质量作为特殊目标融入产品开发之中。它以小分段构建大型软件，使成本计算变得简单容易，而且客户始终参与每个阶段的开发，保证了项目不偏离正确方向，也保证了项目的可控制性。 4.软件开发生命周期软件和其他产品一样，都有一个从“出生”到“消亡”的过程，这个过程称为软件的生命周期。在软件的生命周期中，软件测试是非常重要的一个环节。 软件生命周期分为多个阶段，每个阶段有明确的任务，这样就使得结构复杂、管理复杂的软件开发变得容易控制和管理。通常，可将软件生命周期划分为6个阶段，如图所示。 每个阶段的目标任务及含义分别介绍如下： ****第1阶段:问题定义****，该阶段由软件开发方与需求方共同讨论，主要确定软件的开发目标及其可行性。 ****第2阶段:需求分析****，该阶段对软件需求进行更深入的分析，划分出软件需要实现的功能模块，并制作成文档。需求分析在软件的整个生命周期中起着非常重要的作用，它直接关系到后期软件开发的成功率。在后期开发中，需求可能会发生变化，因此，在进行需求分析时，应考虑到需求的变化，以保证整个项目的顺利进行。 ****第3阶段:软件设计****，该阶段在需求分析结果的基础上，对整个软件系统进行设计，如系统框架设计、数据库设计等。 ****第4阶段:软件开发****，该阶段在软件设计的基础上，选择一种编程语言进行开发。在开发过程中，必须要制订统一的、符合标准的程序编写规范，以保证程序的可读性、易维护性以及可移植性。 ****第5阶段:软件测试****，该阶段是软件开发完成后对软件进行测试，以查找软件设计与软件开发过程中存在的问题并加以修正。软件测试过程包括单元测试、集成测试、系统测试、验收测试等4个阶段;测试的方法以黑盒测试、白盒测试或者两者结合的形式进行。在测试过程中，为减少测试的随意性，需要制订详细的测试计划并严格遵守;测试完成之后，要对测试结果进行分析并对测试结果以文档的形式汇总。 ****第6阶段:软件维护****，软件完成测试并投入使用之后，面对庞大的用户群体，软件可能无法满足用户使用需求，此时就需要对软件进行维护升级以延续软件的使用寿命。软件的维护包括纠错性维护和改进性维护两个方面。软件维护是软件生命周期中持续时间最长的阶段。 5. 项目团队里面的成员及其职责项目经理：驱动整个项目的运转，负责制定计划，安排人力，管理进度，协调团队，进行重大决策。 架构师 / 系统工程师：技术专家，经验丰富，负责整个系统的体系架构的设计以及关键模块的设计。 程序员 / 开发人员：设计、编写软件，并修复软件中的缺陷。 测试工程师：负责找出软件产品存在的问题并报告。 实施/运维工程师：负责软件系统安装部署、升级维护。 资料工程师：负责编写软件产品附带的文件和联机帮助文档 配置管理员：负责管理程序员写的代码和资料工程师写的文档资料，并组合成一个软件包。 QA：质量监管人员 二、软件测试的基础理论1.软件测试的定义*软件测试的发展史：*20世纪60年代（软件工程建立前），为表明程序正确而进行测试。1972年在北卡罗来纳大学举行了首届软件测试正式会议。对软件测试给出了一个早期定义：*测试是为了让程序能够按照预期运行而建立的一种信心。* 1979年，Glenford Myers的《软件测试艺术》，对测试做了定义：*测试是为发现错误而执行的一个程序或者系统的过程。* 20世纪90年代，测试工具盛行起来。1996年提出的测试能力成熟度模型TMM（Testing Maturity Model）。 2009年，James A. Whittake提出探索式测试理论 ****什么是软件测试？软件测试是做什么的？****软件测试是使用人工或者自动手段运行或测定某个系统的过程，检验系统是否满足规定的需求，并找出预期结果与实际结果的差异 2.测试的对象根据软件的定义，软件包括程序、文档，所以软件测试并不仅仅是程序测试。软件测试贯穿于整个软件生命周期中。 由于在整个软件生命周期中，各阶段有不同的测试对象，形成了不同开发阶段的不同类型的测试。需求分析、概要设计、详细设计以及程序编码等各阶段产生的文档，包括需求规格说明、概要设计规格说明、详细设计规格说明以及源程序，都应作为“软件测试”的对象。 3.软件测试的目的软件测试的目的大家都能随口说出，如查找程序中的错误、保证软件质量、检验软件是否符合客户需求等。这些都对，但它们只是笼统地对软件测试目的进行了概括，比较片面结合软件开发、软件测试与客户需求可以将软件测试的目的归结为以下几点。 1) 预防缺陷，减少产品的风险：对于软件开发来说，软件测试通过找到的问题缺陷帮助开发人员找到开发过程中存在的问题，包括软件开发的模式、工具、技术等方面存在的问题与不足，预防下次缺陷的产生。 2）****发现被测对象与用户需求之间的差异（俗称找BUG 3) *通过测试活动发现并解决缺陷，增加人们对被测对象的质量信心；* 4) ****通过测试活动，发现被测对象的质量信息，为决策者提供数据依据****； 4.软件测试所遵循的原则软件测试经过几十年的发展，人们提出了很多测试的基本原则用于指导软件测试工作。制定软件测试的基本原则有助于提高测试工作的效率和质量，能让测试人员以最少的人力物力、时间等尽早发现软件中存在的问题，测试人员应该在测试原则的指导下进行测试工作。下面介绍一下业界公认的6个基本原则。 1.测试应该基于客户的需求所有的测试工作都应该建立在满足客户需求的基础上，从客户角度来看，最严重的错误就是软件无法满足要求。有时候，软件产品的测试结果非常完美，但却不是客户最终想要的产品，那么软件产品的开发就是失败的，而测试工作也是没有任何意义的。因此测试应依照客户的需求配置环境，并且按照客户的使用习惯进行测试并评价结果。 2.测试要尽早进行软件的错误存在于软件生命周期的各个阶段，因此应该尽早开展测试工作，把软件测试贯穿到软件生命周期的各个阶段中，这样测试人员能够尽早地发现和预防错误，降低错误修复的成本。尽早地开展测试工作有利于帮助测试人员了解软件产品的需求和设计，从而预测测试的难度和风险，制订出完善的计划和方案，提高测试的效率。 3.穷尽测试是不可能的由于时间和资源的限制，进行完全(各种输入和输出的全部组合)的测试是不可能的测试人员可以根据测试的风险和优先级等确定测试的关注点，从而控制测试的工作量，在测试成本、风险和收益之间求得平衡。 4.测试缺陷要符合“二八”定理缺陷的“二八”定理也称为Pareto原则、缺陷集群效应，一般情况下，软件80%缺陷会集中在20%模块中，缺陷并不是平均分布的。因此在测试时，要抓住主要矛盾，如果发现某些模块比其他模块具有更多的缺陷，则要投入更多的人力、精力重点测试这些模块以提高测试效率。 5.杀虫剂的悖论我们都知道虫子的抗药性原理，即一种药物使用久了，虫子就会产生抗药性。而在软件测试中，缺陷也是会产生免疫性的。同样的测试用例被反复使用，发现缺陷的能力就会越来越差;测试人员对软件越熟悉越会忽略一些看起来比较小的问题，发现缺陷的能力也越差，这种现象被称为软件测试的“杀虫剂”现象。它主要是由于测试人员没有及时更新测试用例或者是对测试用例和测试对象过于熟悉，形成了思维定式。 要克服这种情况，就要不断对测试用例进行修改和评审，不断增加新的测试用例，同时，测试人员也要发散思维，不能只是为了完成测试任务而做一些输入和输出的对比。 6.没有缺陷的软件是不存在的没有缺陷的软件是不存在的，软件测试是为了找出软件中的缺陷，而不是为了证明软件没有缺陷。 5.测试风险软件测试中的软件风险分析是根据预测软件将出现的风险，制定软件测试计划并排列优先等级，风险分析是对软件中潜在的问题进行识别、估计和评价的过程。 风险也包括进度风险、质量风险、人员风险、变更风险、成本风险等 6.软件的质量软件质量就是“软件与明确的和隐含的定义的需求相一致的程度” 明确的需求指：软件符合明确叙述的功能和性能需求、文档中明确描述的开发标准； 隐性的需求指：所有专业开发的软件都应具有的隐含特征的程度，需要引导的用户需求。 1.软件的质量特点功能性：软件在指定条件下使用时，满足用户明确和隐含需求的功能的能力 可靠性：软件在指定条件下使用时，维持规定的性能级别的能力 易用性：在指定条件下使用时，软件被理解、学习、使用和吸引用户的能力 可维护：软件从一种环境迁移到另外一种环境的能力 2. 那些原因影响软件的质量由于软件自身的特点和目前的软件开发模式使得隐藏在软件内部的质量缺陷无法完全根除,因此每一款软件都会存在一些质量问题。影响软件质量的因素有很多,下面介绍几种比较常见的影响因素。 a. 需求模糊在软件开发之前,确定软件需求是一项非常重要的工作,它是后面软件设计与软件开发的基础,也是最后软件验收的标准。但是软件需求是不可视的,往往也说不清楚,导致产品设计、开发人员与客户存在一定的理解误差,开发人员对软件的真正需求不明确,结果开发出的产品与实际需求不符,这势必会影响软件的质量。 除此之外,在开发过程中客户往往会一而再再而三地变更需求,导致开发人员频繁地修改代码,这可能会导致软件在设计时期存在不能调和的误差,最终影响软件的质量。 b. 开发过程不规范现代软件开发,大多数团队都将精力放在开发成本与开发周期上,而不太重视团队成员的工作规范,导致团队成员开发“随意性”比较大,这也会影响软件质量,而且一旦最后软件出现质量问题,也很难定责,导致后期维护困难 c. 软件开发人员问题软件是由人开发出来的,因此个人的意识对产品的影响非常大。除了个人技术水平限制,开发人员问题还包括人员流动,新来的成员可能会继承上一任的产品接着开发下去,两个人的思维意识、技术水平等都会不同,导致软件开发前后不一致,进而影响软件质量。 d. 软件缺乏质量控制管理在软件开发行业,并没有一个量化的指标去度量一款软件的质量,软件开发的管理人员更关注开发成本和进度,毕竟这是显而易见的,并且是可以度量的。但软件质量则不同,软件质量无法用具体的量化指标去度量,而且软件开发的质量并没有落实到具体的责任人,因此很少有人关心软件最终的质量。 7.软件测试的分类目前，软件测试已经形成一个完整的、体系庞大的学科，不同的测试领域都有不同的测试方法、技术与名称，有很多读者可能也听过类似的黑盒测试、白盒测试、冒烟测试、单元测试等，其实它们是按照不同的分类方法而产生的测试名称。按照不同的分类标准，可以将软件测试分为很多不同的种类，下面我们详细介绍这些软件测试行业的专业名词。 按照测试阶段划分 ① 单元测试 单元测试是软件开发的第一步测试，目的是为了验证软件单元是否符合软件需求与设计。单元测试大多是开发人员进行的自测。 ② 冒烟测试 冒烟测试最初是从电路板测试得来的，当电路板做好以后，首先会加电测试，如果电路板没有冒烟再进行其他测试，否则就必须重新设计后再次测试。 后来这种测试理念被引入到软件测试中。在软件测试中，冒烟测试是指软件构建版本建立后，对系统的基本功能进行简单的测试，这种测试重点验证的是程序的主要功能，而不会对具体功能进行深入测试。 如果测试未通过，需要返回给开发人员进行修正;如果测试通过则再进行其他测试。因此，冒烟测试是对新构建版本软件进行的最基本测试。 ③ 集成测试 集成测试是冒烟测试之后进行的测试，它是将已经测试过的软件单元组合在一起测试它们之间的接口，用于验证软件是否满足设计需求。 ④ 系统测试 系统测试是将经过测试的软件在实际环境中运行，并与其他系统的成分(如数据库、硬件和操作人员等)组合在一起进行的测试。 ⑤ 验收测试 验收测试主要是对软件产品说明进行验证，逐行逐字地按照说明书的描述对软件产品进行测试，确保其符合客户的各项要求。 按照测试技术分类 按照使用的测试技术可以将软件测试分为黑盒测试与白盒测试。 黑盒测试不需要关注被测对象的内部结构，仅从用户需求的角度去考虑，是否满足显性或者隐性的需求。如图 白盒测试白盒测试又叫透明盒测试，它是指测试人员了解软件程序的逻辑结构、路径与运行过程，在测试时，按照程序的执行路径得出结果。白盒测试就是把软件(程序)当作一个透明的盒子，测试人员清楚地知道从输入到输出的每一步过程，如图白盒测试 白盒测试又叫透明盒测试，它是指测试人员了解软件程序的逻辑结构、路径与运行过程，在测试时，按照程序的执行路径得出结果。白盒测试就是把软件(程序)当作一个透明的盒子，测试人员清楚地知道从输入到输出的每一步过程，如图 相对于黑盒测试来说，白盒测试对测试人员的要求会更高一点，他要求测试人员具有一定的编程能力，而且要熟悉各种脚本语言。但是在软件公司里，黑盒测试与白盒测试并不是界限分明的，在测试一款软件时往往是黑盒测试与白盒测试相结合对软件进行完整全面的测试。 按照软件质量分类 按照软件质量特性可以将软件测试分为功能测试与性能测试。 ① 功能测试 功能测试就是测试软件的功能是否满足客户的需求，包括准确性、易用性、适合性、互操作性等。 ② 性能测试 性能测试就是测试软件的性能是否满足客户的需求，性能测试包括负载测试、压力测试、兼容性测试、可移植性测试和健壮性测试。 按照自动化程度来分类 按照自动化程度可以将软件测试分为手工测试与自动化测试。 ① 手工测试 手工测试是测试人员一条一条地执行代码完成测试工作。手工测试比较耗时费力，而且测试人员如果是在疲惫状态下，则很难保证测试的效果。 ② 自动化测试 自动化测试是借助脚本、自动化测试工具等完成相应的测试工作，它也需要人工的参与，但是它可以将要执行的测试代码或流程写成脚本，执行脚本完成整个测试工作。 按照测试类型分类 软件测试类型有多种，包括界面类测试、功能测试、性能测试、安全性测试、文档测试等，其中功能测试与性能测试前面已经介绍，下面主要介绍其他几种测试。 ① 界面类测试 界面类测试是验证软件界面是否符合客户需求，包括界面布局是否美观、按钮是否齐全等。 ② 安全性测试 安全性测试是测试软件在没有授权的内部或外部用户的攻击或恶意破坏时如何进行处理，是否能保证软件与数据的安全。 ③ 文档测试 文档测试以需求分析、软件设计、用户手册、安装手册为主，主要验证文档说明与实际软件之间是否存在差异。 其他分类 还有一些软件测试无法具体归到哪一类，但在测试行业中也会经常进行这些测试，如α测试、β测试、回归测试等，具体介绍如下。 ① *α测试* α测试是指对软件最初版本进行测试。软件最初版本一般不对外发布，在上线之前，由开发人员和测试人员或者用户协助进行测试。测试人员记录使用过程中出现的错误与问题整个测试过程是可控的。 ② *β测试* β测试是指对上线之后的软件版本进行测试，此时软件已上线发布，但发布的版本中可能会存在较轻微的Bug，由用户在使用过程中发现错误与问题并进行记录，然后反馈给开发人员进行修复。 ③ *回归测试* 当测试人员发现缺陷以后，会将缺陷提交给开发人员，开发人员对程序进行修改，修改之后，测试人员会对修改后的程序重新进行测试，确认原有的缺陷已经消除并且没有引入新的缺陷，这个重新测试的过程就叫作回归测试。回归测试是软件测试工作中非常重要的一部分，软件开发的各个阶段都会进行多次回归测试。 ④ *随机测试* 随机测试是没有测试用例、检查列表、脚本或指令的测试，它主要是根据测试人员的经验对软件进行功能和性能抽查。随机测试是根据测试用例说明书执行测试用例的重要补充手段，是保证测试覆盖完整性的有效方式和过程。 三、软件测试的流程1.测试需求分析阶段：阅读需求，理解需求，主要就是对业务的学习，分析需求点，参与需求评审会议; 2.测试计划阶段：根据自己的角色说明 如:测试经理主要任务就是编写测试计划，参考软件需求规格说明书，项目总体计划，内容包括测试范围(来自需求文档)，进度安排，人力物力的分配，整体测试策略的制定。风险评估与规避措施有一个制定。测试人员的话一般是领取分配的测试任务; 3.测试设计阶段：主要是编写测试用例，会参考需求文档(原型图)，概要设计，详细设计等文档，用例编写完成之后会进行评审; 4.测试执行阶段：搭建环境，执行冒烟测试(预测试)，然后进入正式测试，bug管理,根据公司情况进行日报,周报跟踪进度及风险控制; 5.测试评估阶段：出测试报告，确认是否可以上线。 四、测试相关文档介绍在软件研发过程当中，会产生很多的文档，下面罗列测试阶段所产生的文档，包含但不仅限于如下文档。 *文档的名称* *包括但不限于以下内容* *文档编写目的* 测试计划 测试的范围、测试的准则、测试的手段、测试工具、停止的标准、硬/软件环境、测试规划、测试执行、工作量预估、资源安排、进度安排、风险管理等。 明确测试工作内容（范围）、测试工作的方法以及测试工作所需要的各种资源。 测试用例 用例编号、用例名称、测试背景、测试数据、操作步骤、预期结果、实际结果、优先级、重要级、编写人、执行人、备注等。 避免漏测、多测，能够对项目的需求做一个理解，可以作为测试人员工作量的一个考核。 缺陷报告 缺陷编号、缺陷描述、严重度、缺陷状态、发现人、发现时间、修复时间、所属版本、所属模块、修复的优先级、详细描述、下一步处理人等。 把软件存在的缺陷准确的描述出来，便于开发人员修正，反映了当前产品的质量状态，更是测试人员价值的体现。 测试报告 包括项目背景、需求分析、测试时间、测试环境、评审记录、测试范围、测试用例、功能实现清单、缺陷统计、测试统计(包含资源、执行、问题统计)、测试总结是否通过、测试的风险。 把测试的过程和结果写成文档，对发现的问题和缺陷进行分析，为纠正软件的存在的质量问题提供依据，同时为软件验收和交付打下基础。 测试日、周报 1.当前测试进度的关键性数据(用例执行进度、发现问题情况、待回归的问题)2.遇到哪些测试活动中不能解决的问题风险，需要什么样的帮助。3.下一阶段的工作计划是什么？ 要求内容是每日/周测试活动的概述，和下一天/周测试活动的计划，要求反映出当前测试进度，成果及问题。","categories":[],"tags":[{"name":"软件测试理论","slug":"软件测试理论","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"}],"keywords":[]}]}